<!--   ***********  Web Authentication - Level 3 - Spec source file ***********
Notes:
* the h1 tag is spec title that is rendered within the document window. Wrapping
  may be controlled with break tags.  The spec 'Level' value is not appended.
* the Title metadata value is what is rendered in the browser's titlebar, any break
  tags will be rendered. It also has the spec 'Level' value (gratuitously) appended.
-->

<h1>Web Authentication:<br>An API for accessing Public Key Credentials<br>Level 3</h1>
<pre class='metadata'>
Title: Web Authentication: An API for accessing Public Key Credentials - Level
Status: ED
Prepare for TR: true
TR: https://www.w3.org/TR/webauthn-3/
ED: https://w3c.github.io/webauthn/
Previous Version: https://www.w3.org/TR/2021/REC-webauthn-2-20210408/
Previous Version: https://www.w3.org/TR/2019/REC-webauthn-1-20190304/
Shortname: webauthn
Level: 3
Include MDN Panels: maybe
Editor: Michael B. Jones, w3cid 38745, Microsoft, mbj@microsoft.com
Editor: Akshay Kumar, w3cid 99318, Microsoft, akshayku@microsoft.com
Editor: Emil Lundberg, w3cid 102508, Yubico, emil@yubico.com
Former Editor: Dirk Balfanz, w3cid 47648, Google, balfanz@google.com
Former Editor: Vijay Bharadwaj, w3cid 55440, Microsoft, vijay.bharadwaj@microsoft.com
Former Editor: Arnar Birgisson, w3cid 87332, Google, arnarb@google.com
Former Editor: Alexei Czeskis, w3cid 87258, Google, aczeskis@google.com
Former Editor: Jeff Hodges, w3cid 43843, formerly Google
Former Editor: J.C. Jones, w3cid 87240, formerly Mozilla
Former Editor: Hubert Le Van Gong, w3cid 84817, PayPal, hlevangong@paypal.com
Former Editor: Angelo Liao, w3cid 94342, Microsoft, huliao@microsoft.com
Former Editor: Rolf Lindemann, w3cid 84447, Nok Nok Labs, rolf@noknok.com
!Contributors: <a href="mailto:WebAuthn@ve7jtb.com">John Bradley</a> (Yubico)
!Contributors: <a href="mailto:cbrand@google.com">Christiaan Brand</a> (Google)
!Contributors: <a href="mailto:tim.cappalli@microsoft.com">Tim Cappalli</a> (Microsoft)
!Contributors: <a href="mailto:agl@google.com">Adam Langley</a> (Google)
!Contributors: <a href="mailto:mandyam@qti.qualcomm.com">Giridhar Mandyam</a> (Qualcomm)
!Contributors: <a href="mailto:mattmil3@cisco.com">Matthew Miller</a> (Cisco)
!Contributors: <a href="mailto:nsatragno@google.com">Nina Satragno</a> (Google)
!Contributors: <a href="mailto:nick.steele@gemini.com">Nick Steele</a> (Gemini)
!Contributors: <a href="mailto:jiewen_tan@apple.com">Jiewen Tan</a> (Apple)
!Contributors: <a href="mailto:sweeden@au1.ibm.com">Shane Weeden</a> (IBM)
!Contributors: <a href="mailto:mkwst@google.com">Mike West</a> (Google)
!Contributors: <a href="mailto:jyasskin@google.com">Jeffrey Yasskin</a> (Google)
group: webauthn
Issue Tracking: GitHub https://github.com/w3c/webauthn/issues
!Tests: <a href=https://github.com/web-platform-tests/wpt/tree/master/webauthn>web-platform-tests webauthn/</a> (<a href=https://github.com/web-platform-tests/wpt/labels/webauthn>ongoing work</a>)
Text Macro: FALSE <code>false</code>
Text Macro: PII personally identifying information
Text Macro: RP Relying Party
Text Macro: RPS Relying Parties
Text Macro: INFORMATIVE <em>This section is not normative.</em>
Text Macro: TRUE <code>true</code>
Text Macro: WAA WebAuthn Authenticator
Text Macro: WAC WebAuthn Client
Text Macro: WRP WebAuthn Relying Party
Text Macro: WRPS WebAuthn Relying Parties
Ignored Vars: op, alg, type, algorithm
Abstract: This specification defines an API enabling the creation and use of strong, attested, [=scoped=], public key-based
 credentials by [=web applications=], for the purpose of strongly authenticating users. Conceptually, one or more [=public key
 credentials=], each [=scoped=] to a given [=WebAuthn Relying Party=], are created by and [=bound credential|bound=] to
 [=authenticators=] as requested by the web application. The user agent mediates access to [=authenticators=] and their [=public
 key credentials=] in order to preserve user
 privacy. [=Authenticators=] are responsible for ensuring that no operation is performed without [=user consent=].
 [=Authenticators=] provide cryptographic proof of their properties to [=Relying Parties=] via [=attestation=]. This
 specification also describes the functional model for WebAuthn conformant [=authenticators=], including their signature and
 [=attestation=] functionality.
Boilerplate: omit conformance, omit feedback-header, omit abstract-header
Markup Shorthands: css off, markdown on
Implementation Report: https://www.w3.org/2020/12/webauthn-report.html
</pre>

<style type="text/css">
body {
    counter-reset: table;
}
/* For some reason, doing the counter-increment on the figcaption like Bikeshed does with figures does not seem to work here. */
figure.table {
    counter-increment: table;
}
figure.table figcaption {
    counter-increment: none;
}
figure.table figcaption:not(.no-marker)::before {
    content: "Table " counter(table) " ";
}
figure.table .overlarge {
    max-width: 50em;
}

.figure-num-following::before {
    counter-increment: figure;
    content: counter(figure)
}

.figure-num-following::after {
    counter-increment: figure -1;
    content: ""
}

.figure-num-previous::before {
    content: counter(figure);
}

.table-ref-previous::before {
    content: counter(table);
}

.table-ref-following::before {
    counter-increment: table;
    content: counter(table);
}

.table-ref-following::after {
    counter-increment: table -1;
    content: "";
}
</style>


<pre class="link-defaults">

spec: dom; type: interface; for:/; text: Document


</pre>



<!-- TODO: Clean out these anchor lists once they appear in Shepherd -->
<pre class="anchors">

spec: ECMAScript; urlPrefix: https://tc39.github.io/ecma262/#
    type: method
        for: JSON; text: stringify; url: sec-json.stringify
    type: dfn
        text: %ArrayBuffer%; url: sec-arraybuffer-constructor
        url: sec-object-internal-methods-and-internal-slots
            text: internal method
            text: internal slot
        text: own property; url: sec-own-property

spec: RFC9052; urlPrefix: https://tools.ietf.org/html/rfc9052
    type: dfn; for: RFC9052
        text: COSE key; url: name-key-objects
        text: kty; url: name-cose-key-common-parameters
        text: section 7; url: section-7

spec: RFC9053; urlPrefix: https://tools.ietf.org/html/rfc9053
    type: dfn; for: RFC9053
        text: crv; url: name-double-coordinate-curves
        text: section 2.1; url: section-2.1
        text: section 2; url: section-2
        text: section 7.1; url: section-7.1

spec: RFC8230; urlPrefix: https://tools.ietf.org/html/rfc8230
    type: dfn; for: RFC8230
        text: Section 4; url: section-4
        text: Section 2; url: section-2

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        urlPrefix: dom.html
            for: Document; url: concept-document-permissions-policy; text: permissions policy
        urlPrefix: browsers.html
            text: browsing context; url: browsing-context
        urlPrefix: origin.html
            text: origin; url: concept-origin
            text: opaque origin; url: concept-origin-opaque
            text: tuple origin; url: concept-origin-tuple
            text: document.domain; url:dom-document-domain
        urlPrefix: form-control-infrastructure.html
            text: autofill detail token; url: autofill-detail-tokens

spec: url; urlPrefix: https://url.spec.whatwg.org
    type: dfn
        text: scheme; url: concept-url-scheme
        text: port; url: concept-url-port


spec: TokenBinding; urlPrefix: https://tools.ietf.org/html/rfc8471#
    type: dfn
        text: Token Binding; url: section-1
        text: Token Binding ID; url: section-3.2

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dictionary
        text: CredentialCreationOptions; url: dictdef-credentialcreationoptions
    type: dictionary
        text: CredentialRequestOptions; url: dictdef-credentialrequestoptions
    for: Credential
        type: method
            text: [[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)
            text: [[Create]](origin, options, sameOriginWithAncestors)
            text: [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
            text: [[Store]](credential, sameOriginWithAncestors)
    for: CredentialsContainer
        type: method
            text: create(); url: dom-credentialscontainer-create
    type: dfn
        text: signal
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors

spec: Geolocation-API; urlPrefix: https://w3c.github.io/geolocation-api/
    type: interface
        text: GeolocationCoordinates; url: coordinates_interface

spec: mixed-content; urlPrefix: www.w3.org/TR/mixed-content/
    type: dfn
        text: a priori authenticated

spec: page-visibility; urlPrefix: https://www.w3.org/TR/page-visibility/
    type: dfn
        text: visibility states

spec: WHATWG HTML; urlPrefix: https://html.spec.whatwg.org/
    type: dfn
        text: focus
        text: username; url: attr-fe-autocomplete-username

spec: WHATWG URL; urlPrefix: https://url.spec.whatwg.org/
    type: dfn
        text: same site; url: host-same-site

spec: FIDO-CTAP; urlPrefix: https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.html
    type: dfn
        text: CTAP2 canonical CBOR encoding form; url: ctap2-canonical-cbor-encoding-form
        text: §6.2. Responses; url: responses
        text: large, per-credential blobs; url: large-blob

spec: FIDO-APPID; urlPrefix: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-appid-and-facets-v2.0-id-20180227.html
    type: dfn
        text: determining the FacetID of a calling application; url: determining-the-facetid-of-a-calling-application
        text: determining if a caller's FacetID is authorized for an AppID; url: determining-if-a-caller-s-facetid-is-authorized-for-an-appid

spec: FIDO-U2F-Message-Formats; urlPrefix: https://fidoalliance.org/specs/fido-u2f-v1.1-id-20160915/fido-u2f-raw-message-formats-v1.1-id-20160915.html
    type: dfn; for: FIDO-U2F-Message-Formats
        text: application parameter; url: authentication-request-message---u2f_authenticate
        text: Section 4.3; url: registration-response-message-success
        text: Section 5.4; url: authentication-response-message-success

spec: FIDO-Registry; urlPrefix: https://fidoalliance.org/specs/common-specs/fido-registry-v2.1-ps-20191217.html
    type: dfn; for: FIDO-Registry
        text: Section 3.1 User Verification Methods; url: user-verification-methods
        text: Section 3.2 Key Protection Types; url: key-protection-types
        text: Section 3.3 Matcher Protection Types; url: matcher-protection-types
        text: Section 3.6.2 Public Key Representation Formats; url: public-key-representation-formats

spec: RFC4949; urlPrefix: https://tools.ietf.org/html/rfc4949
    type: dfn
        text: leap of faith; url: page-182
        text: man-in-the-middle attack; url: page-186
        text: salt; url: page-258
        text: salted; url: page-258

spec: SP800-800-63r3; urlPrefix: https://pages.nist.gov/800-63-3/sp800-63-3.html
    type: dfn
        text: authentication factor; url: af
        text: multi-factor; url: af
        text: second-factor; url: af
        text: single-factor; url: sf
        text: something you know; url: af
        text: something you have; url: af
        text: something you are; url: af

spec: webidl; urlPrefix: https://heycam.github.io/webidl
    type: dfn;
        text: get a copy of the bytes held by the buffer source; url: dfn-get-buffer-source-copy

spec: webdriver; urlPrefix: https://w3c.github.io/webdriver/
    type: dfn
        text: WebDriver error; url: dfn-error
        text: WebDriver error code; url: dfn-error-code
        text: endpoint node; url: dfn-endpoint-node
        text: extension capability; url: dfn-extension-capability
        text: extension command; url: dfn-extension-commands
        text: getting a property; url: dfn-getting-properties
        text: set a property; url: dfn-set-a-property
        text: invalid argument; url: dfn-invalid-argument
        text: matching capabilities; url: dfn-matching-capabilities
        text: remote end steps; url: dfn-remote-end-steps
        text: success; url: dfn-success
        text: unsupported operation; url: dfn-unsupported-operation
        text: validating capabilities; url: dfn-validate-capabilities

spec: UTR29
    urlPrefix: https://unicode.org/reports/tr29/
        type: dfn; for:/; url: Grapheme_Cluster_Boundaries; text: grapheme cluster

spec: RFC5280; urlPrefix: https://tools.ietf.org/html/rfc5280
    type: dfn
        text: SubjectPublicKeyInfo; url: section-4.1.2.7

spec: RFC8610; urlPrefix: https://tools.ietf.org/html/rfc8610
    type: dfn
        text: group sockets; url: section-3.9

spec: BCP47; urlPrefix: https://tools.ietf.org/html/bcp47
    type: dfn
        text: language tag; url: section-2.1

</pre> <!-- class=anchors -->

<!-- L128 spec:webappsec-credential-management-1; type:dictionary; for:/; text:CredentialRequestOptions -->

<pre class="link-defaults">
spec:credential-management; type:dfn; text:credentials
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:/; text:same site
spec:infra; type:dfn; for:/; text:set
spec:infra; type:dfn; text:list
spec:infra; type:dfn; for:struct; text:item
spec:infra; type:dfn; for:map; text:exists
spec:url; type:dfn; text:domain
spec:url; type:dfn; for:url; text:host
spec:url; type:dfn; text:valid domain;
spec:webidl; type:dfn; text:DOMString
spec:webidl; type:dfn; text:USVString
spec:webidl; type:interface; text:Promise
</pre>


# Introduction # {#sctn-intro}

[INFORMATIVE]

This specification defines an API enabling the creation and use of strong, attested, [=scoped=], public key-based
credentials by [=web applications=], for the purpose of strongly authenticating users. A [=public key credential=] is
created and stored by a <em>[=[WAA]=]</em> at the behest of a <em>[=[WRP]=]</em>, subject to <em>[=user
consent=]</em>. Subsequently, the [=public key credential=] can only be accessed by [=origins=] belonging to that [=[RP]=].
This scoping is enforced jointly by <em>[=conforming User Agents=]</em> and <em>[=authenticators=]</em>.
Additionally, privacy across [=[RPS]=] is maintained; [=[RPS]=] are not able to detect any properties, or even
the existence, of credentials [=scoped=] to other [=[RPS]=].

[=[RPS]=] employ the [=Web Authentication API=] during two distinct, but related, [=ceremonies=] involving a user. The first
is [=Registration=], where a [=public key credential=] is created on an [=authenticator=], and [=scoped=] to a [=[RP]=]
with the present user's account (the account might already exist or might be created at this time). The second is
[=Authentication=], where the [=[RP]=] is presented with an <em>[=Authentication Assertion=]</em> proving the presence
and [=user consent|consent=] of the user who registered the [=public key credential=]. Functionally, the [=Web Authentication
API=] comprises a {{PublicKeyCredential}} which extends the Credential Management API [[!CREDENTIAL-MANAGEMENT-1]], and
infrastructure which allows those credentials to be used with {{CredentialsContainer/create()|navigator.credentials.create()}} and
{{CredentialsContainer/get()|navigator.credentials.get()}}. The former is used during [=Registration=], and the
latter during [=Authentication=].

Broadly, compliant [=authenticators=] protect [=public key credentials=], and interact with user agents to implement the
[=Web Authentication API=].
Implementing compliant authenticators is possible in software executing
(a) on a general-purpose computing device,
(b) on an on-device Secure Execution Environment, Trusted Platform Module (TPM), or a Secure Element (SE), or
(c) off device.
Authenticators being implemented on device are called [=platform authenticators=].
Authenticators being implemented off device ([=roaming authenticators=]) can be accessed over a transport such
as Universal Serial Bus (USB), Bluetooth Low Energy (BLE), or Near Field Communications (NFC).

## Specification Roadmap ## {#sctn-spec-roadmap}

While many W3C specifications are directed primarily to user agent developers and also to web application developers
(i.e., "Web authors"), the nature of Web Authentication requires that this specification be correctly used by multiple audiences,
as described below.

**All audiences** ought to begin with [[#sctn-use-cases]], [[#sctn-sample-scenarios]], and [[#sctn-terminology]], and should also
refer to [[WebAuthnAPIGuide]] for an overall tutorial.
Beyond that, the intended audiences for this document are the following main groups:

- [=[RP]=] web application developers, especially those responsible for [=[RP]=] [=web application=] login flows, account recovery flows,
    user account database content, etc.
- Web framework developers

    - The above two audiences should in particular refer to [[#sctn-rp-operations]].
        The introduction to [[#sctn-api]] may be helpful, though readers should realize that the [[#sctn-api]] section is targeted specifically
        at user agent developers, not web application developers.
        Additionally, if they intend to verify [=authenticator=] [=attestations=], then
        [[#sctn-attestation]] and [[#sctn-defined-attestation-formats]] will also be relevant.
        [[#sctn-extensions]], and [[#sctn-defined-extensions]] will be of interest if they wish to make use of extensions.
        Finally, they should read [[#sctn-security-considerations-rp]] and [[#sctn-privacy-considerations-rp]]
        and consider which challenges apply to their application and users.

- User agent developers
- OS platform developers, responsible for OS platform API design and implementation in regards to platform-specific
    [=authenticator=] APIs, platform [=WebAuthn Client=] instantiation, etc.

    - The above two audiences should read [[#sctn-api]] very carefully, along with [[#sctn-extensions]] if they intend to support extensions.
        They should also carefully read
        <!-- no sec cons for clients enumerated at this time
        [[#sctn-security-considerations-client]] and
        -->
        [[#sctn-privacy-considerations-client]].

- [=Authenticator=] developers. These readers will want to pay particular attention to [[#sctn-authenticator-model]],
    [[#sctn-defined-attestation-formats]], [[#sctn-extensions]], and [[#sctn-defined-extensions]].
    They should also carefully read [[#sctn-security-considerations-authenticator]] and [[#sctn-privacy-considerations-authenticator]].

<div class="note">
    Note: Along with the [[#sctn-api|Web Authentication API]] itself, this specification defines a
    request-response <em>cryptographic protocol</em>&mdash;the
    <dfn export>WebAuthn/FIDO2 protocol</dfn>&mdash;between
    a [=[WRP]=] server and an [=authenticator=], where the [=[RP]=]'s request consists of a
    [[#sctn-cryptographic-challenges|challenge]] and other
    input data supplied by the [=[RP]=] and sent to the [=authenticator=].
    The request is conveyed via the
    combination of HTTPS, the [=[RP]=] [=web application=], the [[#sctn-api|WebAuthn API]], and the platform-specific communications channel
    between the user agent and the [=authenticator=].
    The [=authenticator=] replies with a digitally signed [=authenticator data=] message and other output data, which is conveyed back to the
    [=[RP]=] server via the same path in reverse. Protocol details vary according to whether an [=authentication=] or
    [=registration=] operation is invoked by the [=[RP]=].
    See also [Figure 1](#fig-registration) and [Figure 2](#fig-authentication).

    <strong>It is important for Web Authentication deployments' end-to-end security</strong> that the role of each
    component&mdash;the [=[RP]=] server, the [=client=], and the [=authenticator=]&mdash;
    as well as [[#sctn-security-considerations]] and [[#sctn-privacy-considerations]], are understood <em>by all audiences</em>.
</div>

## Use Cases ## {#sctn-use-cases}

The below use case scenarios illustrate use of two very different types of [=authenticators=], as well as outline further
scenarios. Additional scenarios, including sample code, are given later in [[#sctn-sample-scenarios]].

### Registration ### {#sctn-usecase-registration}

- On a phone:
    * User navigates to example.com in a browser and signs in to an existing account using whatever method they have been using
        (possibly a legacy method such as a password), or creates a new account.
    * The phone prompts, "Do you want to register this device with example.com?"
    * User agrees.
    * The phone prompts the user for a previously configured [=authorization gesture=] (PIN, biometric, etc.); the user
        provides this.
    * Website shows message, "Registration complete."


### Authentication ### {#sctn-usecase-authentication}

- On a laptop or desktop:
    * User pairs their phone with the laptop or desktop via Bluetooth.
    * User navigates to example.com in a browser and initiates signing in.
    * User gets a message from the browser, "Please complete this action on your phone."

- Next, on their phone:
    * User sees a discrete prompt or notification, "Sign in to example.com."
    * User selects this prompt / notification.
    * User is shown a list of their example.com identities, e.g., "Sign in as Mohamed / Sign in as 张三".
    * User picks an identity, is prompted for an [=authorization gesture=] (PIN, biometric, etc.) and provides this.

- Now, back on the laptop:
    * Web page shows that the selected user is signed in, and navigates to the signed-in page.


### New Device Registration ### {#sctn-usecase-new-device-registration}

This use case scenario illustrates how a [=[RP]=] can leverage a combination of a [=roaming authenticator=] (e.g., a USB security
key fob) and a [=platform authenticator=] (e.g., a built-in fingerprint sensor) such that the user has:

  - a "primary" [=roaming authenticator=] that they use to authenticate on new-to-them [=client devices=] (e.g., laptops,
    desktops) or on such [=client devices=] that lack a [=platform authenticator=], and
  - a low-friction means to strongly re-authenticate on [=client devices=] having [=platform authenticators=].

Note: This approach of registering multiple [=authenticators=] for an account is also useful in account recovery use cases.

- First, on a desktop computer (lacking a [=platform authenticator=]):
    * User navigates to `example.com` in a browser and signs in to an existing account using whatever method they have been using
        (possibly a legacy method such as a password), or creates a new account.
    * User navigates to account security settings and selects "Register security key".
    * Website prompts the user to plug in a USB security key fob; the user does.
    * The USB security key blinks to indicate the user should press the button on it; the user does.
    * Website shows message, "Registration complete."

    Note: Since this computer lacks a [=platform authenticator=], the website may require the user to present their USB security
    key from time to time or each time the user interacts with the website. This is at the website's discretion.

- Later, on their laptop (which features a [=platform authenticator=]):
    * User navigates to example.com in a browser and initiates signing in.
    * Website prompts the user to plug in their USB security key.
    * User plugs in the previously registered USB security key and presses the button.
    * Website shows that the user is signed in, and navigates to the signed-in page.
    * Website prompts, "Do you want to register this computer with example.com?"
    * User agrees.
    * Laptop prompts the user for a previously configured [=authorization gesture=] (PIN, biometric, etc.); the user provides this.
    * Website shows message, "Registration complete."
    * User signs out.

- Later, again on their laptop:
    * User navigates to example.com in a browser and initiates signing in.
    * Website shows message, "Please follow your computer's prompts to complete sign in."
    * Laptop prompts the user for an [=authorization gesture=] (PIN, biometric, etc.); the user provides this.
    * Website shows that the user is signed in, and navigates to the signed-in page.


### Other Use Cases and Configurations ### {#sctn-other-configurations}

A variety of additional use cases and configurations are also possible, including (but not limited to):

- A user navigates to example.com on their laptop, is guided through a flow to create and register a credential on their phone.

- A user obtains a discrete, [=roaming authenticator=], such as a "fob" with USB or USB+NFC/BLE connectivity options, loads
    example.com in their browser on a laptop or phone, and is guided through a flow to create and register a credential on the
    fob.

- A [=[RP]=] prompts the user for their [=authorization gesture=] in order to authorize a single transaction, such as a payment
    or other financial transaction.




## Sample API Usage Scenarios ## {#sctn-sample-scenarios}

[INFORMATIVE]

In this section, we walk through some events in the lifecycle of a [=public key credential=], along with the corresponding
sample code for using this API. Note that this is an example flow and does not limit the scope of how the API can be used.

As was the case in earlier sections, this flow focuses on a use case involving a [=first-factor roaming authenticator=]
with its own display. One example of such an authenticator would be a smart phone. Other authenticator types are also supported
by this API, subject to implementation by the [=client platform=]. For instance, this flow also works without modification for the case of
an authenticator that is embedded in the [=client device=]. The flow also works for the case of an authenticator without
its own display (similar to a smart card) subject to specific implementation considerations. Specifically, the [=client platform=]
needs to display any prompts that would otherwise be shown by the authenticator, and the authenticator needs to allow the [=client
platform=] to enumerate all the authenticator's credentials so that the client can have information to show appropriate prompts.


### Registration ### {#sctn-sample-registration}

This is the first-time flow, in which a new credential is created and registered with the server.
In this flow, the [=[WRP]=] does not have a preference for [=platform authenticator=] or [=roaming authenticators=].

1. The user visits example.com, which serves up a script. At this point, the user may already be logged in using a legacy
    username and password, or additional authenticator, or other means acceptable to the [=[RP]=].
    Or the user may be in the process of creating a new account.

1. The [=[RP]=] script runs the code snippet below.

1. The [=client platform=] searches for and locates the authenticator.

1. The [=client=] connects to the authenticator, performing any pairing actions if necessary.

1. The authenticator shows appropriate UI for the user to provide a biometric or other [=authorization gesture=].

1. The authenticator returns a response to the [=client=], which in turn returns a response to the [=[RP]=] script. If
    the user declined to select an authenticator or provide authorization, an appropriate error is returned.

1. If a new credential was created,
    - The [=[RP]=] script sends the newly generated [=credential public key=] to the server, along with additional information
        such as attestation regarding the provenance and characteristics of the authenticator.
    - The server stores the [=credential public key=] in its database and associates it with the user as well as with the
        characteristics of authentication indicated by attestation, also storing a friendly name for later use.
    - The script may store data such as the [=credential ID=] in local storage, to improve future UX by narrowing the choice of
        credential for the user.

The sample code for generating and registering a new key follows:

<pre class="example" highlight="js">
    if (!window.PublicKeyCredential) { /* Client not capable. Handle error. */ }

    var publicKey = {
      // The challenge is produced by the server; see the Security Considerations
      challenge: new Uint8Array([21,31,105 /* 29 more random bytes generated by the server */]),

      // Relying Party:
      rp: {
        name: "ACME Corporation"
      },

      // User:
      user: {
        id: Uint8Array.from(window.atob("MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII="), c=>c.charCodeAt(0)),
        name: "alex.mueller@example.com",
        displayName: "Alex Müller",
      },

      // This Relying Party will accept either an ES256 or RS256 credential, but
      // prefers an ES256 credential.
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7 // "ES256" as registered in the IANA COSE Algorithms registry
        },
        {
          type: "public-key",
          alg: -257 // Value registered by this specification for "RS256"
        }
      ],

      authenticatorSelection: {
        // Try to use UV if possible. This is also the default.
        userVerification: "preferred"
      },

      timeout: 360000,  // 6 minutes
      excludeCredentials: [
        // Don't re-register any authenticator that has one of these credentials
        {"id": Uint8Array.from(window.atob("ufJWp8YGlibm1Kd9XQBWN1WAw2jy5In2Xhon9HAqcXE="), c=>c.charCodeAt(0)), "type": "public-key"},
        {"id": Uint8Array.from(window.atob("E/e1dhZc++mIsz4f9hb6NifAzJpF1V4mEtRlIPBiWdY="), c=>c.charCodeAt(0)), "type": "public-key"}
      ],

      // Make excludeCredentials check backwards compatible with credentials registered with U2F
      extensions: {"appidExclude": "https://acme.example.com"}
    };

    // Note: The following call will cause the authenticator to display UI.
    navigator.credentials.create({ publicKey })
      .then(function (newCredentialInfo) {
        // Send new credential info to server for verification and registration.
      }).catch(function (err) {
        // No acceptable authenticator or user refused consent. Handle appropriately.
      });
</pre>

### Registration Specifically with User-Verifying Platform Authenticator ### {#sctn-sample-registration-with-platform-authenticator}

This is an example flow for when the [=[WRP]=] is specifically interested in creating a [=public key credential=] with
a [=user-verifying platform authenticator=].

1. The user visits example.com and clicks on the login button, which redirects the user to login.example.com.

1. The user enters a username and password to log in. After successful login, the user is redirected back to example.com.

1. The [=[RP]=] script runs the code snippet below.

    1. The user agent checks if a [=user-verifying platform authenticator=] is available. If not, terminate this flow.

    1. The [=[RP]=] asks the user if they want to create a credential with it. If not, terminate this flow.

    1. The user agent and/or operating system shows appropriate UI and guides the user in creating a credential
        using one of the available platform authenticators.

    1. Upon successful credential creation, the [=[RP]=] script conveys the new credential to the server.

<pre class="example" highlight="js">
    if (!window.PublicKeyCredential) { /* Client not capable of the API. Handle error. */ }

    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()
        .then(function (uvpaAvailable) {
            // If there is a user-verifying platform authenticator
            if (uvpaAvailable) {
                // Render some RP-specific UI and get a Promise for a Boolean value
                return askIfUserWantsToCreateCredential();
            }
        }).then(function (userSaidYes) {
            // If there is a user-verifying platform authenticator
            // AND the user wants to create a credential
            if (userSaidYes) {
                var publicKeyOptions = { /* Public key credential creation options. */};
                return navigator.credentials.create({ "publicKey": publicKeyOptions });
            }
        }).then(function (newCredentialInfo) {
            if (newCredentialInfo) {
                // Send new credential info to server for verification and registration.
            }
        }).catch(function (err) {
            // Something went wrong. Handle appropriately.
        });
</pre>

### Authentication ### {#sctn-sample-authentication}

This is the flow when a user with an already registered credential visits a website and wants to authenticate using the
credential.

1. The user visits example.com, which serves up a script.

1. The script asks the [=client=] for an Authentication Assertion, providing as much information as possible to narrow
    the choice of acceptable credentials for the user. This can be obtained from the data that was stored locally after
    registration, or by other means such as prompting the user for a username.

1. The [=[RP]=] script runs one of the code snippets below.

1. The [=client platform=] searches for and locates the authenticator.

1. The [=client=] connects to the authenticator, performing any pairing actions if necessary.

1. The authenticator presents the user with a notification that their attention is needed. On opening the
    notification, the user is shown a friendly selection menu of acceptable credentials using the account information provided
    when creating the credentials, along with some information on the [=origin=] that is requesting these keys.

1. The authenticator obtains a biometric or other [=authorization gesture=] from the user.

1. The authenticator returns a response to the [=client=], which in turn returns a response to the [=[RP]=] script.
    If the user declined to select a credential or provide an authorization, an appropriate error is returned.

1. If an assertion was successfully generated and returned,
    - The script sends the assertion to the server.
    - The server examines the assertion, extracts the [=credential ID=], looks up the registered
        credential public key in its database, and verifies the [=assertion signature=].
        If valid, it looks up the identity associated with the assertion's [=credential ID=]; that
        identity is now authenticated. If the [=credential ID=] is not recognized by the server (e.g.,
        it has been deregistered due to inactivity) then the authentication has failed; each [=[RP]=]
        will handle this in its own way.
    - The server now does whatever it would otherwise do upon successful authentication -- return a success page, set
        authentication cookies, etc.

If the [=[RP]=] script does not have any hints available (e.g., from locally stored data) to help it narrow the list of
credentials, then the sample code for performing such an authentication might look like this:

<pre class="example" highlight="js">
    if (!window.PublicKeyCredential) { /* Client not capable. Handle error. */ }

    // credentialId is generated by the authenticator and is an opaque random byte array
    var credentialId = new Uint8Array([183, 148, 245 /* more random bytes previously generated by the authenticator */]);
    var options = {
      // The challenge is produced by the server; see the Security Considerations
      challenge: new Uint8Array([4,101,15 /* 29 more random bytes generated by the server */]),
      timeout: 120000,  // 2 minutes
      allowCredentials: [{ type: "public-key", id: credentialId }]
    };

    navigator.credentials.get({ "publicKey": options })
        .then(function (assertion) {
        // Send assertion to server for verification
    }).catch(function (err) {
        // No acceptable credential or user refused consent. Handle appropriately.
    });
</pre>

On the other hand, if the [=[RP]=] script has some hints to help it narrow the list of credentials, then the sample code for
performing such an authentication might look like the following. Note that this sample also demonstrates how to use the [=credProps|Credential Properties Extension=].

<pre class="example" highlight="js">
    if (!window.PublicKeyCredential) { /* Client not capable. Handle error. */ }

    var encoder = new TextEncoder();
    var acceptableCredential1 = {
        type: "public-key",
        id: encoder.encode("BA44712732CE")
    };
    var acceptableCredential2 = {
        type: "public-key",
        id: encoder.encode("BG35122345NF")
    };

    var options = {
      // The challenge is produced by the server; see the Security Considerations
      challenge: new Uint8Array([8,18,33 /* 29 more random bytes generated by the server */]),
      timeout: 120000,  // 2 minutes
      allowCredentials: [acceptableCredential1, acceptableCredential2],
      extensions: { 'credProps': true }
    };

    navigator.credentials.get({ "publicKey": options })
        .then(function (assertion) {
        // Send assertion to server for verification
    }).catch(function (err) {
        // No acceptable credential or user refused consent. Handle appropriately.
    });
</pre>

### Aborting Authentication Operations ### {#sctn-sample-aborting}

The below example shows how a developer may use the AbortSignal parameter to abort a
credential registration operation. A similar procedure applies to an authentication operation.

<pre class="example" highlight="js">
    const authAbortController = new AbortController();
    const authAbortSignal = authAbortController.signal;

    authAbortSignal.onabort = function () {
        // Once the page knows the abort started, inform user it is attempting to abort.
    }

    var options = {
        // A list of options.
    }

    navigator.credentials.create({
        publicKey: options,
        signal: authAbortSignal})
        .then(function (attestation) {
            // Register the user.
        }).catch(function (error) {
            if (error == "AbortError") {
                // Inform user the credential hasn't been created.
                // Let the server know a key hasn't been created.
            }
        });

    // Assume widget shows up whenever authentication occurs.
    if (widget == "disappear") {
        authAbortController.abort();
    }
</pre>


### Decommissioning ### {#sctn-sample-decommissioning}

The following are possible situations in which decommissioning a credential might be desired. Note that all of these are
handled on the server side and do not need support from the API specified here.

- Possibility #1 -- user reports the credential as lost.
    * User goes to server.example.net, authenticates and follows a link to report a lost/stolen [=authenticator=].
    * Server returns a page showing the list of registered credentials with friendly names as configured during registration.
    * User selects a credential and the server deletes it from its database.
    * In the future, the [=[RP]=] script does not specify this credential in any list of acceptable credentials, and assertions
        signed by this credential are rejected.

- Possibility #2 -- server deregisters the credential due to inactivity.
    * Server deletes credential from its database during maintenance activity.
    * In the future, the [=[RP]=] script does not specify this credential in any list of acceptable credentials, and assertions
        signed by this credential are rejected.

- Possibility #3 -- user deletes the credential from the [=authenticator=].
    * User employs a [=authenticator=]-specific method (e.g., device settings UI) to delete a credential from their [=authenticator=].
    * From this point on, this credential will not appear in any selection prompts, and no assertions can be generated with it.
    * Sometime later, the server deregisters this credential due to inactivity.


##  Platform-Specific Implementation Guidance ## {#sctn-platform-impl-guidance}

This specification defines how to use Web Authentication in the general case. When using Web
Authentication in connection with specific platform support (e.g. apps), it is recommended to see
platform-specific documentation and guides for additional guidance and limitations.



# Conformance # {#sctn-conformance}

This specification defines three conformance classes. Each of these classes is specified so that conforming members of the class
are secure against non-conforming or hostile members of the other classes.

## User Agents ## {#sctn-conforming-user-agents}

A User Agent MUST behave as described by [[#sctn-api]] in order to be considered conformant. [=Conforming User Agents=] MAY implement
algorithms given in this specification in any way desired, so long as the end result is indistinguishable from the result that
would be obtained by the specification's algorithms.

A conforming User Agent MUST also be a conforming implementation of the IDL fragments of this specification, as described in the
“Web IDL” specification. [[!WebIDL]]

### Enumerations as DOMString types ### {#sct-domstring-backwards-compatibility}

Enumeration types are not referenced by other parts of the Web IDL because that
would preclude other values from being used without updating this specification
and its implementations. It is important for backwards compatibility that
[=client platforms=] and [=[RPS]=] handle unknown values. Enumerations for this
specification exist here for documentation and as a registry. Where the
enumerations are represented elsewhere, they are typed as {{DOMString}}s, for
example in {{PublicKeyCredentialDescriptor/transports}}.

## Authenticators ## {#sctn-conforming-authenticators}

A [=[WAA]=] MUST provide the operations defined by [[#sctn-authenticator-model]], and those operations MUST behave as
described there. This is a set of functional and security requirements for an authenticator to be usable by a [=Conforming User
Agent=].

As described in [[#sctn-use-cases]], an authenticator may be implemented in the operating system underlying the User Agent, or in
external hardware, or a combination of both.

### Backwards Compatibility with FIDO U2F ### {#sctn-conforming-authenticators-u2f}

[=Authenticators=] that only support the [[#sctn-fido-u2f-attestation]] have no mechanism to store a
[=user handle=], so the returned {{AuthenticatorAssertionResponse/userHandle}} will always be null.

## [WRPS] ## {#sctn-conforming-relying-parties}

A [=[WRP]=] MUST behave as described in [[#sctn-rp-operations]] to obtain all the security benefits offered by this specification. See
[[#sctn-rp-benefits]] for further discussion of this.


## All Conformance Classes ## {#sctn-conforming-all-classes}

All [=CBOR=] encoding performed by the members of the above conformance classes MUST be done using the
[=CTAP2 canonical CBOR encoding form=].
All decoders of the above conformance classes SHOULD reject CBOR that is not validly encoded
in the [=CTAP2 canonical CBOR encoding form=] and SHOULD reject messages with duplicate map keys.


# Dependencies # {#sctn-dependencies}

This specification relies on several other underlying specifications, listed
below and in [[#index-defined-elsewhere]].

: Base64url encoding
:: The term <dfn>Base64url Encoding</dfn> refers to the base64 encoding using the URL- and filename-safe character set defined
    in Section 5 of [[!RFC4648]], with all trailing '=' characters omitted (as permitted by Section 3.2) and without the
    inclusion of any line breaks, whitespace, or other additional characters.

: CBOR
:: A number of structures in this specification, including attestation statements and extensions, are encoded using the
    [=CTAP2 canonical CBOR encoding form=] of the Compact Binary Object Representation (<dfn>CBOR</dfn>) [[!RFC8949]],
    as defined in [[!FIDO-CTAP]].

: CDDL
:: This specification describes the syntax of all [=CBOR=]-encoded data using the CBOR Data Definition Language (<dfn>CDDL</dfn>) [[!RFC8610]].

: COSE
:: CBOR Object Signing and Encryption (COSE) [[!RFC9052]] [[!RFC9053]].
    The IANA COSE Algorithms registry [[!IANA-COSE-ALGS-REG]] originally established by [[!RFC8152 obsolete]] and updated by these specifications is also used.

:  Credential Management
:: The API described in this document is an extension of the {{Credential}} concept defined in [[!CREDENTIAL-MANAGEMENT-1]].

: DOM
:: {{DOMException}} and the DOMException values used in this specification are defined in [[!DOM4]].

: ECMAScript
:: [=%ArrayBuffer%=] is defined in [[!ECMAScript]].

: HTML
:: The concepts of [=browsing context=], [=origin=], [=opaque origin=], [=tuple origin=], [=relevant settings object=], [=same site=]
    and [=is a registrable domain suffix of or is equal to=] are defined in [[!HTML]].

: URL
:: The concepts of [=domain=], [=host=], [=port=], [=scheme=], [=valid domain=] and [=valid domain string=] are defined in [[!URL]].

: Web IDL
:: Many of the interface definitions and all of the IDL in this specification depend on [[!WebIDL]]. This updated version of
    the Web IDL standard adds support for {{Promise}}s, which are now the preferred mechanism for asynchronous
    interaction in all new web APIs.

: FIDO AppID
:: The algorithms for [=determining the FacetID of a calling application=] and
    [=determining if a caller's FacetID is authorized for an AppID=] (used only in
    the [=AppID|AppID extension=]) are defined by [[!FIDO-APPID]].

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in [[!RFC2119]].


# Terminology # {#sctn-terminology}

: <dfn>Attestation</dfn>
:: Generally, <em>attestation</em> is a statement that serves to bear witness, confirm, or authenticate.
    In the WebAuthn context, [=attestation=] is employed to provide verifiable evidence as to the origin of an [=authenticator=]
    and the data it emits. This includes such things as [=credential IDs=], [=credential key pairs=], [=signature counters=], etc.

    An [=attestation statement=] is provided within an [=attestation object=] during a [=registration=] ceremony. See also [[#sctn-attestation]]
    and [Figure 6](#fig-attStructs). Whether or how the [=client=] conveys the [=attestation statement=] and [=AAGUID=]
    portions of the [=attestation object=] to the [=[RP]=] is described by [=attestation conveyance=].

: <dfn>Attestation Certificate</dfn>
:: An X.509 Certificate for the <dfn>attestation key pair</dfn> used by an [=authenticator=] to attest to its manufacture
    and capabilities. At [=registration=] time, the [=authenticator=] uses the <dfn>attestation private key</dfn> to sign
    the [=[RP]=]-specific [=credential public key=] (and additional data) that it generates and returns via the
    [=authenticatorMakeCredential=] operation. [=[RPS]=] use the <dfn>attestation public key</dfn> conveyed in the [=attestation
    certificate=] to verify the [=attestation signature=]. Note that in the case of [=self attestation=], the
    [=authenticator=] has no distinct [=attestation key pair=] nor [=attestation certificate=], see [=self
    attestation=] for details.

: <dfn>Authentication</dfn>
: <dfn>Authentication Ceremony</dfn>
:: The [=ceremony=] where a user, and the user's [=client platform=] (containing or connected to at least one [=authenticator=]) work in
    concert to cryptographically prove to a [=[RP]=] that the user controls the [=credential private key=] of a
    previously-registered [=public key credential=] (see [=Registration=]). Note that this includes a [=test of user presence=] or
    [=user verification=].

    The WebAuthn [=authentication ceremony=] is defined in [[#sctn-verifying-assertion]],
    and is initiated by the [=[RP]=] invoking a <code>{{CredentialsContainer/get()|navigator.credentials.get()}}</code> operation
    with a {{CredentialRequestOptions/publicKey}} argument.
    See [[#sctn-api]] for an introductory overview and [[#sctn-sample-authentication]] for implementation examples.

: <dfn>Authentication Assertion</dfn>
: <dfn>Assertion</dfn>
:: The cryptographically signed {{AuthenticatorAssertionResponse}} object returned by an [=authenticator=] as the result of an
    [=authenticatorGetAssertion=] operation.

    This corresponds to the [[!CREDENTIAL-MANAGEMENT-1]] specification's single-use <a
    spec="credential-management">credentials</a>.

: <dfn>Authenticator</dfn>
: <dfn>[WAA]</dfn>
:: A cryptographic entity, existing in hardware or software, that can [=registration|register=] a user with a given [=[RP]=]
    and later [=Authentication Assertion|assert possession=] of the registered [=public key credential=], and optionally
    [=user verification|verify the user=], when requested by the [=[RP]=]. [=Authenticators=] can report information
    regarding their [=authenticator types|type=] and security characteristics via [=attestation=] during [=registration=].

    A [=[WAA]=] could be a [=roaming authenticator=], a dedicated hardware subsystem integrated into the [=client device=],
    or a software component of the [=client=] or [=client device=].

    In general, an [=authenticator=] is assumed to have only one user.
    If multiple natural persons share access to an [=authenticator=],
    they are considered to represent the same user in the context of that [=authenticator=].
    If an [=authenticator=] implementation supports multiple users in separated compartments,
    then each compartment is considered a separate [=authenticator=]
    with a single user with no access to other users' [=credentials=].

: <dfn>Authorization Gesture</dfn>
:: An [=authorization gesture=] is a physical interaction performed by a user with an authenticator as part of a [=ceremony=],
    such as [=registration=] or [=authentication=]. By making such an [=authorization gesture=], a user [=user consent|provides
    consent=] for (i.e., <em>authorizes</em>) a [=ceremony=] to proceed. This MAY involve [=user verification=] if the
    employed [=authenticator=] is capable, or it MAY involve a simple [=test of user presence=].

: <dfn>Backed Up</dfn>
:: [=Public Key Credential Sources=] may be backed up in some fashion such that they may become present on an authenticator other
    than their [=generating authenticator=]. Backup can occur via mechanisms including but not limited to peer-to-peer sync,
    cloud sync, local network sync, and manual import/export. See also [[#sctn-credential-backup]].

: <dfn>Backup Eligibility</dfn>
: <dfn>Backup Eligible</dfn>
:: A [=Public Key Credential Source=]'s [=generating authenticator=] determines at creation time whether the [=public key credential source=]
    is allowed to be [=backed up=]. Backup eligibility is signaled in [=authenticator data=]'s [=flags=] along with the current [=backup state=].
    Backup eligibility is a [=credential property=] and is permanent for a given [=public key credential source=].
    A backup eligible [=public key credential source=] is referred to as a <dfn>multi-device credential</dfn> whereas one that is not
    backup eligible is referred to as a <dfn>single-device credential</dfn>. See also [[#sctn-credential-backup]].

: <dfn>Backup State</dfn>
:: The current backup state of a [=multi-device credential=] as determined by the current [=managing authenticator=]. Backup state is
    signaled in [=authenticator data=]'s [=flags=] and can change over time. See also [=backup eligibility=] and [[#sctn-credential-backup]].

: <dfn>Biometric Authenticator</dfn>
:: Any [=authenticator=] that implements [=biometric recognition=].

: <dfn>Biometric Recognition</dfn>
:: The automated recognition of individuals based on their biological and behavioral characteristics [[ISOBiometricVocabulary]].

: <dfn>Bound credential</dfn>
: "Authenticator [=contains=] a credential"
: "Credential [=created on=] an authenticator"
:: A [=public key credential source=] or [=public key credential=] is said to be [=bound credential|bound=] to its [=managing
    authenticator=]. This means that only the [=managing authenticator=] can generate [=assertions=] for the [=public key
    credential sources=] [=bound credential|bound=] to it.

    This may also be expressed as "the [=managing authenticator=] <dfn>contains</dfn> the [=bound credential=]",
    or "the [=bound credential=] was <dfn>created on</dfn> its [=managing authenticator=]".
    Note, however, that a [=server-side credential=] might not be physically stored in persistent memory inside the authenticator,
    hence "[=bound credential|bound to=]" is the primary term.
    See [[#sctn-credential-storage-modality]].

: <dfn>Ceremony</dfn>
:: The concept of a [=ceremony=] [[Ceremony]] is an extension of the concept of a network protocol, with human nodes alongside
    computer nodes and with communication links that include user interface(s), human-to-human communication, and transfers of
    physical objects that carry data. What is out-of-band to a protocol is in-band to a ceremony. In this specification,
    [=Registration=] and [=Authentication=] are ceremonies, and an [=authorization gesture=] is often a component of
    those [=ceremonies=].

: <dfn>Client</dfn>
: <dfn>[WAC]</dfn>
:: Also referred to herein as simply a [=client=]. See also [=Conforming User Agent=]. A [=[WAC]=] is an intermediary entity typically implemented in the user agent (in whole, or in part). Conceptually, it underlies the [=Web Authentication API=] and embodies the implementation of the {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}} and {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} [=internal methods=]. It is responsible for both marshalling the inputs for the underlying [=authenticator operations=], and for returning the results of the latter operations to the [=Web Authentication API=]'s callers.

    The [=[WAC]=] runs on, and is distinct from, a [=[WAC] Device=].

: <dfn>Client Device</dfn>
: <dfn>[WAC] Device</dfn>
:: The hardware device on which the [=[WAC]=] runs, for example a smartphone, a laptop computer or a desktop computer, and the
    operating system running on that hardware.

    The distinctions between a [=[WAC] device=] and a [=client=] are:
    * a single [=client device=] MAY support running multiple [=clients=], i.e., browser implementations,
        which all have access to the same [=authenticators=] available on that [=client device=], and
    * [=platform authenticators=] are bound to a [=client device=] rather than a [=[WAC]=].

    A [=client device=] and a [=client=] together constitute a [=client platform=].

: <dfn>Client Platform</dfn>
:: A [=client device=] and a [=client=] together make up a [=client platform=]. A single hardware device MAY be part of multiple
    distinct [=client platforms=] at different times by running different operating systems and/or [=clients=].

: <dfn>Client-Side</dfn>
:: This refers in general to the combination of the user's [=client platform=], [=authenticators=], and everything gluing
    it all together.

: <dfn>Client-side discoverable Public Key Credential Source</dfn>
: <dfn>Client-side discoverable Credential</dfn>
: <dfn>Discoverable Credential</dfn>
: \[DEPRECATED] <dfn>Resident Credential</dfn>
: \[DEPRECATED] <dfn>Resident Key</dfn>
:: Note: Historically, [=client-side discoverable credentials=] have  been known as [=resident credentials=] or [=resident keys=].
    Due to the phrases `ResidentKey` and `residentKey` being widely used in both the [=web authentication api|WebAuthn
    API=] and also in the [=Authenticator Model=] (e.g., in dictionary member names, algorithm variable names, and
    operation parameters) the usage of `resident` within their
    names has not been changed for backwards compatibility purposes. Also, the term [=resident key=] is
    defined here as equivalent to a [=client-side discoverable credential=].

    A [=Client-side discoverable Public Key Credential Source=], or [=Discoverable Credential=] for short,
    is a [=public key credential source=] that is <strong><em>discoverable</em></strong> and usable in [=authentication ceremonies=]
    where the [=[RP]=] does not provide any [=credential ID=]s,
    i.e., the [=[RP]=] invokes {{CredentialsContainer/get()|navigator.credentials.get()}}
    with an <strong><em>[=list/is empty|empty=]</em></strong> {{PublicKeyCredentialRequestOptions/allowCredentials}} argument. This means that the [=[RP]=] does not necessarily need to first identify the user.

    As a consequence, a [=discoverable credential capable=] [=authenticator=] can generate an [=assertion signature=]
    for a [=discoverable credential=] given only an [=RP ID=],
    which in turn necessitates that the [=public key credential source=]
    is stored in the [=authenticator=] or [=client platform=].
    This is in contrast to a [=Server-side Public Key Credential Source=],
    which requires that the [=authenticator=] is given both the [=RP ID=] and the [=credential ID=]
    but does not require [=client-side=] storage of the [=public key credential source=].

    See also: [=client-side credential storage modality=] and [=non-discoverable credential=].

    Note: [=Client-side discoverable credentials=] are also usable in [=authentication ceremonies=] where [=credential ID=]s are given,
    i.e., when calling {{CredentialsContainer/get()|navigator.credentials.get()}}
    with a non-[=list/is empty|empty=] {{PublicKeyCredentialRequestOptions/allowCredentials}} argument.

: <dfn>Conforming User Agent</dfn>
:: A user agent implementing, in cooperation with the underlying [=client device=], the [=Web Authentication API=] and algorithms
    given in this specification, and handling communication between [=authenticators=] and [=[RPS]=].

: <dfn>Credential ID</dfn>
:: A probabilistically-unique [=byte sequence=] identifying a [=public key credential source=] and its [=authentication assertions=]. At most 1023 bytes long.

    Credential IDs are generated by [=authenticators=] in two forms:
    1. At least 16 bytes that include at least 100 bits of entropy, or
    1. The [=public key credential source=], without its [=Credential ID=] or [=mutable items=], encrypted so only its [=managing authenticator=] can
        decrypt it. This form allows the [=authenticator=] to be nearly stateless, by having the [=[RP]=] store any necessary
        state.

        Note: [[FIDO-UAF-AUTHNR-CMDS]] includes guidance on encryption techniques under "Security Guidelines".

    [=[RPS]=] do not need to distinguish these two [=Credential ID=] forms.

: <dfn>Credential Key Pair</dfn>
: <dfn>Credential Private Key</dfn>
: <dfn>Credential Public Key</dfn>
: <dfn>User Public Key</dfn>
: <dfn>User Credential</dfn>
:: A [=credential key pair=] is a pair of asymmetric cryptographic keys generated by an [=authenticator=]
    and [=scoped=] to a specific [=[WRP]=]. It is the central part of a [=public key credential=].

    A [=credential public key=] is the public key portion of a [=credential key pair=].
    The [=credential public key=] is returned to the [=[RP]=] during a [=registration ceremony=].

    A [=credential private key=] is the private key portion of a [=credential key pair=].
    The [=credential private key=] is bound to a particular [=authenticator=] - its [=managing authenticator=] -
    and is expected to never be exposed to any other party, not even to the owner of the [=authenticator=].

    Note that in the case of [=self
    attestation=], the [=credential key pair=] is also used as the [=attestation key pair=], see [=self attestation=]
    for details.

    Note: The [=credential public key=] is referred to as the [=user public key=] in FIDO UAF [[UAFProtocol]], and in FIDO U2F
    [[FIDO-U2F-Message-Formats]] and some parts of this specification that relate to it.

: <dfn>Credential Properties</dfn>
:: A [=credential property=] is some characteristic property of a [=public key credential source=], such as whether it is a
    [=client-side discoverable credential=] or a [=server-side credential=].

: <dfn>Credential Record</dfn>
:: In order to implement the algorithms defined in [[#sctn-rp-operations]],
    the [=[RP]=] MUST store some properties of registered [=public key credential sources=].
    The [=credential record=] [=struct=] is an abstraction of these properties stored in a [=user account=].
    A&nbsp;credential record is created during a [=registration ceremony=] and used in subsequent [=authentication ceremonies=].
    [=[RPS]=] MAY delete credential records as necessary or when requested by users.

    The following [=struct/items=] are RECOMMENDED in order to implement all steps of
    [[#sctn-registering-a-new-credential]] and [[#sctn-verifying-assertion]] as defined:

    <dl dfn-for="credential record" dfn-type="abstract-op">
        :   <dfn>type</dfn>
        ::  The [=public key credential source/type=] of the [=public key credential source=].

        :   <dfn>id</dfn>
        ::  The [=Credential ID=] of the [=public key credential source=].

        :   <dfn>publicKey</dfn>
        ::  The [=credential public key=] of the [=public key credential source=].

        :   <dfn>signCount</dfn>
        ::  The latest value of the [=authData/signCount|signature counter=] in the [=authenticator data=]
            from any [=ceremony=] using the [=public key credential source=].

        :   <dfn>transports</dfn>
        ::  The value returned from {{AuthenticatorAttestationResponse/getTransports()}}
            when the [=public key credential source=] was [=registration|registered=].

            Note: Modifying or removing [=list/items=] from the value returned from {{AuthenticatorAttestationResponse/getTransports()}}
            could negatively impact user experience, or even prevent use of the corresponding credential.

        :   <dfn>BE</dfn>
        ::  The value of the [=authData/flags/BE=] [=flag=] when the [=public key credential source=] was created.

        :   <dfn>BS</dfn>
        ::  The latest value of the [=authData/flags/BS=] [=flag=] in the [=authenticator data=]
            from any [=ceremony=] using the [=public key credential source=].
    </dl>

    The following [=struct/items=] are OPTIONAL:

    <dl dfn-for="credential record" dfn-type="abstract-op">
        :   <dfn>attestationObject</dfn>
        ::  The value of the {{AuthenticatorAttestationResponse/attestationObject}} attribute
            when the [=public key credential source=] was [=registration|registered=].
            Storing this enables the [=[RP]=] to reference the credential's [=attestation statement=] at a later time.

        :   <dfn>attestationClientDataJSON</dfn>
        ::  The value of the {{AuthenticatorResponse/clientDataJSON}} attribute
            when the [=public key credential source=] was [=registration|registered=].
            Storing this in combination with the above [$credential record/attestationObject$] [=struct/item=]
            enables the [=[RP]=] to re-verify the [=attestation signature=] at a later time.
    </dl>

    [=WebAuthn extensions=] MAY define additional [=struct/items=] needed to process the extension.
    [=[RPS]=] MAY also include any additional [=struct/items=] as needed,
    and MAY omit any [=struct/items=] not needed for their implementation.

    The <dfn>credential descriptor for a credential record</dfn> is a {{PublicKeyCredentialDescriptor}} value with the contents:

    :   {{PublicKeyCredentialDescriptor/type}}
    ::  The [$credential record/type$] of the [=credential record=].

    :   {{PublicKeyCredentialDescriptor/id}}
    ::  The [$credential record/id$] of the [=credential record=].

    :   {{PublicKeyCredentialDescriptor/transports}}
    ::  The [$credential record/transports$] of the [=credential record=].

: <dfn>Hardware-bound Device Key Pair</dfn>
: <dfn>Device-bound Key</dfn>
: <dfn>Device Private Key</dfn>
: <dfn>Device Public Key</dfn>
:: A [=hardware-bound device key pair=], also known as a [=device-bound key=], is an [=authenticator=]-, [=[RP]=]-, and [=user credential=]-specific public key pair created upon a [=[RP]=]'s request via the [=devicePubKey=] [=WebAuthn extension=].
    The [=authenticator=] that a [=hardware-bound device key pair=] is created upon guarantees that the [=device private key=] is securely stored in hardware, i.e., it is unextractable. See also [[#sctn-device-publickey-extension]].

    Note: All guarantees about the operation of an [=authenticator=] operation rely on [=attestation=]. In particular, [=[RPS]=] MUST NOT rely on the above guarantee of unextractability unless supported by a valid, trusted [=attestation statement=].

: <dfn>Generating Authenticator</dfn>
:: The Generating Authenticator is the authenticator involved in the [=authenticatorMakeCredential=] operation resulting
    in the creation of a given [=public key credential source=]. The [=generating authenticator=] is the same as the [=managing authenticator=]
    for [=single-device credentials=]. For [=multi-device credentials=], the generating authenticator may or may not be the same as the
    current [=managing authenticator=] participating in a given [=authentication=] operation.

: <dfn>Human Palatability</dfn>
:: An identifier that is [=human palatability|human-palatable=] is intended to be rememberable and reproducible by typical human
    users, in contrast to identifiers that are, for example, randomly generated sequences of bits [[EduPersonObjectClassSpec]].

: <dfn>Non-Discoverable Credential</dfn>
:: This is a [=credential=] whose [=credential ID=] must be provided in {{PublicKeyCredentialRequestOptions/allowCredentials}} when calling {{CredentialsContainer/get()|navigator.credentials.get()}} because it is not [=client-side discoverable credential|client-side discoverable=]. See also [=server-side credentials=].

: <dfn>Public Key Credential</dfn>
:: Generically, a *credential* is data one entity presents to another in order to *authenticate* the former to the latter
    [[RFC4949]]. The term [=public key credential=] refers to one of: a [=public key credential source=], the
    possibly-[=attestation|attested=] [=credential public key=] corresponding to a [=public key credential source=], or an
    [=authentication assertion=]. Which one is generally determined by context.

    <div class="note">
        Note: This is a [=willful violation=] of [[RFC4949]]. In English, a "credential" is both a) the thing presented to prove
        a statement and b) intended to be used multiple times. It's impossible to achieve both criteria securely with a single
        piece of data in a public key system. [[RFC4949]] chooses to define a credential as the thing that can be used multiple
        times (the public key), while this specification gives "credential" the English term's flexibility. This specification
        uses more specific terms to identify the data related to an [[RFC4949]] credential:

        : "Authentication information" (possibly including a private key)
        :: [=Public key credential source=]
        : "Signed value"
        :: [=Authentication assertion=]
        : [[RFC4949]] "credential"
        :: [=Credential public key=] or [=attestation object=]
    </div>

    At [=registration=] time, the [=authenticator=] creates an asymmetric key pair, and stores its [=credential private
    key|private key portion=] and information from the [=[RP]=] into a [=public key credential source=]. The [=credential public
    key|public key portion=] is returned to the [=[RP]=], which then stores it in the active [=user account=].
    Subsequently, only that [=[RP]=], as identified by its [=RP ID=], is able to employ the [=public key credential=] in
    [=authentication|authentication ceremonies=], via the {{CredentialsContainer/get()}} method. The [=[RP]=] uses its stored
    copy of the [=credential public key=] to verify the resultant [=authentication assertion=].

: <dfn>Public Key Credential Source</dfn>
:: A [=credential source=] ([[CREDENTIAL-MANAGEMENT-1]]) used by an [=authenticator=] to generate [=authentication assertions=]. A [=public key credential source=] consists of a [=struct=] with the following [=struct/items=]:

    <dl dfn-for="public key credential source">
        :   <dfn>type</dfn>
        ::  whose value is of {{PublicKeyCredentialType}}, defaulting to {{public-key}}.

        :   <dfn>id</dfn>
        ::  A [=Credential ID=].

        :   <dfn>privateKey</dfn>
        ::  The [=credential private key=].

        :   <dfn>rpId</dfn>
        ::  The [=Relying Party Identifier=], for the [=[RP]=] this [=public key credential source=] is [=scoped=] to.
            This is determined by the <code>{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code>
            parameter of the {{CredentialsContainer/create()}} operation.

        :   <dfn>userHandle</dfn>
        ::  The [=user handle=] associated when this [=public key credential source=] was created. This [=struct/item=] is
            nullable.

        :   <dfn>otherUI</dfn>
        ::  OPTIONAL other information used by the [=authenticator=] to inform its UI. For example, this might include the user's
            {{PublicKeyCredentialUserEntity/displayName}}. [=public key credential source/otherUI=] is a <dfn>mutable item</dfn> and SHOULD NOT be bound to the
            [=public key credential source=] in a way that prevents [=public key credential source/otherUI=] from being updated.
    </dl>

    The [=authenticatorMakeCredential=] operation creates a [=public key credential source=] [=bound credential|bound=] to a <dfn for="public key
    credential source">managing authenticator</dfn> and returns the [=credential public key=] associated with its [=credential
    private key=]. The [=[RP]=] can use this [=credential public key=] to verify the [=authentication assertions=] created by
    this [=public key credential source=].

: <dfn>Rate Limiting</dfn>
:: The process (also known as throttling) by which an authenticator implements controls against brute force attacks by limiting
    the number of consecutive failed authentication attempts within a given period of time. If the limit is reached, the
    authenticator should impose a delay that increases exponentially with each successive attempt, or disable the current
    authentication modality and offer a different [=authentication factor=] if available. [=Rate limiting=] is often implemented as an
    aspect of [=user verification=].

: <dfn>Registration</dfn>
: <dfn>Registration Ceremony</dfn>
:: The [=ceremony=] where a user, a [=[RP]=], and the user's [=client platform=] (containing or connected to at least one
    [=authenticator=]) work in concert to create a [=public key credential=] and associate it with a [=user account=].
    Note that this includes employing a [=test of user presence=] or [=user verification=].
    After a successful [=registration ceremony=], the user can be authenticated by an [=authentication ceremony=].

    The WebAuthn [=registration ceremony=] is defined in [[#sctn-registering-a-new-credential]],
    and is initiated by the [=[RP]=] invoking a <code>{{CredentialsContainer/create()|navigator.credentials.create()}}</code> operation
    with a {{CredentialCreationOptions/publicKey}} argument.
    See [[#sctn-api]] for an introductory overview and [[#sctn-sample-registration]] for implementation examples.

: <dfn>[RP]</dfn>
: <dfn>[WRP]</dfn>
:: The entity whose <dfn>web application</dfn> utilizes the [[#sctn-api|Web Authentication API]] to [=registration|register=] and
    [=authentication|authenticate=] users.

    A [=[RP]=] implementation typically consists of both some client-side script
    that invokes the [=Web Authentication API=] in the [=client=],
    and a server-side component that executes the [[#sctn-rp-operations|[RP] operations]] and other application logic.
    Communication between the two components MUST use HTTPS or equivalent transport security,
    but is otherwise beyond the scope of this specification.

        Note: While the term [=[RP]=] is also often used in other contexts (e.g., X.509 and OAuth), an entity acting as a [=[RP]=] in one
        context is not necessarily a [=[RP]=] in other contexts. In this specification, the term [=[WRP]=] is often shortened
        to be just [=[RP]=], and explicitly refers to a [=[RP]=] in the WebAuthn context. Note that in any concrete instantiation
        a WebAuthn context may be embedded in a broader overall context, e.g., one based on OAuth.


: <dfn>Relying Party Identifier</dfn>
: <dfn>RP ID</dfn>
:: In the context of the [=web authentication api|WebAuthn API=], a [=relying party identifier=] is a [=valid domain string=] identifying the [=[WRP]=] on whose behalf a given [=registration=] or
    [=authentication|authentication ceremony=] is being performed. A [=public key credential=] can only be used for
    [=authentication=] with the same entity (as identified by [=RP ID=]) it was registered with.

    By default, the [=RP ID=] for a
    WebAuthn operation is set to the caller's [=environment settings object/origin=]'s [=effective domain=]. This default MAY be
    overridden by the caller, as long as the caller-specified [=RP ID=] value [=is a registrable domain suffix of or is equal
    to=] the caller's [=environment settings object/origin=]'s [=effective domain=]. See also [[#sctn-createCredential]] and
    [[#sctn-getAssertion]].

    <div class="note" id="note-pkcredscope">
        Note: An [=RP ID=] is based on a [=host=]'s [=domain=] name. It does not itself include a [=scheme=] or [=port=], as an [=origin=] does. The [=RP ID=] of a [=public key credential=] determines its <dfn>scope</dfn>. I.e., it <dfn>determines the set of origins on which the public key credential may be exercised</dfn>, as follows:

            - The [=RP ID=] must be equal to the [=determines the set of origins on which the public key credential may be exercised|origin=]'s [=effective domain=], or a [=is a registrable domain suffix of or is equal to|registrable domain suffix=] of the [=determines the set of origins on which the public key credential may be exercised|origin=]'s [=effective domain=].
            - The [=determines the set of origins on which the public key credential may be exercised|origin=]'s [=scheme=] must be `https`.
            - The [=determines the set of origins on which the public key credential may be exercised|origin=]'s [=port=] is unrestricted.

        For example, given a [=[RP]=] whose origin is `https://login.example.com:1337`, then the following [=RP ID=]s are valid: `login.example.com` (default) and `example.com`, but not `m.login.example.com` and not `com`.

        This is done in order to match the behavior of pervasively deployed ambient credentials (e.g., cookies, [[RFC6265]]).
        Please note that this is a greater relaxation of "same-origin" restrictions than what
        [=document.domain=]'s setter provides.

        These restrictions on origin values apply to [=WebAuthn Clients=].
    </div>

    Other specifications mimicking the [=web authentication api|WebAuthn API=] to enable WebAuthn [=public key credentials=] on non-Web platforms (e.g. native mobile applications), MAY define different rules for binding a caller to a [=Relying Party Identifier=]. Though, the [=RP ID=] syntaxes MUST conform to either [=valid domain strings=] or URIs [[!RFC3986]] [[!URL]].

: <dfn>Server-side Public Key Credential Source</dfn>
: <dfn>Server-side Credential</dfn>
: \[DEPRECATED] <dfn>Non-Resident Credential</dfn>
:: Note: Historically, [=server-side credentials=] have been known as [=non-resident credentials=].
    For backwards compatibility purposes, the various [=web authentication api|WebAuthn API=] and
    [=Authenticator Model=] components
    with various forms of `resident` within their names have not been changed.

    A [=Server-side Public Key Credential Source=], or [=Server-side Credential=] for short,
    is a [=public key credential source=] that is only usable in an [=authentication ceremony=]
    when the [=[RP]=] supplies its [=credential ID=] in {{CredentialsContainer/get()|navigator.credentials.get()}}'s
    {{PublicKeyCredentialRequestOptions/allowCredentials}} argument. This means that the [=[RP]=] must
    manage the credential's storage and discovery, as well as be able to first identify the user in order to
    discover the [=credential IDs=] to supply in the
    {{CredentialsContainer/get()|navigator.credentials.get()}} call.

    [=Client-side=] storage of the [=public key credential source=]
    is not required for a [=server-side credential=].
    This is in contrast to a [=client-side discoverable credential=],
    which instead does not require the user to first be identified in order to provide the user's [=credential ID=]s
    to a {{CredentialsContainer/get()|navigator.credentials.get()}} call.

    See also: [=server-side credential storage modality=] and [=non-discoverable credential=].

: <dfn>Test of User Presence</dfn>
:: A [=test of user presence=] is a simple form of [=authorization gesture=] and technical process where a user interacts with
    an [=authenticator=] by (typically) simply touching it (other modalities may also exist), yielding a Boolean result. Note
    that this does not constitute [=user verification=] because a [=test of user presence|user presence test=], by definition,
    is not capable of [=biometric recognition=], nor does it involve the presentation of a shared secret such as a password or
    PIN.

: <dfn>User Account</dfn>
:: In the context of this specification,
    a [=user account=] denotes the mapping of a set of [=credentials=] [[CREDENTIAL-MANAGEMENT-1]]
    to a (sub)set of a [=[RP]=]'s resources, as maintained and authorized by the [=[RP]=].
    The [=[RP]=] maps a given [=public key credential=] to a [=user account=]
    by assigning a [=user account=]-specific value to the credential's [=user handle=]
    and storing a [=credential record=] for the credential in the [=user account=].
    This mapping, the set of credentials, and their authorizations, may evolve over time.
    A given [=user account=] might be accessed by one or more natural persons (also known as "users"),
    and one natural person might have access to one or more [=user accounts=],
    depending on actions of the user(s) and the [=[RP]=].

: <dfn>User Consent</dfn>
:: User consent means the user agrees with what they are being asked, i.e., it encompasses reading and understanding prompts.
    An [=authorization gesture=] is a [=ceremony=] component often employed to indicate [=user consent=].

: <dfn>User Handle</dfn>
:: A user handle is an identifier for a [=user account=], specified by the [=[RP]=] as
    <code>{{PublicKeyCredentialCreationOptions/user}}.{{PublicKeyCredentialUserEntity/id}}</code>
    during [=registration=].
    [=Discoverable credentials=] store this identifier and return it as
    <code>{{PublicKeyCredential/response}}.{{AuthenticatorAssertionResponse/userHandle}}</code>
    in [=authentication ceremonies=] started with an [=list/empty=]
    <code>{{PublicKeyCredentialRequestOptions/allowCredentials}}</code> argument.

    The main use of the [=user handle=] is to identify the [=user account=] in such [=authentication ceremonies=],
    but the [=credential ID=] could be used instead.
    The main differences are
    that the [=credential ID=] is chosen by the [=authenticator=] and unique for each credential,
    while the [=user handle=] is chosen by the [=[RP]=] and ought to be the same
    for all [=credentials=] registered to the same [=user account=].

    [=Authenticators=] [=credentials map|map=] pairs of [=RP ID=] and [=user handle=] to [=public key credential sources=].
    As a consequence, an authenticator will store at most one [=discoverable credential=] per [=user handle=] per [=[RP]=].

    A user handle is an opaque [=byte sequence=] with a maximum size of 64 bytes, and is not meant to be displayed to the user.
    It MUST NOT contain personally identifying information, see [[#sctn-user-handle-privacy]].

: <dfn id=concept-user-present>User Present</dfn>
:: Upon successful completion of a [=test of user presence|user presence test=], the user is said to be
    "[=user present|present=]".

: <dfn>User Verification</dfn>
:: The technical process by which an [=authenticator=] <em>locally authorizes</em> the invocation of the
    [=authenticatorMakeCredential=] and [=authenticatorGetAssertion=] operations. [=User verification=] MAY be instigated
    through various [=authorization gesture=] modalities; for example, through a touch plus pin code, password entry, or
    [=biometric recognition=] (e.g., presenting a fingerprint) [[ISOBiometricVocabulary]]. The intent is to
    distinguish individual users.

    Note that [=user verification=] does not give the [=[RP]=] a concrete identification of the user,
    but when 2 or more ceremonies with [=user verification=] have been done with that [=credential=]
    it expresses that it was the same user that performed all of them.
    The same user might not always be the same natural person, however,
    if multiple natural persons share access to the same [=authenticator=].

    Note: Distinguishing natural persons depends in significant part upon the [=client platform=]'s
    and [=authenticator=]'s capabilities.
    For example, some devices are intended to be used by a single individual,
    yet they may allow multiple natural persons to enroll fingerprints or know the same PIN
    and thus access the same [=user account=](s) using that device.

    <div class="note">
        Note: Invocation of the [=authenticatorMakeCredential=] and [=authenticatorGetAssertion=] operations
        implies use of key material managed by the authenticator.

        Also, for security, [=user verification=] and use of [=credential private keys=]
        must all occur within the logical security boundary defining the [=authenticator=].
    </div>

    [=User verification=] procedures MAY implement [=rate limiting=] as a protection against brute force attacks.

: <dfn id=concept-user-verified>User Verified</dfn>
:: Upon successful completion of a [=user verification=] process, the user is said to be "[=user verified|verified=]".


# <dfn>Web Authentication API</dfn> # {#sctn-api}

This section normatively specifies the API for creating and using [=public key credentials=]. The basic
idea is that the credentials belong to the user and are [=managing authenticator|managed=] by a [=[WAA]=], with which the [=[WRP]=] interacts through the [=client platform=]. [=[RP]=] scripts can (with the [=user consent|user's consent=]) request the
browser to create a new credential for future use by the [=[RP]=]. See <a href="#fig-registration">Figure <span class="figure-num-following"/></a>, below.


<figure id="fig-registration">
    <img src="images/webauthn-registration-flow-01.svg"/>
    <figcaption>Registration Flow</figcaption>
</figure>


Scripts can also request the user’s permission to perform
[=authentication=] operations with an existing credential. See <a href="#fig-authentication">Figure <span class="figure-num-following"/></a>, below.


<figure id="fig-authentication">
    <img src="images/webauthn-authentication-flow-01.svg"/>
    <figcaption>Authentication Flow</figcaption>
</figure>


All such operations are performed in the authenticator and are mediated by
the [=client platform=] on the user's behalf. At no point does the script get access to the credentials themselves; it only
gets information about the credentials in the form of objects.

In addition to the above script interface, the authenticator MAY implement (or come with client software that implements) a user
interface for management. Such an interface MAY be used, for example, to reset the authenticator to a clean state or to inspect
the current state of the authenticator. In other words, such an interface is similar to the user interfaces provided by browsers
for managing user state such as history, saved passwords, and cookies. Authenticator management actions such as credential
deletion are considered to be the responsibility of such a user interface and are deliberately omitted from the API exposed to
scripts.

The security properties of this API are provided by the client and the authenticator working together. The authenticator, which
holds and [=managing authenticator|manages=] credentials, ensures that all operations are [=scoped=] to a particular [=origin=], and cannot be replayed against
a different [=origin=], by incorporating the [=origin=] in its responses. Specifically, as defined in [[#sctn-authenticator-ops]],
the full [=origin=] of the requester is included, and signed over, in the [=attestation object=] produced when a new credential
is created as well as in all assertions produced by WebAuthn credentials.

Additionally, to maintain user privacy and prevent malicious [=[RPS]=] from probing for the presence of [=public key
credentials=] belonging to other [=[RPS]=], each [=public key credential|credential=] is also [=scoped=] to a [=Relying Party
Identifier=], or [=RP ID=]. This [=RP ID=] is provided by the client to the [=authenticator=] for all operations, and the
[=authenticator=] ensures that [=public key credential|credentials=] created by a [=[RP]=] can only be used in operations
requested by the same [=RP ID=]. Separating the [=origin=] from the [=RP ID=] in this way allows the API to be used in cases
where a single [=[RP]=] maintains multiple [=origins=].

The client facilitates these security measures by providing the [=[RP]=]'s [=origin=] and [=RP ID=] to the [=authenticator=] for
each operation. Since this is an integral part of the WebAuthn security model, user agents only expose this API to callers in
[=secure contexts=].
For web contexts in particular,
this only includes those accessed via a secure transport (e.g., TLS) established without errors.

The Web Authentication API is defined by the union of the Web IDL fragments presented in the following sections. A combined IDL
listing is given in the [[#idl-index]].

## <dfn interface>PublicKeyCredential</dfn> Interface ## {#iface-pkcredential}

The {{PublicKeyCredential}} interface inherits from {{Credential}} [[!CREDENTIAL-MANAGEMENT-1]], and contains the attributes
that are returned to the caller when a new credential is created, or a new assertion is requested.

<xmp class="idl">
    [SecureContext, Exposed=Window]
    interface PublicKeyCredential : Credential {
        [SameObject] readonly attribute ArrayBuffer              rawId;
        [SameObject] readonly attribute AuthenticatorResponse    response;
        [SameObject] readonly attribute DOMString?               authenticatorAttachment;
        AuthenticationExtensionsClientOutputs getClientExtensionResults();
        static Promise<boolean> isConditionalMediationAvailable();
        PublicKeyCredentialJSON toJSON();
    };
</xmp>
<dl dfn-type="attribute" dfn-for="PublicKeyCredential">
    :   {{Credential/id}}
    ::  This attribute is inherited from {{Credential}}, though {{PublicKeyCredential}} overrides {{Credential}}'s getter,
        instead returning the [=base64url encoding=] of the data contained in the object's
        {{PublicKeyCredential/[[identifier]]}} [=internal slot=].

    :   {{PublicKeyCredential/rawId}}
    ::  This attribute returns the {{ArrayBuffer}} contained in the {{PublicKeyCredential/[[identifier]]}} internal slot.

    :   <dfn>response</dfn>
    ::  This attribute contains the [=authenticator=]'s response to the client's request to either create a [=public key
        credential=], or generate an [=authentication assertion=]. If the {{PublicKeyCredential}} is created in response to
        {{CredentialsContainer/create()}}, this attribute's value will be an {{AuthenticatorAttestationResponse}}, otherwise,
        the {{PublicKeyCredential}} was created in response to {{CredentialsContainer/get()}}, and this attribute's value
        will be an {{AuthenticatorAssertionResponse}}.

    :   <dfn>authenticatorAttachment</dfn>
    ::  This attribute reports the [=authenticator attachment modality=] in effect at the time the
        {{CredentialsContainer/create()|navigator.credentials.create()}} or
        {{CredentialsContainer/get()|navigator.credentials.get()}} methods successfully complete.
        The attribute’s value SHOULD be a member of {{AuthenticatorAttachment}}. [=[RPS]=] SHOULD treat unknown values
        as if the value were null.

        <div class="note">
        Note: If, as the result of a [=registration ceremony|registration=] or [=authentication ceremony=], {{PublicKeyCredential/authenticatorAttachment}}'s value is "cross-platform" and
        concurrently {{isUserVerifyingPlatformAuthenticatorAvailable}} returns [TRUE], then the user employed a [=roaming authenticator=] for this [=ceremony=] while there is an available
        [=platform authenticator=]. Thus the [=[RP]=] has the opportunity to prompt the user to register the available [=platform authenticator=], which may enable more streamlined user experience flows.

        An [=authenticator's=] [=authenticator attachment modality|attachment modality=] could change over time.
        For example, a mobile phone might at one time only support [=platform attachment=]
        but later receive updates to support [=cross-platform attachment=] as well.
        </div>




    :   {{PublicKeyCredential/getClientExtensionResults()}}
    ::  This operation returns the value of {{PublicKeyCredential/[[clientExtensionsResults]]}}, which is a [=map=] containing
        [=extension identifier=] → [=client extension output=] entries produced by the extension's
        [=client extension processing=].

    :   {{PublicKeyCredential/isConditionalMediationAvailable()}}
    ::  {{PublicKeyCredential}} overrides this method to indicate availability for {{CredentialMediationRequirement/conditional}}
        mediation. [=[WRPS]=] SHOULD verify availability before attempting to set
        <code>|options|.{{CredentialRequestOptions/mediation}}</code> to {{CredentialMediationRequirement/conditional}}.

        Upon invocation, a promise is returned that resolves with a value of [TRUE] if {{CredentialMediationRequirement/conditional}}
        [=user mediation=] is available, or [FALSE] otherwise.

        This method has no arguments and returns a promise to a Boolean value.

        Note: If this method is not present, {{CredentialMediationRequirement/conditional}} [=user mediation=] is not available.

    :   {{PublicKeyCredential/toJSON()}}
    ::  This operation returns {{RegistrationResponseJSON}} or {{AuthenticationResponseJSON}},
        which are [=JSON type=] representations mirroring {{PublicKeyCredential}}, suitable for submission to a
        [=[RP]=] server as an `application/json` payload. The [=client=] is in charge of
        [serializing values to JSON types as usual](https://webidl.spec.whatwg.org/#idl-tojson-operation),
        but MUST take additional steps to first encode any {{ArrayBuffer}} values to {{DOMString}} values
        using [=base64url encoding=].

        The
        {{RegistrationResponseJSON/clientExtensionResults|RegistrationResponseJSON.clientExtensionResults}} or
        {{AuthenticationResponseJSON/clientExtensionResults|AuthenticationResponseJSON.clientExtensionResults}}
        member MUST be set to the output of {{PublicKeyCredential/getClientExtensionResults()}},
        with any {{ArrayBuffer}} values encoded to {{DOMString}} values using
        [=base64url encoding=]. This MAY include {{ArrayBuffer}} values from extensions registered
        in the IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] but not
        defined in [[#sctn-extensions]].

        The {{AuthenticatorAttestationResponseJSON/transports|AuthenticatorAttestationResponseJSON.transports}}
        member MUST be set to the output of {{AuthenticatorAttestationResponse/getTransports()}}.
</dl>

<xmp class="idl">
    typedef DOMString Base64URLString;
    typedef (RegistrationResponseJSON or AuthenticationResponseJSON) PublicKeyCredentialJSON;

    dictionary RegistrationResponseJSON {
        Base64URLString id;
        Base64URLString rawId;
        AuthenticatorAttestationResponseJSON response;
        DOMString?  authenticatorAttachment;
        AuthenticationExtensionsClientOutputsJSON clientExtensionResults;
        DOMString type;
    };

    dictionary AuthenticatorAttestationResponseJSON {
        Base64URLString clientDataJSON;
        Base64URLString attestationObject;
        sequence<DOMString> transports;
    };

    dictionary AuthenticationResponseJSON {
        Base64URLString id;
        Base64URLString rawId;
        AuthenticatorAssertionResponseJSON response;
        DOMString?  authenticatorAttachment;
        AuthenticationExtensionsClientOutputsJSON clientExtensionResults;
        DOMString type;
    };

    dictionary AuthenticatorAssertionResponseJSON {
        Base64URLString clientDataJSON;
        Base64URLString authenticatorData;
        Base64URLString signature;
        Base64URLString? userHandle;
    };

    dictionary AuthenticationExtensionsClientOutputsJSON {
    };
</xmp>

<dl dfn-type="attribute" dfn-for="PublicKeyCredential">
    :   <dfn>\[[type]]</dfn>
    ::  The {{PublicKeyCredential}} [=interface object=]'s {{Credential/[[type]]}} [=internal slot=]'s value is the string
        "`public-key`".

        Note: This is reflected via the {{Credential/type}} attribute getter inherited from {{Credential}}.

    :   <dfn>\[[discovery]]</dfn>
    ::  The {{PublicKeyCredential}} [=interface object=]'s {{Credential/[[discovery]]}} [=internal slot=]'s value is
        "{{Credential/[[discovery]]/remote}}".

    :   <dfn>\[[identifier]]</dfn>
    ::  This [=internal slot=] contains the [=credential ID=], chosen by the authenticator.
        The [=credential ID=] is used to look up credentials for use, and is therefore expected to be globally unique
        with high probability across all credentials of the same type, across all authenticators.

        Note: This API does not constrain
        the format or length of this identifier, except that it MUST be sufficient for the [=authenticator=] to uniquely select a key.
        For example, an authenticator without on-board storage may create identifiers containing a [=credential private key=]
        wrapped with a symmetric key that is burned into the authenticator.

    :   <dfn>\[[clientExtensionsResults]]</dfn>
    ::  This [=internal slot=] contains the results of processing client extensions requested by the [=[RP]=] upon the
        [=[RP]=]'s invocation of either {{CredentialsContainer/create()|navigator.credentials.create()}} or
        {{CredentialsContainer/get()|navigator.credentials.get()}}.
</dl>

{{PublicKeyCredential}}'s [=interface object=] inherits {{Credential}}'s implementation of
{{Credential/[[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)}}, and defines its own
implementation of {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}}, {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}, and
{{Credential/[[Store]](credential, sameOriginWithAncestors)}}.


### `CredentialCreationOptions` Dictionary Extension ### {#sctn-credentialcreationoptions-extension}

To support registration via {{CredentialsContainer/create()|navigator.credentials.create()}}, this document extends
the {{CredentialCreationOptions}} dictionary as follows:

<xmp class="idl">
    partial dictionary CredentialCreationOptions {
        PublicKeyCredentialCreationOptions      publicKey;
    };
</xmp>

### `CredentialRequestOptions` Dictionary Extension ### {#sctn-credentialrequestoptions-extension}

To support obtaining assertions via {{CredentialsContainer/get()|navigator.credentials.get()}}, this document extends the
{{CredentialRequestOptions}} dictionary as follows:

<xmp class="idl">
    partial dictionary CredentialRequestOptions {
        PublicKeyCredentialRequestOptions      publicKey;
    };
</xmp>


### Create a New Credential - PublicKeyCredential's `[[Create]](origin, options, sameOriginWithAncestors)` Method ### {#sctn-createCredential}

<div link-for-hint="PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)">
{{PublicKeyCredential}}'s [=interface object=]'s implementation of the <dfn for="PublicKeyCredential" method>\[[Create]](origin,
options, sameOriginWithAncestors)</dfn> [=internal method=] [[!CREDENTIAL-MANAGEMENT-1]] allows
[=[WRP]=] scripts to call {{CredentialsContainer/create()|navigator.credentials.create()}} to request the creation of a new
[=public key credential source=], [=bound credential|bound=] to an [=authenticator=]. This
{{CredentialsContainer/create()|navigator.credentials.create()}} operation can be aborted by leveraging the {{AbortController}};
see [[dom#abortcontroller-api-integration]] for detailed instructions.


This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)">

    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s [=environment settings object/origin=], as determined by the
        calling {{CredentialsContainer/create()}} implementation.

    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialCreationOptions}} object whose
        <code>|options|.{{CredentialCreationOptions/publicKey}}</code> member contains a {{PublicKeyCredentialCreationOptions}}
        object specifying the desired attributes of the to-be-created [=public key credential=].

    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the caller's [=environment settings object=] is
        [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.

</dl>

Note: <strong>This algorithm is synchronous:</strong> the {{Promise}} resolution/rejection is handled by
{{CredentialsContainer/create()|navigator.credentials.create()}}.

Note: All {{BufferSource}} objects used in this algorithm must be snapshotted when the algorithm begins, to
avoid potential synchronization issues. The algorithm implementations should [=get a copy of the bytes held
by the buffer source=] and use that copy for relevant portions of the algorithm.

When this method is invoked, the user agent MUST execute the following algorithm:

1. Assert: <code>|options|.{{CredentialCreationOptions/publicKey}}</code> is present.

1. If <var ignore>sameOriginWithAncestors</var> is [FALSE], throw a "{{NotAllowedError}}" {{DOMException}}.

    Note: This "sameOriginWithAncestors" restriction aims to address a tracking concern raised in [Issue #1336](https://github.com/w3c/webauthn/issues/1336). This may be revised in future versions of this specification.

1. Let |pkOptions| be the value of <code>|options|.{{CredentialCreationOptions/publicKey}}</code>.

1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/timeout}}</code> is present, check if its value lies within a
    reasonable range as defined by the [=client=] and if not, correct it to the closest value lying within that range. Set a timer
    |lifetimeTimer| to this adjusted value. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/timeout}}</code> is not
    present, then set |lifetimeTimer| to a [=client=]-specific default.

        Recommended ranges and defaults for <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/timeout}}</code> are as follows.
          If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{AuthenticatorSelectionCriteria/userVerification}}</code>
            <dl class="switch">
                :   is set to {{UserVerificationRequirement/discouraged}}
                ::  Recommended range: 30000 milliseconds to 180000 milliseconds.
                ::  Recommended default value: 120000 milliseconds (2 minutes).

                :   is set to {{UserVerificationRequirement/required}} or {{UserVerificationRequirement/preferred}}
                ::  Recommended range: 30000 milliseconds to 600000 milliseconds.
                ::  Recommended default value: 300000 milliseconds (5 minutes).
            </dl>

        Note: The user agent should take cognitive guidelines into considerations regarding timeout for users with special needs.

1. If the length of <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/user}}.{{PublicKeyCredentialUserEntity/id}}</code> is not between 1 and 64 bytes (inclusive) then throw a {{TypeError}}.

1. Let |callerOrigin| be {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)/origin}}. If |callerOrigin| is an [=opaque origin=], throw a "{{NotAllowedError}}" {{DOMException}}.

1. Let |effectiveDomain| be the |callerOrigin|'s [=effective domain=].
    If [=effective domain=] is not a [=valid domain=], then throw a
    "{{SecurityError}}" {{DOMException}}.

    Note: An [=effective domain=] may resolve to a [=host=], which can be represented in various manners,
        such as [=domain=], [=ipv4 address=], [=ipv6 address=], [=opaque host=], or [=empty host=].
        Only the [=domain=] format of [=host=] is allowed here. This is for simplification and also
        is in recognition of various issues with using direct IP address identification in concert
        with PKI-based security.

<!-- Note: this next step is actually a top-level step, but bikeshed wanted it indented this much in order to render it as
a numbered step. If outdented, it (today) is rendered as a bullet in the midst of a numbered list :-/
-->
    <li id='CreateCred-DetermineRpId'>

        If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code>
            <dl class="switch">

                :   is present
                ::  If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code> [=is not a
                    registrable domain suffix of and is not equal to=] |effectiveDomain|, throw a "{{SecurityError}}" {{DOMException}}.

                :   Is not present
                ::  Set <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code> to
                    |effectiveDomain|.
            </dl>

        Note: <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code> represents the
            caller's [=RP ID=]. The [=RP ID=] defaults to being the caller's [=environment settings object/origin=]'s
            [=effective domain=] unless the caller has explicitly set
            <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code> when calling
            {{CredentialsContainer/create()}}.
    </li>

1. Let |credTypesAndPubKeyAlgs| be a new [=list=] whose [=list/items=] are pairs of {{PublicKeyCredentialType}} and
    a {{COSEAlgorithmIdentifier}}.

1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/pubKeyCredParams}}</code>'s [=list/size=]
    <dl class="switch">
        :   is zero
        ::  [=list/Append=] the following pairs of {{PublicKeyCredentialType}} and {{COSEAlgorithmIdentifier}} values to |credTypesAndPubKeyAlgs|:
             * {{public-key}} and <code>-7</code> ("ES256").
             * {{public-key}} and <code>-257</code> ("RS256").

        :   is non-zero
        ::  [=list/For each=] |current| of <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/pubKeyCredParams}}</code>:

            1. If <code>|current|.{{PublicKeyCredentialParameters/type}}</code> does not contain a {{PublicKeyCredentialType}} supported
                by this implementation, then [=continue=].
            1. Let |alg| be <code>|current|.{{PublicKeyCredentialParameters/alg}}</code>.
            1. [=list/Append=] the pair of <code>|current|.{{PublicKeyCredentialParameters/type}}</code> and |alg| to
                |credTypesAndPubKeyAlgs|.

            If |credTypesAndPubKeyAlgs| [=list/is empty=], throw a "{{NotSupportedError}}" {{DOMException}}.
    </dl>

1. Let |clientExtensions| be a new [=map=] and let |authenticatorExtensions| be a new [=map=].

1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/extensions}}</code> is present, then [=map/for each=]
    |extensionId| → |clientExtensionInput| of <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/extensions}}</code>:
    1. If |extensionId| is not supported by this [=client platform=] or is not a [=registration extension=], then [=continue=].

    1. [=map/Set=] |clientExtensions|[|extensionId|] to |clientExtensionInput|.

    1. If |extensionId| is not an [=authenticator extension=], then [=continue=].

    1. Let |authenticatorExtensionInput| be the ([=CBOR=]) result of running |extensionId|'s [=client extension processing=]
        algorithm on |clientExtensionInput|. If the algorithm returned an error, [=continue=].

    1. [=map/Set=] |authenticatorExtensions|[|extensionId|] to the [=base64url encoding=] of |authenticatorExtensionInput|.

1. Let |collectedClientData| be a new {{CollectedClientData}} instance whose fields are:
    : {{CollectedClientData/type}}
    :: The string "webauthn.create".
    : {{CollectedClientData/challenge}}
    :: The [=base64url encoding=] of |pkOptions|.{{PublicKeyCredentialCreationOptions/challenge}}.
    : {{CollectedClientData/origin}}
    :: The [=ascii serialization of an origin|serialization of=] |callerOrigin|.
    : {{CollectedClientData/crossOrigin}}
    :: The inverse of the value of the
        {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)/sameOriginWithAncestors}}
        argument passed to this [=internal method=].

1. Let |clientDataJSON| be the [=JSON-compatible serialization of client data=] constructed from |collectedClientData|.

1. Let |clientDataHash| be the [=hash of the serialized client data=] represented by |clientDataJSON|.

1. If <code>|options|.{{CredentialCreationOptions/signal}}</code> is present and [=AbortSignal/aborted=], throw
    the <code>|options|.{{CredentialCreationOptions/signal}}</code>'s [=AbortSignal/abort reason=].

1. Let |issuedRequests| be a new [=ordered set=].

1. Let |authenticators| represent a value which at any given instant is a [=set=] of [=client platform=]-specific handles, where each
    [=set/item=] identifies an [=authenticator=] presently available on this [=client platform=] at that instant.

    Note: What qualifies an [=authenticator=] as "available" is intentionally unspecified; this is meant to represent how
    [=authenticators=] can be <a href="https://en.wikipedia.org/w/index.php?title=Hot_plug">hot-plugged</a> into (e.g., via USB)
    or discovered (e.g., via NFC or Bluetooth) by the [=client=] by various mechanisms, or permanently built into the [=client=].

1. Start |lifetimeTimer|.

1. [=While=] |lifetimeTimer| has not expired, perform the following actions depending upon |lifetimeTimer|,
    and the state and response [=set/for each=] |authenticator| in |authenticators|:
    <dl class="switch">
        :   If |lifetimeTimer| expires,
        ::  [=set/For each=] |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on |authenticator|
            and [=set/remove=] |authenticator| from |issuedRequests|.

        :   If the user exercises a user agent user-interface option to cancel the process,
        ::  [=set/For each=] |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on |authenticator|
            and [=set/remove=] |authenticator| from |issuedRequests|. Throw a "{{NotAllowedError}}" {{DOMException}}.

        :   If <code>|options|.{{CredentialCreationOptions/signal}}</code> is present and [=AbortSignal/aborted=],
        ::  [=set/For each=] |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=]
            operation on |authenticator| and [=set/remove=] |authenticator| from |issuedRequests|. Then throw the
            <code>|options|.{{CredentialCreationOptions/signal}}</code>'s [=AbortSignal/abort reason=].

        :   If an |authenticator| becomes available on this [=client device=],
        ::  Note:  This includes the case where an |authenticator| was available upon |lifetimeTimer| initiation.

            1. This |authenticator| is now the <dfn for="create">candidate authenticator</dfn>.

            1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}</code> is present:

                  1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{AuthenticatorSelectionCriteria/authenticatorAttachment}}</code> is
                    present and its value is not equal to |authenticator|'s [=authenticator attachment modality=], [=iteration/continue=].

                  1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{residentKey}}</code>

                      <dl class="switch">
                          :   is present and set to {{ResidentKeyRequirement/required}}
                          ::  If the |authenticator| is not capable of storing a [=client-side discoverable public key credential
                              source=], [=iteration/continue=].

                          :   is present and set to {{ResidentKeyRequirement/preferred}} or {{ResidentKeyRequirement/discouraged}}
                          ::  No effect.

                          :   is not present
                          ::  if <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{requireResidentKey}}</code>
                              is set to [TRUE] and the |authenticator| is not capable of storing a [=client-side discoverable public
                              key credential source=], [=iteration/continue=].
                      </dl>

                  1. If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{AuthenticatorSelectionCriteria/userVerification}}</code> is
                    set to {{UserVerificationRequirement/required}} and the |authenticator| is not capable of performing [=user
                    verification=], [=iteration/continue=].

            1. Let |requireResidentKey| be the <dfn>effective resident key requirement for credential creation</dfn>, a Boolean value, as follows:

                If <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{residentKey}}</code>

                    <dl class="switch">

                        :   is present and set to {{ResidentKeyRequirement/required}}
                        ::  Let |requireResidentKey| be [TRUE].

                        :   is present and set to {{ResidentKeyRequirement/preferred}}
                        ::  If the |authenticator|

                            <dl class="switch">
                                :   is capable of [=client-side credential storage modality=]
                                ::  Let |requireResidentKey| be [TRUE].

                                :   is not capable of [=client-side credential storage modality=], or if the [=client=] cannot determine authenticator capability,
                                ::  Let |requireResidentKey| be [FALSE].
                            </dl>

                        :   is present and set to {{ResidentKeyRequirement/discouraged}}
                        ::  Let |requireResidentKey| be [FALSE].

                        :   is not present
                        ::  Let |requireResidentKey| be the value of <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{requireResidentKey}}</code>.

                    </dl>

            1. Let |userVerification| be the <dfn>effective user verification requirement for credential creation</dfn>, a Boolean value,
                as follows. If
                <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{AuthenticatorSelectionCriteria/userVerification}}</code>

                    <dl class="switch">

                        :   is set to {{UserVerificationRequirement/required}}
                        ::  Let |userVerification| be [TRUE].

                        :   is set to {{UserVerificationRequirement/preferred}}
                        ::  If the |authenticator|

                            <dl class="switch">
                                :   is capable of [=user verification=]
                                ::  Let |userVerification| be [TRUE].

                                :   is not capable of [=user verification=]
                                ::  Let |userVerification| be [FALSE].
                            </dl>

                        :   is set to {{UserVerificationRequirement/discouraged}}
                        ::  Let |userVerification| be [FALSE].

                    </dl>

            1. Let |enterpriseAttestationPossible| be a Boolean value, as follows. If
                <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/attestation}}</code>

                    <dl class="switch">

                        :   is set to {{AttestationConveyancePreference/enterprise}}
                        ::  Let |enterpriseAttestationPossible| be [TRUE] if the user agent wishes to support enterprise attestation for <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code> (see [Step 8](#CreateCred-DetermineRpId), above). Otherwise [FALSE].

                        :   otherwise
                        ::  Let |enterpriseAttestationPossible| be [FALSE].

                    </dl>

            1. Let |attestationFormats| be a list of strings, initialized to the value of <code>|options|.{{PublicKeyCredentialCreationOptions/attestationFormats}}</code>.

            1. If <code>|options|.{{PublicKeyCredentialCreationOptions/attestation}}</code>

                    <dl class="switch">

                        :   is set to {{AttestationConveyancePreference/none}}
                        ::  Set |attestationFormats| be the single-element list containing the string &ldquo;none&rdquo;

                    </dl>

            1. Let |excludeCredentialDescriptorList| be a new [=list=].

            1. [=list/For each=] credential descriptor |C| in <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/excludeCredentials}}</code>:
                1. If <code>|C|.{{PublicKeyCredentialDescriptor/transports}}</code> [=list/is not empty=], and |authenticator| is connected over a transport not
                    mentioned in <code>|C|.{{PublicKeyCredentialDescriptor/transports}}</code>, the client MAY [=continue=].

                    Note: If the client chooses to [=continue=], this could result in
                    inadvertently registering multiple credentials [=bound credential|bound to=] the same [=authenticator=]
                    if the transport hints in <code>|C|.{{PublicKeyCredentialDescriptor/transports}}</code> are not accurate.
                    For example, stored transport hints could become inaccurate
                    as a result of software upgrades adding new connectivity options.

                1. Otherwise, [=list/Append=] |C| to |excludeCredentialDescriptorList|.

<!-- Note: this next step is actually a top-level step, but bikeshed wanted it indented this much in order to render it as
a numbered step. If outdented, it (today) is rendered either as a bullet in the midst of a numbered list or is mis-numabered :-/
-->
                    <li id='CreateCred-InvokeAuthnrMakeCred'>

                        <!-- @@EDITOR-ANCHOR-01: KEEP THIS LIST SYNC'D WITH OTHER LOCATIONS WITH THIS TAG -->
                        Invoke the [=authenticatorMakeCredential=] operation on |authenticator| with
                            |clientDataHash|,
                            <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/rp}}</code>,
                            <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/user}}</code>,
                            |requireResidentKey|,
                            |userVerification|,
                            |credTypesAndPubKeyAlgs|,
                            |excludeCredentialDescriptorList|,
                            |enterpriseAttestationPossible|,
                            |attestationFormats|,
                            and |authenticatorExtensions| as parameters.
                    </li>

            1. [=set/Append=] |authenticator| to |issuedRequests|.

        :   If an |authenticator| ceases to be available on this [=client device=],
        ::  [=set/Remove=] |authenticator| from |issuedRequests|.

        :   If any |authenticator| returns a status indicating that the user cancelled the operation,
        ::  1. [=set/Remove=] |authenticator| from |issuedRequests|.
            1. [=set/For each=] remaining |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on
                |authenticator| and [=set/remove=] it from |issuedRequests|.

                Note: [=Authenticators=] may return an indication of "the user cancelled the entire operation".
                How a user agent manifests this state to users is unspecified.

        :   If any |authenticator| returns an error status equivalent to "{{InvalidStateError}}",
        ::  1. [=set/Remove=] |authenticator| from |issuedRequests|.
            1. [=set/For each=] remaining |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on
                |authenticator| and [=set/remove=] it from |issuedRequests|.
            1. Throw an "{{InvalidStateError}}" {{DOMException}}.

            Note: This error status is handled separately because the |authenticator| returns it only if
            |excludeCredentialDescriptorList| identifies a credential [=bound credential|bound=] to the |authenticator| and the user has [=user
            consent|consented=] to the operation. Given this explicit consent, it is acceptable for this case to be
            distinguishable to the [=[RP]=].

        :   If any |authenticator| returns an error status not equivalent to "{{InvalidStateError}}",
        ::  [=set/Remove=] |authenticator| from |issuedRequests|.

            Note: This case does not imply [=user consent=] for the operation, so details about the error are hidden from the
            [=[RP]=] in order to prevent leak of potentially identifying information. See [[#sctn-make-credential-privacy]] for
            details.

        :   If any |authenticator| indicates success,
        ::  1.  [=set/Remove=] |authenticator| from |issuedRequests|. This authenticator is now the <dfn for="create">selected authenticator</dfn>.

            1.  Let |credentialCreationData| be a [=struct=] whose [=items=] are:

                :   <code><dfn for="credentialCreationData">attestationObjectResult</dfn></code>
                ::  whose value is the bytes returned from the successful [=authenticatorMakeCredential=] operation.

                    Note: this value is <code>attObj</code>, as defined in [[#sctn-generating-an-attestation-object]].

                :   <code><dfn for="credentialCreationData">clientDataJSONResult</dfn></code>
                ::  whose value is the bytes of |clientDataJSON|.

                :   <code><dfn for="credentialCreationData">attestationConveyancePreferenceOption</dfn></code>
                ::  whose value is the value of |pkOptions|.{{PublicKeyCredentialCreationOptions/attestation}}.

                :   <code><dfn for="credentialCreationData">clientExtensionResults</dfn></code>
                ::  whose value is an {{AuthenticationExtensionsClientOutputs}} object containing [=extension identifier=] →
                    [=client extension output=] entries. The entries are created by running each extension's
                    [=client extension processing=] algorithm to create the [=client extension outputs=], for each
                    [=client extension=] in <code>|pkOptions|.{{PublicKeyCredentialCreationOptions/extensions}}</code>.

            1.  Let |constructCredentialAlg| be an algorithm that takes a [=global object=]
                |global|, and whose steps are:

                1.  If <code>|credentialCreationData|.[=attestationConveyancePreferenceOption=]</code>'s value is
                    <dl class="switch">
                        :   {{AttestationConveyancePreference/none}}
                        ::  Replace potentially uniquely identifying information with non-identifying versions of the
                            same:
                               1. If the [=AAGUID=] in the [=attested credential data=] is 16 zero bytes, <code>|credentialCreationData|.[=attestationObjectResult=].fmt</code> is "packed", and "x5c" is absent from <code>|credentialCreationData|.[=attestationObjectResult=]</code>, then [=self attestation=] is being used and no further action is needed.
                               1. Otherwise
                                  1. Replace the [=AAGUID=] in the [=attested credential data=] with 16 zero bytes.
                                  1. Set the value of <code>|credentialCreationData|.[=attestationObjectResult=].fmt</code> to "none", and set the value of <code>|credentialCreationData|.[=attestationObjectResult=].attStmt</code> to be an empty [=CBOR=] map. (See [[#sctn-none-attestation]] and [[#sctn-generating-an-attestation-object]]).

                        :   {{AttestationConveyancePreference/indirect}}
                        ::  The client MAY replace the [=AAGUID=] and [=attestation statement=] with a more privacy-friendly
                            and/or more easily verifiable version of the same data (for example, by employing an [=Anonymization CA=]).

                        :   {{AttestationConveyancePreference/direct}} or {{AttestationConveyancePreference/enterprise}}
                        ::  Convey the [=authenticator=]'s [=AAGUID=] and [=attestation statement=], unaltered, to the [=[RP]=].
                    </dl>

                1.  Let |attestationObject| be a new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the
                    bytes of <code>|credentialCreationData|.[=attestationObjectResult=]</code>'s value.

                1.  Let |id| be <code>|attestationObject|.authData.[=attestedCredentialData=].[=credentialId=]</code>.

                1.  Let |pubKeyCred| be a new {{PublicKeyCredential}} object associated with |global| whose fields are:

                    :   {{PublicKeyCredential/[[identifier]]}}
                    ::  |id|

                    :   {{PublicKeyCredential/authenticatorAttachment}}
                    ::  The {{AuthenticatorAttachment}} value matching the current [=authenticator attachment modality=] of |authenticator|.

                    :   {{PublicKeyCredential/response}}
                    ::  A new {{AuthenticatorAttestationResponse}} object associated with |global| whose fields are:

                        :   {{AuthenticatorResponse/clientDataJSON}}
                        ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                            <code>|credentialCreationData|.[=credentialCreationData/clientDataJSONResult=]</code>.

                        :   {{AuthenticatorAttestationResponse/attestationObject}}
                        ::  |attestationObject|

                        :   {{AuthenticatorAttestationResponse/[[transports]]}}
                        ::  A sequence of zero or more unique {{DOMString}}s, in lexicographical order, that the |authenticator| is believed to support. The values SHOULD be members of {{AuthenticatorTransport}}, but [=client platforms=] MUST ignore unknown values.

                            If a user agent does not wish to divulge this information it MAY substitute an arbitrary sequence designed to preserve privacy. This sequence MUST still be valid, i.e. lexicographically sorted and free of duplicates. For example, it may use the empty sequence. Either way, in this case the user agent takes the risk that [=[RP]=] behavior may be suboptimal.

                            If the user agent does not have any transport information, it SHOULD set this field to the empty sequence.

                            Note: How user agents discover transports supported by a given [=authenticator=] is outside the scope of this specification, but may include information from an [=attestation certificate=] (for example [[FIDO-Transports-Ext]]), metadata communicated in an [=authenticator=] protocol such as CTAP2, or special-case knowledge about a [=platform authenticator=].

                    :   {{PublicKeyCredential/[[clientExtensionsResults]]}}
                    ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                        <code>|credentialCreationData|.[=credentialCreationData/clientExtensionResults=]</code>.

                1.  Return |pubKeyCred|.

            1. [=set/For each=] remaining |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on
                |authenticator| and [=set/remove=] it from |issuedRequests|.

            1. Return |constructCredentialAlg| and terminate this algorithm.

    </dl>

1. Throw a "{{NotAllowedError}}" {{DOMException}}. In order to prevent information leak that could identify the
    user without [=user consent|consent=], this step MUST NOT be executed before |lifetimeTimer| has expired. See
    [[#sctn-make-credential-privacy]] for details.

During the above process, the user agent SHOULD show some UI to the user to guide them in the process of selecting and
authorizing an authenticator.
</div>


### Use an Existing Credential to Make an Assertion - PublicKeyCredential's `[[Get]](options)` Method ### {#sctn-getAssertion}

[=[WRPS]=] call <code><a idl for="CredentialsContainer" lt="get()">navigator.credentials.get({publicKey:..., ...})</a></code> to
discover and use an existing [=public key credential=], with the [=user consent|user's consent=]. [=[RP]=] script optionally specifies some criteria
to indicate what [=public key credential sources=] are acceptable to it. The [=client platform=] locates [=public key credential sources=]
matching the specified criteria, and guides the user to pick one that the script will be allowed to use. The user may choose to
decline the entire interaction even if a [=public key credential source=] is present, for example to maintain privacy. If the user picks a
[=public key credential source=], the user agent then uses
[[#sctn-op-get-assertion]] to sign a [=[RP]=]-provided challenge and other collected data into an [=authentication assertion=], which is used as a
[=credential=].

The {{CredentialsContainer/get()|navigator.credentials.get()}} implementation [[!CREDENTIAL-MANAGEMENT-1]] calls
<code>PublicKeyCredential.{{PublicKeyCredential/[[CollectFromCredentialStore]]()}}</code> to collect any [=credentials=] that
should be available without [=user mediation=] (roughly, this specification's [=authorization gesture=]), and if it does not find
exactly one of those, it then calls <code>PublicKeyCredential.{{PublicKeyCredential/[[DiscoverFromExternalSource]]()}}</code> to have
the user select a [=public key credential source=].

Since this specification requires an [=authorization gesture=] to create any [=assertions=], the <code>PublicKeyCredential.<dfn
for="PublicKeyCredential" method>\[[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)</dfn></code> [=internal method=] inherits the default behavior of
{{Credential/[[CollectFromCredentialStore]]()|Credential.[[CollectFromCredentialStore]]()}}, of returning an empty set.

In general, the user agent SHOULD show some UI to the user to guide them in selecting and authorizing an authenticator with which
to complete the operation. By setting <code>|options|.{{CredentialRequestOptions/mediation}}</code> to {{CredentialMediationRequirement/conditional}}, [=[RPS]=] can indicate that a prominent modal UI should <i>not</i> be shown <i>unless</i> credentials are discovered. [=[RP]=]
script SHOULD first check that {{PublicKeyCredential/isConditionalMediationAvailable()}} returns [TRUE] in order to avoid
the possibility of causing a user-visible error to be returned if the user agent does not support
{{CredentialMediationRequirement/conditional}} [=user mediation=].

This
{{CredentialsContainer/get()|navigator.credentials.get()}} operation can be aborted by leveraging the {{AbortController}};
see [[dom#abortcontroller-api-integration]] for detailed instructions.

#### PublicKeyCredential's <code><dfn for="PublicKeyCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn></code> Method #### {#sctn-discover-from-external-source}

<div link-for-hint="PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">

    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s [=environment settings object/origin=], as determined by the
        calling {{CredentialsContainer/get()}} implementation, i.e., {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        <code>|options|.{{CredentialRequestOptions/publicKey}}</code> member contains a {{PublicKeyCredentialRequestOptions}}
        object specifying the desired attributes of the [=public key credential=] to discover.

    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the caller's [=environment settings object=] is
        [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.

        Note: Invocation of this [=internal method=] indicates that it was allowed by
        [=permissions policy=], which is evaluated at the [[!CREDENTIAL-MANAGEMENT-1]] level.
        See [[#sctn-permissions-policy]].
</dl>

Note: <strong>This algorithm is synchronous:</strong> the {{Promise}} resolution/rejection is handled by
{{CredentialsContainer/get()|navigator.credentials.get()}}.

Note: All {{BufferSource}} objects used in this algorithm must be snapshotted when the algorithm begins, to
avoid potential synchronization issues. The algorithm implementations should [=get a copy of the bytes held
by the buffer source=] and use that copy for relevant portions of the algorithm.

When this method is invoked, the user agent MUST execute the following algorithm:

1. Assert: <code>|options|.{{CredentialRequestOptions/publicKey}}</code> is present.

1. Let |pkOptions| be the value of <code>|options|.{{CredentialRequestOptions/publicKey}}</code>.

1. If <code>|options|.{{CredentialRequestOptions/mediation}}</code> is present with the value
    {{CredentialMediationRequirement/conditional}}:

    1. Let |credentialIdFilter| be the value of <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code>.

    1. Set <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code> to [=list/empty=].

        Note: This prevents [=non-discoverable credentials=] from being used during {{CredentialMediationRequirement/conditional}} requests.

    1. Set a timer |lifetimeTimer| to a value of infinity.

        Note: |lifetimeTimer| is set to a value of infinity so that the user has the entire lifetime of
        the [=Document=] to interact with any <{input}> form control tagged with a `"webauthn"` [=autofill detail token=]. For example, upon the user clicking in such an input field, the user agent can render a list of discovered credentials for the user to select from, and perhaps also give the user the option to "try another way".

1. Else:

    1. Let |credentialIdFilter| be an [=list/empty=] [=list=].

    1. If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/timeout}}</code> is present, check if its value lies
        within a reasonable range as defined by the [=client=] and if not, correct it to the closest value lying within that range.
        Set a timer |lifetimeTimer| to this adjusted value. If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/timeout}}</code>
        is not present, then set |lifetimeTimer| to a [=client=]-specific default.

            Recommended ranges and defaults for <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/timeout}}</code> are as follows.
              If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/userVerification}}</code>
                <dl class="switch">
                    :   is set to {{UserVerificationRequirement/discouraged}}
                    ::  Recommended range: 30000 milliseconds to 180000 milliseconds.
                    ::  Recommended default value: 120000 milliseconds (2 minutes).

                    :   is set to {{UserVerificationRequirement/required}} or {{UserVerificationRequirement/preferred}}
                    ::  Recommended range: 30000 milliseconds to 600000 milliseconds.
                    ::  Recommended default value: 300000 milliseconds (5 minutes).
                </dl>

            Note: The user agent should take cognitive guidelines into considerations regarding timeout for users with special needs.

1. Let |callerOrigin| be {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)/origin}}. If |callerOrigin| is
    an [=opaque origin=], throw a "{{NotAllowedError}}" {{DOMException}}.

1. Let |effectiveDomain| be the |callerOrigin|'s [=effective domain=].
    If [=effective domain=] is not a [=valid domain=], then throw a
    "{{SecurityError}}" {{DOMException}}.

    Note: An [=effective domain=] may resolve to a [=host=], which can be represented in various manners,
        such as [=domain=], [=ipv4 address=], [=ipv6 address=], [=opaque host=], or [=empty host=].
        Only the [=domain=] format of [=host=] is allowed here. This is for simplification and also is
        in recognition of various issues with using direct IP address identification in concert with
        PKI-based security.

        <li id='GetAssn-DetermineRpId'>
            If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/rpId}}</code> is not present, then set |rpId| to
                |effectiveDomain|.

                Otherwise:

                1. If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/rpId}}</code> [=is not a registrable domain suffix of and is not
                    equal to=] |effectiveDomain|, throw a "{{SecurityError}}" {{DOMException}}.

                1. Set |rpId| to <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/rpId}}</code>.

                    Note: |rpId| represents the caller's [=RP ID=]. The [=RP ID=] defaults to being the caller's [=environment
                    settings object/origin=]'s [=effective domain=] unless the caller has explicitly set
                    <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/rpId}}</code> when calling {{CredentialsContainer/get()}}.
        </li>

1. Let |clientExtensions| be a new [=map=] and let |authenticatorExtensions| be a new [=map=].

1. If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/extensions}}</code> is present, then [=map/for each=]
    |extensionId| → |clientExtensionInput| of <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/extensions}}</code>:
    1. If |extensionId| is not supported by this [=client platform=] or is not an [=authentication extension=], then [=continue=].

    1. [=map/Set=] |clientExtensions|[|extensionId|] to |clientExtensionInput|.

    1. If |extensionId| is not an [=authenticator extension=], then [=continue=].

    1. Let |authenticatorExtensionInput| be the ([=CBOR=]) result of running |extensionId|'s [=client extension processing=]
        algorithm on |clientExtensionInput|. If the algorithm returned an error, [=continue=].

    1. [=map/Set=] |authenticatorExtensions|[|extensionId|] to the [=base64url encoding=] of |authenticatorExtensionInput|.

1. Let |collectedClientData| be a new {{CollectedClientData}} instance whose fields are:
    : {{CollectedClientData/type}}
    :: The string "webauthn.get".
    : {{CollectedClientData/challenge}}
    :: The [=base64url encoding=] of |pkOptions|.{{PublicKeyCredentialRequestOptions/challenge}}
    : {{CollectedClientData/origin}}
    :: The [=ascii serialization of an origin|serialization of=] |callerOrigin|.
    : {{CollectedClientData/crossOrigin}}
    :: The inverse of the value of the
        {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)/sameOriginWithAncestors}}
        argument passed to this [=internal method=].

1. Let |clientDataJSON| be the [=JSON-compatible serialization of client data=] constructed from |collectedClientData|.

1. Let |clientDataHash| be the [=hash of the serialized client data=] represented by |clientDataJSON|.

1. If <code>|options|.{{CredentialRequestOptions/signal}}</code> is present and [=AbortSignal/aborted=], throw
    the <code>|options|.{{CredentialRequestOptions/signal}}</code>'s [=AbortSignal/abort reason=].

1. Let |issuedRequests| be a new [=ordered set=].

1. Let |savedCredentialIds| be a new [=map=].

1. Let |authenticators| represent a value which at any given instant is a [=set=] of [=client platform=]-specific handles, where each
    [=set/item=] identifies an [=authenticator=] presently available on this [=client platform=] at that instant.

    Note: What qualifies an [=authenticator=] as "available" is intentionally unspecified; this is meant to represent how
    [=authenticators=] can be <a href="https://en.wikipedia.org/w/index.php?title=Hot_plug">hot-plugged</a> into (e.g., via USB)
    or discovered (e.g., via NFC or Bluetooth) by the [=client=] by various mechanisms, or permanently built into the [=client=].

1. Let |silentlyDiscoveredCredentials| be a new [=map=] whose [=map/entry|entries=] are of the form: [=DiscoverableCredentialMetadata=] → [=authenticator=].

1. Start |lifetimeTimer|.

1. [=While=] |lifetimeTimer| has not expired, perform the following actions depending upon |lifetimeTimer|,
    and the state and response [=set/for each=] |authenticator| in |authenticators|:

    <dl class="switch">

        :   If |lifetimeTimer| expires,
        ::  [=set/For each=] |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on
            |authenticator| and [=set/remove=] |authenticator| from |issuedRequests|.

        :   If the user exercises a user agent user-interface option to cancel the process,
        ::  [=set/For each=] |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on |authenticator|
            and [=set/remove=] |authenticator| from |issuedRequests|. Throw a "{{NotAllowedError}}" {{DOMException}}.

        :   If <code>|options|.{{CredentialRequestOptions/signal}}</code> is present and [=AbortSignal/aborted=],
        ::  [=set/For each=] |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation on |authenticator|
            and [=set/remove=] |authenticator| from |issuedRequests|. Then
            throw the <code>|options|.{{CredentialRequestOptions/signal}}</code>'s [=AbortSignal/abort reason=].

            <!-- this needs to be indented 2 more levels to get it to render properly -->
                <dt id="GetAssn-ConditionalMediation-Interact-FormControl">
                  If <code>|options|.{{CredentialRequestOptions/mediation}}</code> is {{CredentialMediationRequirement/conditional}}
                  and the user interacts with an <{input}> or <{textarea}> form control with an <{input/autocomplete}> attribute whose value
                  contains a `"webauthn"` [=autofill detail token=],
                </dt>

        ::  1. If |silentlyDiscoveredCredentials| is not [=list/empty=]:

                1. Prompt the user to optionally select a [=DiscoverableCredentialMetadata=] (|credentialMetadata|) from |silentlyDiscoveredCredentials|.

                    Note: The prompt shown SHOULD include values from |credentialMetadata|'s [=DiscoverableCredentialMetadata/otherUI=]
                    such as {{PublicKeyCredentialEntity/name}} and {{PublicKeyCredentialUserEntity/displayName}}.

                1. If the user selects a |credentialMetadata|,

                    1. Let |publicKeyOptions| be a temporary copy of |pkOptions|.

                    1. Let |authenticator| be the value of |silentlyDiscoveredCredentials|[|credentialMetadata|].

                    1. Set <code>|publicKeyOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code> to be a [=list=] containing a
                        single {{PublicKeyCredentialDescriptor}} [=list/item=] whose {{PublicKeyCredentialDescriptor/id}}'s value is set to
                        |credentialMetadata|'s [=DiscoverableCredentialMetadata/id=]'s value and whose{{PublicKeyCredentialDescriptor/id}}
                        value is set to |credentialMetadata|'s [=DiscoverableCredentialMetadata/type=].

                    1. Execute the [=issuing a credential request to an authenticator=] algorithm with |authenticator|, |savedCredentialIds|,
                        |publicKeyOptions|, |rpId|, |clientDataHash|, and |authenticatorExtensions|.

                        If this returns [FALSE], [=continue=].

                    1. [=set/Append=] |authenticator| to |issuedRequests|.

        :   If <code>|options|.{{CredentialRequestOptions/mediation}}</code> is not {{CredentialMediationRequirement/conditional}},
            |issuedRequests| is empty, <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code> is not empty,
            and no |authenticator| will become available for any [=public key credentials=] therein,
        ::  Indicate to the user that no eligible credential could be found. When the user acknowledges the dialog, throw a "{{NotAllowedError}}" {{DOMException}}.

            Note: One way a [=client platform=] can determine that no |authenticator| will become available is by examining the <code>{{PublicKeyCredentialDescriptor/transports}}</code> members of the present <code>{{PublicKeyCredentialDescriptor}}</code> [=list/items=] of <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code>, if any. For example, if all <code>{{PublicKeyCredentialDescriptor}}</code> [=list/items=] list only <code>{{AuthenticatorTransport/internal}}</code>, but all [=platform authenticator|platform=] |authenticator|s have been tried, then there is no possibility of satisfying the request. Alternatively, all <code>{{PublicKeyCredentialDescriptor}}</code> [=list/items=] may list <code>{{PublicKeyCredentialDescriptor/transports}}</code> that the [=client platform=] does not support.

        :   If an |authenticator| becomes available on this [=client device=],
        ::  Note:  This includes the case where an |authenticator| was available upon |lifetimeTimer| initiation.

            1. If <code>|options|.{{CredentialRequestOptions/mediation}}</code> is {{CredentialMediationRequirement/conditional}}
                and the |authenticator| supports the [=silentCredentialDiscovery=] operation:

                1. Let |collectedDiscoveredCredentialMetadata| be the result of invoking the [=silentCredentialDiscovery=] operation on |authenticator| with |rpId| as parameter.

                1. [=list/For each=] |credentialMetadata| of |collectedDiscoveredCredentialMetadata|:

                    1. If |credentialIdFilter| [=list/is empty=] or |credentialIdFilter| contains an item whose
                        {{PublicKeyCredentialDescriptor/id}}'s value is set to |credentialMetadata|'s [=DiscoverableCredentialMetadata/id=],
                        [=map/set=] |silentlyDiscoveredCredentials|[|credentialMetadata|] to |authenticator|.

                           Note: A request will be issued to this authenticator upon user selection of a credential via
                           interaction with a particular UI context
                           (see [here](#GetAssn-ConditionalMediation-Interact-FormControl) for details).

            1. Else:

                1. Execute the [=issuing a credential request to an authenticator=] algorithm with |authenticator|, |savedCredentialIds|,
                    |pkOptions|, |rpId|, |clientDataHash|, and |authenticatorExtensions|.

                    If this returns [FALSE], [=continue=].

                    Note: This branch is taken if <code>|options|.{{CredentialRequestOptions/mediation}}</code> is {{CredentialMediationRequirement/conditional}}
                    and the |authenticator| does not support the [=silentCredentialDiscovery=] operation to allow use of such authenticators during a
                    {{CredentialMediationRequirement/conditional}} [=user mediation=] request.

                1. [=set/Append=] |authenticator| to |issuedRequests|.

        :   If an |authenticator| ceases to be available on this [=client device=],
        ::  [=set/Remove=] |authenticator| from |issuedRequests|.

        :   If any |authenticator| returns a status indicating that the user cancelled the operation,
        ::  1. [=set/Remove=] |authenticator| from |issuedRequests|.
            1. [=set/For each=] remaining |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation
                on |authenticator| and [=set/remove=] it from |issuedRequests|.

                Note: [=Authenticators=] may return an indication of "the user cancelled the entire operation".
                How a user agent manifests this state to users is unspecified.

        :   If any |authenticator| returns an error status,
        ::  [=set/Remove=] |authenticator| from |issuedRequests|.

        :   If any |authenticator| indicates success,
        ::  1.  [=set/Remove=] |authenticator| from |issuedRequests|.

            1.  <span id="assertionCreationDataCreation"></span>
                Let <var ignore>assertionCreationData</var> be a [=struct=] whose [=items=] are:

                :   <code><dfn for="assertionCreationData">credentialIdResult</code>
                ::  If <code>|savedCredentialIds|[|authenticator|]</code> exists, set the value of [=credentialIdResult=] to be
                    the bytes of <code>|savedCredentialIds|[|authenticator|]</code>. Otherwise, set the value of
                    [=credentialIdResult=] to be the bytes of the [=credential ID=] returned from the successful
                    [=authenticatorGetAssertion=] operation, as defined in [[#sctn-op-get-assertion]].

                :   <code><dfn for="assertionCreationData">clientDataJSONResult</dfn></code>
                ::  whose value is the bytes of |clientDataJSON|.

                :   <code><dfn for="assertionCreationData">authenticatorDataResult</dfn></code>
                ::  whose value is the bytes of the [=authenticator data=] returned by the [=authenticator=].

                :   <code><dfn for="assertionCreationData">signatureResult</dfn></code>
                ::  whose value is the bytes of the signature value returned by the [=authenticator=].

                :   <code><dfn for="assertionCreationData">userHandleResult</dfn></code>
                ::  If the [=authenticator=] returned a [=user handle=], set the value of [=userHandleResult=] to be the bytes of
                    the returned [=user handle=]. Otherwise, set the value of [=userHandleResult=] to null.

                :   <code><dfn for="assertionCreationData">assertionAttestation</dfn></code>
                ::  If the [=authenticator=] returned an [=attestation=], set the value of [=assertionAttestation=] to be the bytes of
                    the [=attestation statement=]. Otherwise set it to null.

                :   <code><dfn for="assertionCreationData">clientExtensionResults</dfn></code>
                ::  whose value is an {{AuthenticationExtensionsClientOutputs}} object containing [=extension identifier=] →
                    [=client extension output=] entries. The entries are created by running each extension's
                    [=client extension processing=] algorithm to create the [=client extension outputs=], for each
                    [=client extension=] in <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/extensions}}</code>.

            1. If |credentialIdFilter| [=list/is not empty=] and |credentialIdFilter| does not contain an item whose
                {{PublicKeyCredentialDescriptor/id}}'s value is set to the value of [=credentialIdResult=], [=continue=].

            1.  Let |constructAssertionAlg| be an algorithm that takes a [=global object=]
                |global|, and whose steps are:

                1.  Let |pubKeyCred| be a new {{PublicKeyCredential}} object associated with |global| whose fields are:

                    :   {{PublicKeyCredential/[[identifier]]}}
                    ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                        <code>|assertionCreationData|.[=credentialIdResult=]</code>.

                    :   {{PublicKeyCredential/authenticatorAttachment}}
                    ::  The {{AuthenticatorAttachment}} value matching the current [=authenticator attachment modality=] of |authenticator|.

                    :   {{PublicKeyCredential/response}}
                    ::  A new {{AuthenticatorAssertionResponse}} object associated with |global| whose fields are:

                        :   {{AuthenticatorResponse/clientDataJSON}}
                        ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                            <code>|assertionCreationData|.[=assertionCreationData/clientDataJSONResult=]</code>.

                        :   {{AuthenticatorAssertionResponse/authenticatorData}}
                        ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                            <code>|assertionCreationData|.[=assertionCreationData/authenticatorDataResult=]</code>.

                        :   {{AuthenticatorAssertionResponse/signature}}
                        ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                            <code>|assertionCreationData|.[=assertionCreationData/signatureResult=]</code>.

                        :   {{AuthenticatorAssertionResponse/userHandle}}
                        ::  If <code>|assertionCreationData|.[=assertionCreationData/userHandleResult=]</code> is null, set this
                            field to null. Otherwise, set this field to a new {{ArrayBuffer}}, created using |global|'s
                            [=%ArrayBuffer%=], containing the bytes of
                            <code>|assertionCreationData|.[=assertionCreationData/userHandleResult=]</code>.

                        :   {{AuthenticatorAssertionResponse/attestationObject}}
                        ::  If <code>|assertionCreationData|.[=assertionCreationData/assertionAttestation=]</code> is null, set this
                            field to null. Otherwise, set this field to a new {{ArrayBuffer}}, created using |global|'s
                            [=%ArrayBuffer%=], containing the bytes of
                            <code>|assertionCreationData|.[=assertionCreationData/assertionAttestation=]</code>.

                    :   {{PublicKeyCredential/[[clientExtensionsResults]]}}
                    ::  A new {{ArrayBuffer}}, created using |global|'s [=%ArrayBuffer%=], containing the bytes of
                        <code>|assertionCreationData|.[=assertionCreationData/clientExtensionResults=]</code>.

                1.  Return |pubKeyCred|.

            1.  [=set/For each=] remaining |authenticator| in |issuedRequests| invoke the [=authenticatorCancel=] operation
                on |authenticator| and [=set/remove=] it from |issuedRequests|.

            1.  Return |constructAssertionAlg| and terminate this algorithm.
    </dl>

1. Throw a "{{NotAllowedError}}" {{DOMException}}. In order to prevent information leak that could identify the
    user without [=user consent|consent=], this step MUST NOT be executed before |lifetimeTimer| has expired. See
    [[#sctn-assertion-privacy]] for details.

</div>

#### <dfn for="PublicKeyCredential" algorithm="Issuing a credential request to an authenticator">Issuing a Credential Request to an Authenticator</dfn> #### {#sctn-issuing-cred-request-to-authenticator}

This sub-algorithm of {{PublicKeyCredential/[[DiscoverFromExternalSource]]()}} encompasses the specific UI context-independent
steps necessary for requesting a [=credential=] from a given [=authenticator=], using given {{PublicKeyCredentialRequestOptions}}.
It is called by {{PublicKeyCredential/[[DiscoverFromExternalSource]]()}} from various points depending on which [=user mediation=]
the present [=authentication ceremony=] is subject to (e.g.: {{CredentialMediationRequirement/conditional}} mediation).

This algorithm accepts the following arguments:

<dl dfn-type="argument" dfn-for="Issuing a credential request to an authenticator">
    :   <dfn>authenticator</dfn>
    ::  A [=client platform=]-specific handle identifying an [=authenticator=] presently available on this [=client platform=].

    :   <dfn>savedCredentialIds</dfn>
    ::  A [=map=] containing [=authenticator=] → [=credential ID=]. This argument will be modified in this algorithm.

    :   <dfn>pkOptions</dfn>
    ::  This argument is a {{PublicKeyCredentialRequestOptions}} object specifying the desired attributes of the
        [=public key credential=] to discover.

    :   <dfn>rpId</dfn>
    ::  The request [=RP ID=].

    :   <dfn>clientDataHash</dfn>
    ::  The [=hash of the serialized client data=] represented by |clientDataJSON|.

    :   <dfn>authenticatorExtensions</dfn>
    ::  A [=map=] containing [=extension identifiers=] to the [=base64url encoding=] of the [=client extension processing=]
        output for [=authenticator extensions=].
</dl>

This algorithm returns [FALSE] if the [=client=] determines that the |authenticator| is not capable of handling the request, or [TRUE] if
the request was issued successfully.

The steps for [=issuing a credential request to an authenticator=] are as follows:

    1. If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/userVerification}}</code> is set to
        {{UserVerificationRequirement/required}} and the |authenticator| is not capable of performing [=user verification=],
        return [FALSE].

    1. Let |userVerification| be the <dfn>effective user verification requirement for assertion</dfn>, a Boolean value, as
        follows. If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/userVerification}}</code>

            <dl class="switch">

                :   is set to {{UserVerificationRequirement/required}}
                ::  Let |userVerification| be [TRUE].

                :   is set to {{UserVerificationRequirement/preferred}}
                ::  If the |authenticator|

                    <dl class="switch">
                        :   is capable of [=user verification=]
                        ::  Let |userVerification| be [TRUE].

                        :   is not capable of [=user verification=]
                        ::  Let |userVerification| be [FALSE].
                    </dl>

                :   is set to {{UserVerificationRequirement/discouraged}}
                ::  Let |userVerification| be [FALSE].

            </dl>

    1. Let |enterpriseAttestationPossible| be a Boolean value, as follows. If
        <code>|options|.{{PublicKeyCredentialRequestOptions/attestation}}</code>

            <dl class="switch">

                :   is set to {{AttestationConveyancePreference/enterprise}}
                ::  Let |enterpriseAttestationPossible| be [TRUE] if the user agent wishes to support enterprise attestation for |rpId| (see [Step 7](#GetAssn-DetermineRpId) of [[#sctn-discover-from-external-source]]). Otherwise [FALSE].

                :   otherwise
                ::  Let |enterpriseAttestationPossible| be [FALSE].

            </dl>

    1. Let |attestationFormats| be a list of strings, initialized to the value of <code>|options|.{{PublicKeyCredentialRequestOptions/attestationFormats}}</code>.

    1. If <code>|options|.{{PublicKeyCredentialRequestOptions/attestation}}</code>

            <dl class="switch">

                :   is set to {{AttestationConveyancePreference/none}}
                ::  Set |attestationFormats| be the single-element list containing the string &ldquo;none&rdquo;

            </dl>

    1. <span id="allowCredentialDescriptorListCreation"></span>
        If <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code>
        <dl class="switch">
            :   [=list/is not empty=]
            ::  1. Let |allowCredentialDescriptorList| be a new [=list=].

                1. Execute a [=client platform=]-specific procedure to determine which, if any, [=public key credentials=] described by
                    <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code> are [=bound credential|bound=] to this
                    |authenticator|, by matching with |rpId|,
                    <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}.{{PublicKeyCredentialDescriptor/id}}</code>,
                    and <code>|pkOptions|.{{PublicKeyCredentialRequestOptions/allowCredentials}}.{{PublicKeyCredentialDescriptor/type}}</code>.
                    Set |allowCredentialDescriptorList| to this filtered list.

                1. If |allowCredentialDescriptorList| [=list/is empty=], return [FALSE].

                1. Let |distinctTransports| be a new [=ordered set=].

                1. If |allowCredentialDescriptorList| has exactly one value, set
                    <code>|savedCredentialIds|[|authenticator|]</code> to <code>|allowCredentialDescriptorList|[0].id</code>'s
                    value (see [here](#authenticatorGetAssertion-return-values) in [[#sctn-op-get-assertion]] for more information).

                1. [=list/For each=] credential descriptor |C| in |allowCredentialDescriptorList|,
                    [=set/append=] each value, if any, of <code>|C|.{{PublicKeyCredentialDescriptor/transports}}</code> to |distinctTransports|.

                    Note: This will aggregate only distinct values of {{PublicKeyCredentialDescriptor/transports}} (for this [=authenticator=]) in
                        |distinctTransports| due to the properties of [=ordered sets=].

                1. If |distinctTransports|
                    <dl class="switch">
                        :   [=list/is not empty=]
                        ::  The client selects one |transport| value from |distinctTransports|, possibly incorporating local
                            configuration knowledge of the appropriate transport to use with |authenticator| in making its
                            selection.

                            Then, using |transport|, invoke the [=authenticatorGetAssertion=] operation on
                            |authenticator|, with |rpId|, |clientDataHash|, |allowCredentialDescriptorList|,
                            |userVerification|,
                            |enterpriseAttestationPossible|,
                            |attestationFormats|,
                            and |authenticatorExtensions| as parameters.

                        :   [=list/is empty=]
                        ::  Using local configuration knowledge of the appropriate transport to use with |authenticator|,
                            invoke the [=authenticatorGetAssertion=] operation on |authenticator| with |rpId|,
                            |clientDataHash|, |allowCredentialDescriptorList|, |userVerification|,
                            |enterpriseAttestationPossible|, |attestationFormats|, and |authenticatorExtensions| as parameters.
                    </dl>

            :   [=list/is empty=]
            ::  Using local configuration knowledge of the appropriate transport to use with |authenticator|, invoke the
                [=authenticatorGetAssertion=] operation on |authenticator| with |rpId|, |clientDataHash|,
                |userVerification|,
                |enterpriseAttestationPossible|,
                |attestationFormats|,
                and |authenticatorExtensions| as parameters.

                Note: In this case, the [=[RP]=] did not supply a list of acceptable credential descriptors. Thus, the
                    authenticator is being asked to exercise any credential it may possess that is [=scoped=] to
                    the [=[RP]=], as identified by |rpId|.
        </dl>

    1. Return [TRUE].


### Store an Existing Credential - PublicKeyCredential's `[[Store]](credential, sameOriginWithAncestors)` Method ### {#sctn-storeCredential}

<div link-for-hint="PublicKeyCredential/[[Store]](credential, sameOriginWithAncestors)">

The <dfn for="PublicKeyCredential" method>\[[Store]](credential, sameOriginWithAncestors)</dfn> method is not supported
for Web Authentication's {{PublicKeyCredential}} type, so it always throws an error.

Note: This algorithm is synchronous; the {{Promise}} resolution/rejection is handled by
{{CredentialsContainer/store()|navigator.credentials.store()}}.

This [=internal method=] accepts two arguments:

<dl dfn-type="argument" dfn-for="PublicKeyCredential/[[Store]](credential, sameOriginWithAncestors)">
    :   <dfn>credential</dfn>
    ::  This argument is a {{PublicKeyCredential}} object.

    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the caller's [=environment settings object=] is
        [=same-origin with its ancestors=].
</dl>

When this method is invoked, the user agent MUST execute the following algorithm:

1. Throw a "{{NotSupportedError}}" {{DOMException}}.

</div>

###  Preventing Silent Access to an Existing Credential - PublicKeyCredential's `[[preventSilentAccess]](credential, sameOriginWithAncestors)` Method ### {#sctn-preventSilentAccessCredential}

<div link-for-hint="PublicKeyCredential/[[preventSilentAccess]](credential, sameOriginWithAncestors)">

Calling the <dfn for="PublicKeyCredential" method>\[[preventSilentAccess]](credential, sameOriginWithAncestors)</dfn> method
will have no effect on authenticators that require an [=authorization gesture=],
but setting that flag may potentially exclude authenticators that can operate without user intervention.

This [=internal method=] accepts no arguments.

</div>

### Availability of [=User-Verifying Platform Authenticator=] - PublicKeyCredential's `isUserVerifyingPlatformAuthenticatorAvailable()` Method ### {#sctn-isUserVerifyingPlatformAuthenticatorAvailable}

<div link-for-hint="WebAuthentication/isUserVerifyingPlatformAuthenticatorAvailable">

[=[WRPS]=] use this method to determine whether they can create a new credential using a [=user-verifying platform authenticator=].
Upon invocation, the [=client=] employs a [=client platform=]-specific procedure to discover available [=user-verifying platform authenticators=].
If any are discovered, the promise is resolved with the value of [TRUE].
Otherwise, the promise is resolved with the value of [FALSE].
Based on the result, the [=[RP]=] can take further actions to guide the user to create a credential.

This method has no arguments and returns a Boolean value.

<xmp class="idl">
    partial interface PublicKeyCredential {
        static Promise<boolean> isUserVerifyingPlatformAuthenticatorAvailable();
    };
</xmp>

Note: Invoking this method from a [=browsing context=] where the [=Web Authentication API=] is "disabled" according to the [=allowed to use=] algorithm&mdash;i.e., by a [=permissions policy=]&mdash;will result in the promise being rejected with a {{DOMException}} whose name is "{{NotAllowedError}}". See also [[#sctn-permissions-policy]].

</div>

### Deserialize Registration ceremony options - PublicKeyCredential's `parseCreationOptionsFromJSON()` Method ### {#sctn-parseCreationOptionsFromJSON}

<div link-for-hint="WebAuthentication/parseCreationOptionsFromJSON">

[=[WRPS]=] use this method to convert [=JSON type=] representations of options for
{{CredentialsContainer/create()|navigator.credentials.create()}} into
{{PublicKeyCredentialCreationOptions}}.

Upon invocation, the [=client=] MUST convert the
{{PublicKeyCredential/parseCreationOptionsFromJSON(options)/options}} argument into a new,
identically-structured {{PublicKeyCredentialCreationOptions}} object, using [=base64url encoding=]
to decode any {{DOMString}} attributes in {{PublicKeyCredentialCreationOptionsJSON}} that correspond
to [=buffer source type=] attributes in {{PublicKeyCredentialCreationOptions}}. This conversion MUST
also apply to any [=client extension inputs=] processed by the [=client=].

{{AuthenticationExtensionsClientInputsJSON}} MAY include extensions registered in the IANA
"WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] but not defined in
[[#sctn-extensions]].

If the [=client=] encounters any issues parsing any of the [=JSON type=] representations then it
MUST throw an "{{EncodingError}}" {{DOMException}} with a description of the incompatible
value and terminate the operation.

<xmp class="idl">
    partial interface PublicKeyCredential {
        static PublicKeyCredentialCreationOptions parseCreationOptionsFromJSON(PublicKeyCredentialCreationOptionsJSON options);
    };

    dictionary PublicKeyCredentialCreationOptionsJSON {
        required PublicKeyCredentialRpEntity                    rp;
        required PublicKeyCredentialUserEntityJSON              user;
        required Base64URLString                                challenge;
        required sequence<PublicKeyCredentialParameters>        pubKeyCredParams;
        unsigned long                                           timeout;
        sequence<PublicKeyCredentialDescriptorJSON>             excludeCredentials = [];
        AuthenticatorSelectionCriteria                          authenticatorSelection;
        DOMString                                               attestation = "none";
        AuthenticationExtensionsClientInputsJSON                extensions;
    };

    dictionary PublicKeyCredentialUserEntityJSON {
        required Base64URLString        id;
        required DOMString              name;
        required DOMString              displayName;
    };

    dictionary PublicKeyCredentialDescriptorJSON {
        required Base64URLString        id;
        required DOMString              type;
        sequence<DOMString>             transports;
    };

    dictionary AuthenticationExtensionsClientInputsJSON {
    };
</xmp>

</div>

### Deserialize Authentication ceremony options - PublicKeyCredential's `parseRequestOptionsFromJSON()` Methods ### {#sctn-parseRequestOptionsFromJSON}

<div link-for-hint="WebAuthentication/parseRequestOptionsFromJSON">

[=[WRPS]=] use this method to convert [=JSON type=] representations of options for
{{CredentialsContainer/get()|navigator.credentials.get()}} into
{{PublicKeyCredentialRequestOptions}}.

Upon invocation, the [=client=] MUST convert the
{{PublicKeyCredential/parseRequestOptionsFromJSON(options)/options}} argument into a new,
identically-structured {{PublicKeyCredentialRequestOptions}} object, using [=base64url encoding=]
to decode any {{DOMString}} attributes in {{PublicKeyCredentialRequestOptionsJSON}} that correspond
to [=buffer source type=] attributes in {{PublicKeyCredentialRequestOptions}}. This conversion MUST
also apply to any [=client extension inputs=] processed by the [=client=].

{{AuthenticationExtensionsClientInputsJSON}} MAY include extensions registered in the IANA
"WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] but not defined in
[[#sctn-extensions]].

If the [=client=] encounters any issues parsing any of the [=JSON type=] representations then it
MUST throw an "{{EncodingError}}" {{DOMException}} with a description of the incompatible
value and terminate the operation.

<xmp class="idl">
    partial interface PublicKeyCredential {
        static PublicKeyCredentialRequestOptions parseRequestOptionsFromJSON(PublicKeyCredentialRequestOptionsJSON options);
    };

    dictionary PublicKeyCredentialRequestOptionsJSON {
        required Base64URLString                                challenge;
        unsigned long                                           timeout;
        DOMString                                               rpId;
        sequence<PublicKeyCredentialDescriptorJSON>             allowCredentials = [];
        DOMString                                               userVerification = "preferred";
        AuthenticationExtensionsClientInputsJSON                extensions;
    };
</xmp>

</div>

## Authenticator Responses (interface <dfn interface>AuthenticatorResponse</dfn>) ## {#iface-authenticatorresponse}

[=Authenticators=] respond to [=[RP]=] requests by returning an object derived from the
{{AuthenticatorResponse}} interface:

<xmp class="idl">
    [SecureContext, Exposed=Window]
    interface AuthenticatorResponse {
        [SameObject] readonly attribute ArrayBuffer      clientDataJSON;
    };
</xmp>
<div dfn-type="attribute" dfn-for="AuthenticatorResponse">
    :   <dfn>clientDataJSON</dfn>
    ::  This attribute contains a [[#clientdatajson-serialization|JSON-compatible serialization]] of the [=client data=], the [=hash of the serialized client data|hash of which=] is passed to the
        authenticator by the client in its call to either {{CredentialsContainer/create()}} or {{CredentialsContainer/get()}} (i.e., the
        [=client data=] itself is not sent to the authenticator).
</div>

### Information About Public Key Credential (interface <dfn interface>AuthenticatorAttestationResponse</dfn>) ### {#iface-authenticatorattestationresponse}

The {{AuthenticatorAttestationResponse}} interface represents the [=authenticator=]'s response to a client's request
for the creation of a new [=public key credential=]. It contains information about the new credential that can be used to
identify it for later use, and metadata that can be used by the [=[WRP]=] to assess the characteristics of the credential
during registration.

<xmp class="idl">
    [SecureContext, Exposed=Window]
    interface AuthenticatorAttestationResponse : AuthenticatorResponse {
        [SameObject] readonly attribute ArrayBuffer      attestationObject;
        sequence<DOMString>                              getTransports();
        ArrayBuffer                                      getAuthenticatorData();
        ArrayBuffer?                                     getPublicKey();
        COSEAlgorithmIdentifier                          getPublicKeyAlgorithm();
    };
</xmp>
<div dfn-type="attribute" dfn-for="AuthenticatorAttestationResponse">
    :   {{AuthenticatorResponse/clientDataJSON}}
    ::  This attribute, inherited from {{AuthenticatorResponse}}, contains the [=JSON-compatible serialization of client data=] (see
        [[#sctn-attestation]]) passed to the authenticator by the client in order to generate this credential. The
        exact JSON serialization MUST be preserved, as the [=hash of the serialized client data=] has been computed
        over it.

    :   <dfn>attestationObject</dfn>
    ::  This attribute contains an [=attestation object=], which is opaque to, and cryptographically protected against
        tampering by, the client. The [=attestation object=] contains both [=authenticator data=] and an [=attestation
        statement=]. The former contains the AAGUID, a unique [=credential ID=], and the [=credential public key=]. The
        contents of the [=attestation statement=] are determined by the [=attestation statement format=] used by the
        [=authenticator=]. It also contains any additional information that the [=[RP]=]'s server requires to validate the
        [=attestation statement=], as well as to decode and validate the [=authenticator data=] along with the
        [=JSON-compatible serialization of client data=]. For more details, see [[#sctn-attestation]], [[#sctn-generating-an-attestation-object]],
        and [Figure 6](#fig-attStructs).

    :   {{AuthenticatorAttestationResponse/getTransports()}}
    ::  This operation returns the value of {{AuthenticatorAttestationResponse/[[transports]]}}.

    :   {{AuthenticatorAttestationResponse/getAuthenticatorData()}}
    ::  This operation returns the [=authenticator data=] contained within {{AuthenticatorAttestationResponse/attestationObject}}. See [[#sctn-public-key-easy]].

    :   {{AuthenticatorAttestationResponse/getPublicKey()}}
    ::  This operation returns the DER [=SubjectPublicKeyInfo=] of the new credential, or null if this is not available. See [[#sctn-public-key-easy]].

    :   {{AuthenticatorAttestationResponse/getPublicKeyAlgorithm()}}
    ::  This operation returns the {{COSEAlgorithmIdentifier}} of the new credential. See [[#sctn-public-key-easy]].

    :   <dfn>\[[transports]]</dfn>
    ::  This [=internal slot=] contains a sequence of zero or more unique {{DOMString}}s in lexicographical order. These values are the transports that the [=authenticator=] is believed to support, or an empty sequence if the information is unavailable. The values SHOULD be members of {{AuthenticatorTransport}} but [=[RPS]=] SHOULD accept and store unknown values.
</div>

#### Easily accessing credential data #### {#sctn-public-key-easy}

Every user of the {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}} method will need to parse and store the returned [=credential public key=] in order to verify future [=authentication assertions=]. However, the [=credential public key=] is in COSE format [[!RFC9052]], inside the [=credentialPublicKey=] member of the [=attestedCredentialData=], inside the [=authenticator data=], inside the [=attestation object=] conveyed by {{AuthenticatorAttestationResponse}}.{{AuthenticatorAttestationResponse/attestationObject}}. [=[RPS]=] wishing to use [=attestation=] are obliged to do the work of parsing the {{AuthenticatorAttestationResponse/attestationObject}} and obtaining the [=credential public key=] because that public key copy is the one the [=authenticator=] [signed](#signing-procedure). However, many valid WebAuthn use cases do not require [=attestation=]. For those uses, user agents can do the work of parsing, expose the [=authenticator data=] directly, and translate the [=credential public key=] into a more convenient format.

The {{AuthenticatorAttestationResponse/getPublicKey()}} operation thus returns the [=credential public key=] as a [=SubjectPublicKeyInfo=]. This {{ArrayBuffer}} can, for example, be passed to Java's `java.security.spec.X509EncodedKeySpec`, .NET's `System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo`, or Go's `crypto/x509.ParsePKIXPublicKey`.

Use of {{AuthenticatorAttestationResponse/getPublicKey()}} does impose some limitations: by using {{PublicKeyCredentialCreationOptions/pubKeyCredParams}}, a [=[RP]=] can negotiate with the [=authenticator=] to use public key algorithms that the user agent may not understand. However, if the [=[RP]=] does so, the user agent will not be able to translate the resulting [=credential public key=] into [=SubjectPublicKeyInfo=] format and the return value of {{AuthenticatorAttestationResponse/getPublicKey()}} will be null.

User agents MUST be able to return a non-null value for {{AuthenticatorAttestationResponse/getPublicKey()}} when the [=credential public key=] has a {{COSEAlgorithmIdentifier}} value of:
   * -7 (ES256), where [=kty=] is 2 (with uncompressed points) and [=crv=] is 1 (P-256).
   * -257 (RS256).
   * -8 (EdDSA), where [=crv=] is 6 (Ed25519).

A [=SubjectPublicKeyInfo=] does not include information about the signing algorithm (for example, which hash function to use) that is included in the COSE public key. To provide this, {{AuthenticatorAttestationResponse/getPublicKeyAlgorithm()}} returns the {{COSEAlgorithmIdentifier}} for the [=credential public key=].

To remove the need to parse CBOR at all in many cases, {{AuthenticatorAttestationResponse/getAuthenticatorData()}} returns the [=authenticator data=] from {{AuthenticatorAttestationResponse/attestationObject}}. The [=authenticator data=] contains other fields that are encoded in a binary format. However, helper functions are not provided to access them because [=[RPS]=] already need to extract those fields when [getting an assertion](#sctn-getAssertion). In contrast to [credential creation](#sctn-createCredential), where signature verification is [optional](#enumdef-attestationconveyancepreference), [=[RPS]=] should always be verifying signatures from an assertion and thus must extract fields from the signed [=authenticator data=]. The same functions used there will also serve during credential creation.

Note: {{AuthenticatorAttestationResponse/getPublicKey()}} and {{AuthenticatorAttestationResponse/getAuthenticatorData()}} were only added in level two of this spec. [=[RPS]=] SHOULD use feature detection before using these functions by testing the value of `'getPublicKey' in AuthenticatorAttestationResponse.prototype`. [=[RPS]=] that require this function to exist may not interoperate with older user-agents.

### Web Authentication Assertion (interface <dfn interface>AuthenticatorAssertionResponse</dfn>) ### {#iface-authenticatorassertionresponse}

The {{AuthenticatorAssertionResponse}} interface represents an [=authenticator=]'s response to a client's request for
generation of a new [=authentication assertion=] given the [=[WRP]=]'s challenge and OPTIONAL list of credentials it is
aware of. This response contains a cryptographic signature proving possession of the [=credential private key=], and
optionally evidence of [=user consent=] to a specific transaction.

<xmp class="idl">
    [SecureContext, Exposed=Window]
    interface AuthenticatorAssertionResponse : AuthenticatorResponse {
        [SameObject] readonly attribute ArrayBuffer      authenticatorData;
        [SameObject] readonly attribute ArrayBuffer      signature;
        [SameObject] readonly attribute ArrayBuffer?     userHandle;
        [SameObject] readonly attribute ArrayBuffer?     attestationObject;
    };
</xmp>
<div dfn-type="attribute" dfn-for="AuthenticatorAssertionResponse">
    :   {{AuthenticatorResponse/clientDataJSON}}
    ::  This attribute, inherited from {{AuthenticatorResponse}}, contains the [=JSON-compatible serialization of client data=] (see
        [[#dictionary-client-data]]) passed to the authenticator by the client in order to generate this assertion. The
        exact JSON serialization MUST be preserved, as the [=hash of the serialized client data=] has been computed
        over it.

    :   <dfn>authenticatorData</dfn>
    ::  This attribute contains the [=authenticator data=] returned by the authenticator. See [[#sctn-authenticator-data]].

    :   <dfn>signature</dfn>
    ::  This attribute contains the raw signature returned from the authenticator. See [[#sctn-op-get-assertion]].

    :   <dfn>userHandle</dfn>
    ::  This attribute contains the [=user handle=] returned from the authenticator, or null if the authenticator did not return a
        [=user handle=]. See [[#sctn-op-get-assertion]].

    :   <dfn>attestationObject</dfn>
    ::  This OPTIONAL attribute contains an [=attestation object=], if the [=authenticator=] supports attestation in assertions. The [=attestation object=], if present, includes an [=attestation statement=]. Unlike the {{AuthenticatorAttestationResponse/attestationObject}} in an {{AuthenticatorAttestationResponse}}, it does not contain an `authData` key because the [=authenticator data=] is provided directly in an {{AuthenticatorAssertionResponse}} structure. For more details on attestation, see [[#sctn-attestation]], [[#sctn-attestation-in-assertions]], [[#sctn-generating-an-attestation-object]], and [Figure 6](#fig-attStructs).
</div>

## Parameters for Credential Generation (dictionary <dfn dictionary>PublicKeyCredentialParameters</dfn>) ## {#dictionary-credential-params}

<xmp class="idl">
    dictionary PublicKeyCredentialParameters {
        required DOMString                    type;
        required COSEAlgorithmIdentifier      alg;
    };
</xmp>

<div dfn-type="dict-member" dfn-for="PublicKeyCredentialParameters">
    This dictionary is used to supply additional parameters when creating a new credential.

    :   <dfn>type</dfn>
    ::  This member specifies the type of credential to be created. The value SHOULD be a member of {{PublicKeyCredentialType}} but [=client platforms=] MUST ignore unknown values, ignoring any {{PublicKeyCredentialParameters}} with an unknown {{PublicKeyCredentialParameters/type}}.

    :   <dfn>alg</dfn>
    ::  This member specifies the cryptographic signature algorithm with which the newly generated credential will be used, and
        thus also the type of asymmetric key pair to be generated, e.g., RSA or Elliptic Curve.

    Note: we use "alg" as the latter member name, rather than spelling-out "algorithm", because it will be serialized into
        a message to the authenticator, which may be sent over a low-bandwidth link.
</div>

## Options for Credential Creation (dictionary <dfn dictionary>PublicKeyCredentialCreationOptions</dfn>) ## {#dictionary-makecredentialoptions}

<xmp class="idl">
    dictionary PublicKeyCredentialCreationOptions {
        required PublicKeyCredentialRpEntity         rp;
        required PublicKeyCredentialUserEntity       user;

        required BufferSource                             challenge;
        required sequence<PublicKeyCredentialParameters>  pubKeyCredParams;

        unsigned long                                timeout;
        sequence<PublicKeyCredentialDescriptor>      excludeCredentials = [];
        AuthenticatorSelectionCriteria               authenticatorSelection;
        DOMString                                    attestation = "none";
        sequence<DOMString>                          attestationFormats = [];
        AuthenticationExtensionsClientInputs         extensions;
    };
</xmp>
<div dfn-type="dict-member" dfn-for="PublicKeyCredentialCreationOptions">
    :   <dfn>rp</dfn>
    ::  This member contains a name and an identifier for the [=[RP]=] responsible for the request.

        Its value's {{PublicKeyCredentialEntity/name}} member is REQUIRED. See [[#dictionary-pkcredentialentity]] for further
        details.

        Its value's {{PublicKeyCredentialRpEntity/id}} member specifies the [=RP ID=] the credential
        should be [=scoped=] to. If omitted, its value will be the {{CredentialsContainer}} object's [=relevant
        settings object=]'s [=environment settings object/origin=]'s [=effective domain=]. See [[#dictionary-rp-credential-params]]
        for further details.

    :   <dfn>user</dfn>
    ::  This member contains names and an identifier for the [=user account=] performing the [=registration=].

        Its value's {{PublicKeyCredentialEntity/name}}, {{PublicKeyCredentialUserEntity/displayName}} and
        {{PublicKeyCredentialUserEntity/id}} members are REQUIRED.
        {{PublicKeyCredentialUserEntity/id}} can be returned as the {{AuthenticatorAssertionResponse/userHandle}}
        in some future [=authentication ceremonies=],
        and is used to overwrite existing [=discoverable credentials=]
        that have the same <code>{{PublicKeyCredentialCreationOptions/rp}}.{{PublicKeyCredentialRpEntity/id}}</code> and <code>{{PublicKeyCredentialCreationOptions/user}}.{{PublicKeyCredentialUserEntity/id}}</code>
        on the same [=authenticator=].
        {{PublicKeyCredentialEntity/name}} and {{PublicKeyCredentialUserEntity/displayName}}
        MAY be used by the [=authenticator=] and [=client=] in future [=authentication ceremonies=]
        to help the user select a [=credential=], but are not returned to the [=[RP]=] as a result of future [=authentication ceremonies=]

        For further details, see [[#dictionary-pkcredentialentity]] and [[#dictionary-user-credential-params]].

    :   <dfn>challenge</dfn>
    ::  This member specifies a challenge that the [=authenticator=] signs, along with other data,
        when producing an [=attestation object=] for the newly created credential.
        See the [[#sctn-cryptographic-challenges]] security consideration.

    :   <dfn>pubKeyCredParams</dfn>
    ::  This member lists the key types and signature algorithms the [=[RP]=] supports,
        ordered from most preferred to least preferred.
        The [=client=] and [=authenticator=] make a best-effort to create a credential of the most preferred type possible.
        If none of the listed types can be created, the {{CredentialsContainer/create()}} operation fails.

    :   <dfn>timeout</dfn>
    ::  This OPTIONAL member specifies a time, in milliseconds, that the [=[RP]=] is willing to wait for the call to complete. This is
        treated as a hint, and MAY be overridden by the [=client=].

    :   <dfn>excludeCredentials</dfn>
    ::  The [=[RP]=] SHOULD use this OPTIONAL member to list any existing [=credentials=] mapped to this [=user account=]
        (as identified by {{PublicKeyCredentialCreationOptions/user}}.{{PublicKeyCredentialUserEntity/id}}).
        This ensures that the new credential is not [=created on=] an [=authenticator=]
        that already [=contains=] a credential mapped to this [=user account=].
        If it would be, the [=client=] is requested to instead guide the user to use a different [=authenticator=],
        or return an error if that fails.

    :   <dfn>authenticatorSelection</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to specify capabilities and settings
        that the [=authenticator=] MUST or SHOULD satisfy to participate in the {{CredentialsContainer/create()}} operation.
        See [[#dictionary-authenticatorSelection]].

    :   <dfn>attestation</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to specify a preference regarding [=attestation conveyance=].
        Its value SHOULD be a member of {{AttestationConveyancePreference}}.
        [=Client platforms=] MUST ignore unknown values, treating an unknown value as if the [=map/exist|member does not exist=].

        The default value is {{AttestationConveyancePreference/none}}.

    :   <dfn>attestationFormats</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to specify a preference regarding the [=attestation=] statement format used by the [=authenticator=].
        Values SHOULD be taken from the IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].
        Values are ordered from most preferable to least preferable.
        This parameter is advisory and the [=authenticator=] MAY use an attestation statement not enumerated in this parameter.

        The default value is the empty list, which indicates no preference.

    :   <dfn>extensions</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to provide [=client extension inputs=]
        requesting additional processing by the [=client=] and [=authenticator=].
        For example, the [=[RP]=] may request that the client returns additional information about the [=credential=] that was created.

        The extensions framework is defined in [[#sctn-extensions]].
        Some extensions are defined in [[#sctn-defined-extensions]];
        consult the IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]] for an up-to-date list
        of registered [=WebAuthn Extensions=].
</div>

### Public Key Entity Description (dictionary <dfn dictionary>PublicKeyCredentialEntity</dfn>) ### {#dictionary-pkcredentialentity}

The {{PublicKeyCredentialEntity}} dictionary describes a [=user account=], or a [=[WRP]=], which a [=public key credential=] is
associated with or [=scoped=] to, respectively.

<xmp class="idl">
    dictionary PublicKeyCredentialEntity {
        required DOMString    name;
    };
</xmp>
<div dfn-type="dict-member" dfn-for="PublicKeyCredentialEntity">
    :   <dfn>name</dfn>
    ::  A [=human palatability|human-palatable=] name for the entity. Its function depends on what the {{PublicKeyCredentialEntity}} represents:

          - When inherited by {{PublicKeyCredentialRpEntity}} it is a [=human palatability|human-palatable=] identifier for the [=[RP]=], intended only
            for display. For example, "ACME Corporation", "Wonderful Widgets, Inc." or "ОАО Примертех".

              - [=[RPS]=] SHOULD perform enforcement, as prescribed in Section 2.3 of
                [[!RFC8266]] for the Nickname Profile of the PRECIS FreeformClass [[!RFC8264]],
                when setting {{PublicKeyCredentialEntity/name}}'s value, or displaying the value to the user.

              - This string MAY contain language and direction metadata. [=[RPS]=] SHOULD consider providing this information. See [[#sctn-strings-langdir]] about how this metadata is encoded.

              - [=Clients=] SHOULD perform enforcement, as prescribed in Section 2.3 of
                [[!RFC8266]] for the Nickname Profile of the PRECIS FreeformClass [[!RFC8264]],
                on {{PublicKeyCredentialEntity/name}}'s value prior to displaying the value to the user or
                including the value as a parameter of the [=authenticatorMakeCredential=] operation.

          - When inherited by {{PublicKeyCredentialUserEntity}}, it is a [=human palatability|human-palatable=] identifier for a
            [=user account=]. It is intended only for display, i.e., aiding the user in determining the difference between user
            accounts with similar {{PublicKeyCredentialUserEntity/displayName}}s. For example, "alexm", "alex.mueller@example.com"
            or "+14255551234".

              - The [=[RP]=] MAY let the user choose this value. The [=[RP]=] SHOULD perform enforcement,
                as prescribed in Section 3.4.3 of [[!RFC8265]] for the UsernameCasePreserved Profile of the PRECIS
                IdentifierClass [[!RFC8264]], when setting {{PublicKeyCredentialEntity/name}}'s value, or displaying the value
                to the user.

              - This string MAY contain language and direction metadata. [=[RPS]=] SHOULD consider providing this information. See [[#sctn-strings-langdir]] about how this metadata is encoded.

              - [=Clients=] SHOULD perform enforcement, as prescribed in Section 3.4.3 of [[!RFC8265]]
                for the UsernameCasePreserved Profile of the PRECIS IdentifierClass [[!RFC8264]],
                on {{PublicKeyCredentialEntity/name}}'s value prior to displaying the value to the user or
                including the value as a parameter of the [=authenticatorMakeCredential=] operation.


        When [=clients=], [=client platforms=], or [=authenticators=] display a {{PublicKeyCredentialEntity/name}}'s value, they should always use UI elements to provide a clear boundary around the displayed value, and not allow overflow into other elements [[css-overflow-3]].

        Authenticators MAY truncate a {{PublicKeyCredentialEntity/name}} member's value so that it fits within 64 bytes, if the authenticator stores the value. See [[#sctn-strings-truncation]] about truncation and other considerations.
</div>


### Relying Party Parameters for Credential Generation (dictionary <dfn dictionary>PublicKeyCredentialRpEntity</dfn>) ### {#dictionary-rp-credential-params}

The {{PublicKeyCredentialRpEntity}} dictionary is used to supply additional [=[RP]=] attributes when creating a new credential.

<xmp class="idl">
    dictionary PublicKeyCredentialRpEntity : PublicKeyCredentialEntity {
        DOMString      id;
    };
</xmp>

<div dfn-type="dict-member" dfn-for="PublicKeyCredentialRpEntity">
    :   <dfn>id</dfn>
    ::  A unique identifier for the [=[RP]=] entity, which sets the [=RP ID=].
</div>


### User Account Parameters for Credential Generation (dictionary <dfn dictionary>PublicKeyCredentialUserEntity</dfn>) ### {#dictionary-user-credential-params}

The {{PublicKeyCredentialUserEntity}} dictionary is used to supply additional [=user account=] attributes when creating a new
credential.

<xmp class="idl">
    dictionary PublicKeyCredentialUserEntity : PublicKeyCredentialEntity {
        required BufferSource   id;
        required DOMString      displayName;
    };
</xmp>

<div dfn-type="dict-member" dfn-for="PublicKeyCredentialUserEntity">
    :   <dfn>id</dfn>
    ::  The [=user handle=] of the [=user account=].
        A [=user handle=] is an opaque [=byte sequence=] with a maximum size of 64 bytes,
        and is not meant to be displayed to the user.

        To ensure secure operation, authentication and authorization
        decisions MUST be made on the basis of this {{PublicKeyCredentialUserEntity/id}} member,  not the
        {{PublicKeyCredentialUserEntity/displayName}} nor {{PublicKeyCredentialEntity/name}} members. See Section 6.1 of [[!RFC8266]].

        The [=user handle=] MUST NOT contain [PII] about the user, such as a username or e-mail address;
        see [[#sctn-user-handle-privacy]] for details. The [=user handle=] MUST NOT be empty.

        Note: the [=user handle=] <i>ought not</i> be a constant value across different [=user accounts=],
        even for [=non-discoverable credentials=], because some authenticators always create [=discoverable credentials=].
        Thus a constant [=user handle=] would prevent a user from using such an authenticator
        with more than one [=user account=] at the [=[RP]=].

    :   <dfn>displayName</dfn>
    ::  A [=human palatability|human-palatable=] name for the [=user account=], intended only for display. For example, "Alex Müller" or "田中倫". The
        [=[RP]=] SHOULD let the user choose this, and SHOULD NOT restrict the choice more than necessary.

        - [=[RPS]=] SHOULD perform enforcement, as prescribed in Section 2.3 of
            [[!RFC8266]] for the Nickname Profile of the PRECIS FreeformClass [[!RFC8264]],
            when setting {{PublicKeyCredentialUserEntity/displayName}}'s value, or displaying the value to the user.

        - This string MAY contain language and direction metadata. [=[RPS]=] SHOULD consider providing this information. See [[#sctn-strings-langdir]] about how this metadata is encoded.

        - [=Clients=] SHOULD perform enforcement, as prescribed in Section 2.3 of
            [[!RFC8266]] for the Nickname Profile of the PRECIS FreeformClass [[!RFC8264]],
            on {{PublicKeyCredentialUserEntity/displayName}}'s value prior to displaying the value to the user or
            including the value as a parameter of the [=authenticatorMakeCredential=] operation.

        When [=clients=], [=client platforms=], or [=authenticators=] display a {{PublicKeyCredentialUserEntity/displayName}}'s value, they should always use UI elements to provide a clear boundary around the displayed value, and not allow overflow into other elements [[css-overflow-3]].

        [=Authenticators=] MUST accept and store a 64-byte minimum length for a {{PublicKeyCredentialUserEntity/displayName}}
        member's value. Authenticators MAY truncate a {{PublicKeyCredentialUserEntity/displayName}} member's value so that it fits within 64 bytes. See [[#sctn-strings-truncation]] about truncation and other considerations.
</div>


### Authenticator Selection Criteria (dictionary <dfn dictionary>AuthenticatorSelectionCriteria</dfn>) ### {#dictionary-authenticatorSelection}

[=[WRPS]=] may use the {{AuthenticatorSelectionCriteria}} dictionary to specify their requirements regarding authenticator
attributes.

<xmp class="idl">
    dictionary AuthenticatorSelectionCriteria {
        DOMString                    authenticatorAttachment;
        DOMString                    residentKey;
        boolean                      requireResidentKey = false;
        DOMString                    userVerification = "preferred";
    };
</xmp>

<div dfn-type="dict-member" dfn-for="AuthenticatorSelectionCriteria">
    :   <dfn>authenticatorAttachment</dfn>
    ::  If this member is present, eligible [=authenticators=] are filtered to be only those authenticators attached with the specified
        [[#enum-attachment|authenticator attachment modality]] (see also [[#sctn-authenticator-attachment-modality]]).
        If this member is absent, then any attachment modality is acceptable.
        The value SHOULD be a member of {{AuthenticatorAttachment}} but [=client platforms=] MUST ignore unknown values,
        treating an unknown value as if the [=map/exist|member does not exist=].

        See also the {{PublicKeyCredential/authenticatorAttachment}} member of {{PublicKeyCredential}},
        which can tell what [=authenticator attachment modality=] was used
        in a successful {{CredentialsContainer/create()}} or {{CredentialsContainer/get()}} operation.

    :   <dfn>residentKey</dfn>
    ::  Specifies the extent to which the [=[RP]=] desires to create a [=client-side discoverable credential=]. For historical reasons the naming retains the deprecated “resident” terminology. The value SHOULD be a member of {{ResidentKeyRequirement}} but [=client platforms=] MUST ignore unknown values, treating an unknown value as if the [=map/exist|member does not exist=]. If no value is given then the effective value is {{ResidentKeyRequirement/required}} if {{requireResidentKey}} is [TRUE] or {{ResidentKeyRequirement/discouraged}} if it is [FALSE] or absent.

        See {{ResidentKeyRequirement}} for the description of {{residentKey}}'s values and semantics.

    :   <dfn>requireResidentKey</dfn>
    ::  This member is retained for backwards compatibility with WebAuthn Level 1 and, for historical reasons, its naming retains the deprecated “resident” terminology for [=discoverable credentials=]. [=[RPS]=] SHOULD set it to [TRUE] if, and only if, {{residentKey}} is set to {{ResidentKeyRequirement/required}}.

    :   <dfn>userVerification</dfn>
    ::  This member specifies the [=[RP]=]'s requirements regarding [=user verification=] for the
        {{CredentialsContainer/create()}} operation.
        The value SHOULD be a member of {{UserVerificationRequirement}} but [=client platforms=] MUST ignore unknown values, treating an unknown value as if the [=map/exist|member does not exist=].

        See {{UserVerificationRequirement}} for the description of {{AuthenticatorSelectionCriteria/userVerification}}'s values and semantics.
</div>


### Authenticator Attachment Enumeration (enum <dfn enum>AuthenticatorAttachment</dfn>) ### {#enum-attachment}

This enumeration's values describe [=authenticators=]' [=authenticator attachment modality|attachment modalities=].
[=[RPS]=] use this to express a preferred [=authenticator attachment modality=]
when calling {{CredentialsContainer/create()|navigator.credentials.create()}}
to [[#sctn-createCredential|create a credential]], and [=clients=] use this to report the [=authenticator attachment modality=]
used to complete a [=registration ceremony|registration=] or [=authentication ceremony=].

<xmp class="idl">
    enum AuthenticatorAttachment {
        "platform",
        "cross-platform"
    };
</xmp>

Note: The {{AuthenticatorAttachment}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

<div dfn-type="enum-value" dfn-for="AuthenticatorAttachment">
    :   <dfn>platform</dfn>
    ::  This value indicates [=platform attachment=].

    :   <dfn>cross-platform</dfn>
    ::  This value indicates [=cross-platform attachment=].
</div>

Note: An [=authenticator attachment modality=] selection option is available only in the {{PublicKeyCredential/[[Create]](origin, options,
sameOriginWithAncestors)}} operation. The [=[RP]=] may use it to, for example, ensure the user has a [=roaming credential=] for
authenticating on another [=client device=]; or to specifically register a [=platform credential=] for easier reauthentication using a
particular [=client device=]. The {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}
operation has no [=authenticator attachment modality=] selection option, so the [=[RP]=] SHOULD accept any of the user's registered [=public key
credential|credentials=]. The [=client=] and user will then use whichever is available and convenient at the time.


### Resident Key Requirement Enumeration (enum <dfn enum>ResidentKeyRequirement</dfn>) ### {#enum-residentKeyRequirement}

<xmp class="idl">
    enum ResidentKeyRequirement {
        "discouraged",
        "preferred",
        "required"
    };
</xmp>

Note: The {{ResidentKeyRequirement}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

This enumeration's values describe the [=[RP]=]'s requirements for [=client-side discoverable credentials=] (formerly known as [=resident credentials=] or [=resident keys=]):

<div dfn-type="enum-value" dfn-for="ResidentKeyRequirement">
    :   <dfn>discouraged</dfn>
    ::  The [=[RP]=] prefers creating a [=server-side credential=], but will accept a
        [=client-side discoverable credential=].
        The [=client=] and [=authenticator=] SHOULD create a [=server-side credential=] if possible.

        Note: A [=[RP]=] cannot require that a created credential is a [=server-side credential=] and the [=credProps|Credential Properties Extension=] may not return a value for the {{CredentialPropertiesOutput/rk}} property. Because of this, it may be the case that it does not know if a credential is a [=server-side credential=] or not and thus does not know whether creating a second credential with the same [=user handle=] will evict the first.

    :   <dfn>preferred</dfn>
    ::  The [=[RP]=] strongly prefers creating a [=client-side discoverable credential=], but will accept a
        [=server-side credential=].
        The [=client=] and [=authenticator=] SHOULD create a [=discoverable credential=] if possible.
        For example, the [=client=] SHOULD guide the user through setting up [=user verification=] if needed to create a [=discoverable credential=]. This takes precedence over the setting of {{AuthenticatorSelectionCriteria/userVerification}}.

    :   <dfn>required</dfn>
    ::  The [=[RP]=] requires a [=client-side discoverable credential=].
        The [=client=] MUST return an error if a [=client-side discoverable credential=] cannot be created.
</div>

Note: The [=[RP]=] can seek information on whether or not the authenticator created a [=client-side discoverable credential=]
using the [=resident key credential property=] of the [=credProps|Credential Properties Extension=].
This is useful when values of {{ResidentKeyRequirement/discouraged}} or {{ResidentKeyRequirement/preferred}} are used for
<code>|options|.{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{residentKey}}</code>, because in those cases it is possible for an
[=authenticator=] to create <em>either</em> a [=client-side discoverable credential=] or a [=server-side credential=].


### <dfn>Attestation Conveyance</dfn> Preference Enumeration (enum <dfn enum>AttestationConveyancePreference</dfn>) ### {#enum-attestation-convey}

[=[WRPS]=] may use {{AttestationConveyancePreference}} to specify their preference regarding [=attestation conveyance=]
during credential generation.

<xmp class="idl">
    enum AttestationConveyancePreference {
        "none",
        "indirect",
        "direct",
        "enterprise"
    };
</xmp>

Note: The {{AttestationConveyancePreference}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

<div dfn-type="enum-value" dfn-for="AttestationConveyancePreference">
    :   <dfn>none</dfn>
    ::  The [=[RP]=] is not interested in [=authenticator=] [=attestation=]. For example, in order to
        potentially avoid having to obtain [=user consent=] to relay identifying information to the [=[RP]=], or to save a
        roundtrip to an [=Attestation CA=] or [=Anonymization CA=].
        If the [=authenticator=] generates an [=attestation statement=] that is not a [=self attestation=],
        the [=client=] will replace it with a [=None=] attestation statement.

        This is the default, and unknown values fall back to the behavior of this value.

    :   <dfn>indirect</dfn>
    ::  The [=[RP]=] wants to receive a verifiable [=attestation statement=],
        but allows the [=client=] to decide how to obtain such an [=attestation statement=].
        The client MAY replace an authenticator-generated [=attestation statement=] with one generated by an [=Anonymization CA=],
        in order to protect the user's privacy, or to assist [=[RPS]=] with attestation verification in a heterogeneous ecosystem.

        Note: There is no guarantee that the [=[RP]=] will obtain a verifiable [=attestation statement=] in this case.
        For example, in the case that the authenticator employs [=self attestation=]
        and the [=client=] passes the [=attestation statement=] through unmodified.

    :   <dfn>direct</dfn>
    ::  The [=[RP]=] wants to receive the [=attestation statement=] as generated by the [=authenticator=].

    :   <dfn>enterprise</dfn>
    ::  The [=[RP]=] wants to receive an [=attestation statement=] that may include uniquely identifying information. This is intended for controlled deployments within an enterprise where the organization wishes to tie registrations to specific authenticators. User agents MUST NOT provide such an attestation unless the user agent or authenticator configuration permits it for the requested [=RP ID=].

        If permitted, the user agent SHOULD signal to the authenticator (at [invocation time](#CreateCred-InvokeAuthnrMakeCred)) that enterprise attestation is requested, and convey the resulting [=AAGUID=] and [=attestation statement=], unaltered, to the [=[RP]=].
</div>


## Options for Assertion Generation (dictionary <dfn dictionary>PublicKeyCredentialRequestOptions</dfn>) ## {#dictionary-assertion-options}

The {{PublicKeyCredentialRequestOptions}} dictionary supplies {{CredentialsContainer/get()}} with the data it needs to generate
an assertion. Its {{PublicKeyCredentialRequestOptions/challenge}} member MUST be present, while its other members are OPTIONAL.

<xmp class="idl">
    dictionary PublicKeyCredentialRequestOptions {
        required BufferSource                challenge;
        unsigned long                        timeout;
        USVString                            rpId;
        sequence<PublicKeyCredentialDescriptor> allowCredentials = [];
        DOMString                            userVerification = "preferred";
        DOMString                            attestation = "none";
        sequence<DOMString>                  attestationFormats = [];
        AuthenticationExtensionsClientInputs extensions;
    };
</xmp>

<dl dfn-type="dict-member" dfn-for="PublicKeyCredentialRequestOptions">
    :   <dfn>challenge</dfn>
    ::  This member specifies a challenge that the [=authenticator=] signs, along with other data, when producing an
        [=authentication assertion=]. See the [[#sctn-cryptographic-challenges]] security consideration.

    :   <dfn>timeout</dfn>
    ::  This OPTIONAL member specifies a time, in milliseconds, that the [=[RP]=] is willing to wait for the call to complete.
        The value is treated as a hint, and MAY be overridden by the [=client=].

    :   <dfn>rpId</dfn>
    ::  This OPTIONAL member specifies the [=RP ID=] claimed by the [=[RP]=].
        The [=client=] MUST verify that the [=[RP]=]'s [=origin=] matches the [=scope=] of this [=RP ID=].
        The [=authenticator=] MUST verify
        that this [=RP ID=] exactly equals the [=rpId=] of the [=credential=] to be used for the [=authentication ceremony=].

        If not specified, its value will
        be the {{CredentialsContainer}} object's [=relevant settings object=]'s [=environment settings object/origin=]'s
        [=effective domain=].

    :   <dfn>allowCredentials</dfn>
    ::  This OPTIONAL member is used by the [=client=] to find [=authenticators=] eligible for this [=authentication ceremony=].
        It can be used in two ways:

          - If the [=user account=] to authenticate is already identified (e.g., if the user has entered a username),
            then the [=[RP]=] SHOULD use this member to list
            [=credential descriptor for a credential record|credential descriptors for credential records=] in the [=user account=].
            This SHOULD usually include all [=credential records=] in the [=user account=].

            The [=list/items=] SHOULD specify {{PublicKeyCredentialDescriptor/transports}} whenever possible.
            This helps the [=client=] optimize the user experience for any given situation.
            Also note that the [=[RP]=] does not need to filter the list when requesting [=user verification=] &mdash;
            the [=client=] will automatically ignore non-eligible credentials
            if {{PublicKeyCredentialRequestOptions/userVerification}} is set to {{UserVerificationRequirement/required}}.

            See also the [[#sctn-credential-id-privacy-leak]] privacy consideration.

          - If the [=user account=] to authenticate is not already identified,
            then the [=[RP]=] MAY leave this member [=list/empty=] or unspecified.
            In this case, only [=discoverable credentials=] will be utilized in this [=authentication ceremony=],
            and the [=user account=] MAY be identified by the {{AuthenticatorAssertionResponse/userHandle}}
            of the resulting {{AuthenticatorAssertionResponse}}.
            If the available [=authenticators=] [=contain=] more than one [=discoverable credential=] [=scoped=] to the [=[RP]=],
            the credentials are displayed by the [=client platform=] or [=authenticator=]
            for the user to select from (see step 7 of [[#sctn-op-get-assertion]]).

        If not [=list/empty=], the client MUST return an error if none of the listed credentials can be used.

        The list is ordered in descending order of preference: the first item in the list is the most
        preferred credential, and the last is the least preferred.

    :   <dfn>userVerification</dfn>
    ::  This OPTIONAL member specifies the [=[RP]=]'s requirements regarding [=user verification=] for the
        {{CredentialsContainer/get()}} operation. The value SHOULD be a member of {{UserVerificationRequirement}} but [=client platforms=] MUST ignore unknown values, treating an unknown value as if the [=map/exist|member does not exist=]. Eligible authenticators are filtered to only those capable of satisfying this requirement.

        See {{UserVerificationRequirement}} for the description of {{AuthenticatorSelectionCriteria/userVerification}}'s values and semantics.

    :   <dfn>attestation</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to specify a preference regarding [=attestation conveyance=].
        Its value SHOULD be a member of {{AttestationConveyancePreference}}.
        [=Client platforms=] MUST ignore unknown values, treating an unknown value as if the [=map/exist|member does not exist=].

        The default value is {{AttestationConveyancePreference/none}}.

    :   <dfn>attestationFormats</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to specify a preference regarding the [=attestation=] statement format used by the [=authenticator=].
        Values SHOULD be taken from the IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].
        Values are ordered from most preferable to least preferable.
        This parameter is advisory and the [=authenticator=] MAY use an attestation statement not enumerated in this parameter.

        The default value is the empty list, which indicates no preference.

    :   <dfn>extensions</dfn>
    ::  The [=[RP]=] MAY use this OPTIONAL member to provide [=client extension inputs=]
        requesting additional processing by the [=client=] and [=authenticator=].

        The extensions framework is defined in [[#sctn-extensions]].
        Some extensions are defined in [[#sctn-defined-extensions]];
        consult the IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]] for an up-to-date list
        of registered [=WebAuthn Extensions=].
</dl>


## Abort Operations with `AbortSignal` ## {#sctn-abortoperation}

Developers are encouraged to leverage the {{AbortController}} to manage the
{{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}} and {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} operations.
See [[dom#abortcontroller-api-integration]] section for detailed instructions.

    Note: [[dom#abortcontroller-api-integration]] section specifies that web platform APIs integrating with the
    {{AbortController}} must reject the promise immediately once the {{AbortSignal}} is [=AbortSignal/aborted=].
    Given the complex inheritance and parallelization structure of the {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}}
    and {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} methods, the algorithms for the two APIs fulfills this
    requirement by checking the [=AbortSignal/aborted=] property in three places. In the case of
    {{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}}, the [=AbortSignal/aborted=] property is checked first in
    [[credential-management-1#algorithm-create]] immediately before calling {{Credential/[[Create]](origin, options, sameOriginWithAncestors)}},
    then in [[#sctn-createCredential]] right before [=authenticator sessions=] start, and finally
    during [=authenticator sessions=]. The same goes for
    {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}}.

The [=visibility states|visibility=] and [=focus=] state of the [=Window=] object determines whether the
{{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}} and {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} operations
should continue. When the [=Window=] object associated with the [=Document=] loses focus,
{{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}} and {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} operations
SHOULD be aborted.

    Issue: The WHATWG HTML WG is discussing whether to provide a hook when a browsing context gains or
    loses focuses. If a hook is provided, the above paragraph will be updated to include the hook.
    See [WHATWG HTML WG Issue #2711](https://github.com/whatwg/html/issues/2711) for more details.


## WebAuthn Extensions Inputs and Outputs ## {#sctn-extensions-inputs-outputs}

The subsections below define the data types used for conveying [=WebAuthn extension=] inputs and outputs.

Note: [=Authenticator extension outputs=] are conveyed as a part of [=authenticator data=] (see [Table 1](#table-authData)).

Note: The types defined below &mdash; {{AuthenticationExtensionsClientInputs}} and {{AuthenticationExtensionsClientOutputs}} &mdash; are applicable to both [=registration extensions=] and [=authentication extensions=]. The "Authentication..." portion of their names should be regarded as meaning "WebAuthentication..."


### Authentication Extensions Client Inputs (dictionary {{AuthenticationExtensionsClientInputs}}) ### {#iface-authentication-extensions-client-inputs}

<xmp class="idl">
    dictionary AuthenticationExtensionsClientInputs {
    };
</xmp>

This is a dictionary containing the [=client extension input=] values for zero or more [=WebAuthn Extensions=].


### Authentication Extensions Client Outputs (dictionary {{AuthenticationExtensionsClientOutputs}}) ### {#iface-authentication-extensions-client-outputs}

<xmp class="idl">
    dictionary AuthenticationExtensionsClientOutputs {
    };
</xmp>

This is a dictionary containing the [=client extension output=] values for zero or more [=WebAuthn Extensions=].


### Authentication Extensions Authenticator Inputs (CDDL type `AuthenticationExtensionsAuthenticatorInputs`) ### {#iface-authentication-extensions-authenticator-inputs}

```
AuthenticationExtensionsAuthenticatorInputs = {
  * $$extensionInput .within ( tstr => any )
}
```

The [=CDDL=] type `AuthenticationExtensionsAuthenticatorInputs` defines a [=CBOR=] map
containing the [=authenticator extension input=] values for zero or more [=WebAuthn Extensions=].
Extensions can add members as described in [[#sctn-extension-request-parameters]].

This type is not exposed to the [=[RP]=], but is used by the [=client=] and [=authenticator=].


### Authentication Extensions Authenticator Outputs (CDDL type `AuthenticationExtensionsAuthenticatorOutputs`) ### {#iface-authentication-extensions-authenticator-outputs}

```
AuthenticationExtensionsAuthenticatorOutputs = {
  * $$extensionOutput .within ( tstr => any )
}
```

The [=CDDL=] type `AuthenticationExtensionsAuthenticatorOutputs` defines a [=CBOR=] map
containing the [=authenticator extension output=] values for zero or more [=WebAuthn Extensions=].
Extensions can add members as described in [[#sctn-extension-request-parameters]].


## Supporting Data Structures ## {#sctn-supporting-data-structures}

The [=public key credential=] type uses certain data structures that are specified in supporting specifications. These are as
follows.


### Client Data Used in [=WebAuthn Signatures=] (dictionary <dfn dictionary>CollectedClientData</dfn>) ### {#dictionary-client-data}

The <dfn>client data</dfn> represents the contextual bindings of both the [=[WRP]=] and the [=client=]. It is a key-value
mapping whose keys are strings. Values can be any type that has a valid encoding in JSON. Its structure is defined by the
following Web IDL.

Note: The {{CollectedClientData}} may be extended in the future. Therefore it's critical when parsing to be tolerant of unknown keys and of any reordering of the keys. See also [[#clientdatajson-verification]].

<xmp class="idl">
    dictionary CollectedClientData {
        required DOMString           type;
        required DOMString           challenge;
        required DOMString           origin;
        boolean                      crossOrigin;
    };

    dictionary TokenBinding {
        required DOMString status;
        DOMString id;
    };

    enum TokenBindingStatus { "present", "supported" };
</xmp>

<div dfn-type="dict-member" dfn-for="CollectedClientData">
    :   <dfn>type</dfn>
    ::  This member contains the string "webauthn.create" when creating new credentials, and "webauthn.get" when getting an
        assertion from an existing credential. The purpose of this member is to prevent certain types of signature confusion
        attacks (where an attacker substitutes one legitimate signature for another).

    :   <dfn>challenge</dfn>
    ::  This member contains the base64url encoding of the challenge provided by the [=[RP]=]. See the [[#sctn-cryptographic-challenges]]
        security consideration.

    :   <dfn>origin</dfn>
    ::  This member contains the fully qualified [=origin=] of the requester, as provided to the authenticator by the client, in
        the syntax defined by [[!RFC6454]].

    :   <dfn>crossOrigin</dfn>
    ::  This OPTIONAL member contains the inverse of the `sameOriginWithAncestors` argument value
        that was passed into the [=internal method=].

    :   \[RESERVED] <dfn dfn>tokenBinding</dfn>
    ::  This OPTIONAL member contains information about the state of the [=Token Binding=] protocol [[!TokenBinding]] used when communicating
        with the [=[RP]=]. Its absence indicates that the client doesn't support token binding

        Note: While [=Token Binding=] was present in Level 1 and Level 2 of WebAuthn, its use is not expected in Level 3. The {{CollectedClientData/tokenBinding}} field is reserved so that it will not be reused for a different purpose.

        <div dfn-type="dict-member" dfn-for="TokenBinding">
            :   <dfn>status</dfn>
            ::  This member SHOULD be a member of {{TokenBindingStatus}} but [=client platforms=] MUST ignore unknown values, treating an unknown value as if the {{CollectedClientData/tokenBinding}} [=map/exist|member does not exist=]. When known, this member is one of the following:

                <div dfn-type="enum-value" dfn-for="TokenBindingStatus">
                    :   <dfn>supported</dfn>
                    ::  Indicates the client supports token binding, but it was not negotiated when communicating with the [=[RP]=].

                    :   <dfn>present</dfn>
                    ::  Indicates token binding was used when communicating with the [=[RP]=]. In this case, the
                        {{TokenBinding/id}} member MUST be present.
                </div>

                Note: The {{TokenBindingStatus}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

            :   <dfn>id</dfn>
            ::  This member MUST be present if {{TokenBinding/status}} is {{TokenBindingStatus/present}}, and MUST be a [=base64url
                encoding=] of the [=Token Binding ID=] that was used when communicating with the [=[RP]=].
        </div>

        Note: Obtaining a [=Token Binding ID=] is a [=client platform=]-specific operation.

    The {{CollectedClientData}} structure is used by the client to compute the following quantities:

    : <dfn dfn>JSON-compatible serialization of client data</dfn>
    :: This is the result of performing the [JSON-compatible serialization algorithm](#clientdatajson-serialization) on the {{CollectedClientData}} dictionary.

    : <dfn dfn>Hash of the serialized client data</dfn>
    :: This is the hash (computed using SHA-256) of the [=JSON-compatible serialization of client data=], as constructed by the client.
</div>

#### Serialization #### {#clientdatajson-serialization}

The serialization of the {{CollectedClientData}} is a subset of the algorithm for [=serialize JSON to bytes|JSON-serializing to bytes=]. I.e. it produces a valid JSON encoding of the {{CollectedClientData}} but also provides additional structure that may be exploited by verifiers to avoid integrating a full JSON parser. While verifiers are recommended to perform standard JSON parsing, they may use the [more limited algorithm](#clientdatajson-verification) below in contexts where a full JSON parser is too large. This verification algorithm requires only [=base64url encoding=], appending of bytestrings (which could be implemented by writing into a fixed template), and three conditional checks (assuming that inputs are known not to need escaping).

The serialization algorithm works by appending successive byte strings to an, initially empty, partial result until the complete result is obtained.

1. Let |result| be an empty byte string.
1. Append 0x7b2274797065223a (`{"type":`) to |result|.
1. Append [=CCDToString=]({{CollectedClientData/type}}) to |result|.
1. Append 0x2c226368616c6c656e6765223a (`,"challenge":`) to |result|.
1. Append [=CCDToString=]({{CollectedClientData/challenge}}) to |result|.
1. Append 0x2c226f726967696e223a (`,"origin":`) to |result|.
1. Append [=CCDToString=]({{CollectedClientData/origin}}) to |result|.
1. Append 0x2c2263726f73734f726967696e223a (`,"crossOrigin":`) to |result|.
1. If {{CollectedClientData/crossOrigin}} is not present, or is `false`:
    1. Append 0x66616c7365 (`false`) to |result|.
1. Otherwise:
    1. Append 0x74727565 (`true`) to |result|.
1. Create a temporary copy of the {{CollectedClientData}} and remove the fields {{CollectedClientData/type}}, {{CollectedClientData/challenge}}, {{CollectedClientData/origin}}, and {{CollectedClientData/crossOrigin}} (if present).
1. If no fields remain in the temporary copy then:
    1. Append 0x7d (`}`) to |result|.
1. Otherwise:
    1. Invoke [=serialize JSON to bytes=] on the temporary copy to produce a byte string |remainder|.
    1. Append 0x2c (`,`) to |result|.
    1. Remove the leading byte from |remainder|.
    1. Append |remainder| to |result|.
1. The result of the serialization is the value of |result|.

The function <dfn>CCDToString</dfn> is used in the above algorithm and is defined as:

1. Let |encoded| be an empty byte string.
1. Append 0x22 (`"`) to |encoded|.
1. Invoke [ToString](https://tc39.es/ecma262/#sec-tostring) on the given object to convert to a string.
1. For each code point in the resulting string, if the code point:
    <dl class="switch">
        : is in the set {U+0020, U+0021, U+0023&ndash;U+005B, U+005D&ndash;U+10FFFF}
        :: Append the UTF-8 encoding of that code point to |encoded|.

        : is U+0022
        :: Append 0x5c22 (`\"`) to |encoded|.

        : is U+005C
        :: Append 0x5c5c (<kbd>\\</kbd>) to |encoded|.

        : otherwise
        :: Append 0x5c75 (`\u`) to |encoded|, followed by four, lower-case hex digits that, when interpreted as a base-16 number, represent that code point.
    </dl>
1. Append 0x22 (`"`) to |encoded|.
1. The result of this function is the value of |encoded|.

#### Limited Verification Algorithm #### {#clientdatajson-verification}

Verifiers may use the following algorithm to verify an encoded {{CollectedClientData}} if they cannot support a full JSON parser:

1. The inputs to the algorithm are:
    1. A bytestring, |clientDataJSON|, that contains {{AuthenticatorResponse/clientDataJSON}}&thinsp;&mdash;&thinsp;the serialized {{CollectedClientData}} that is to be verified.
    1. A string, |type|, that contains the expected {{CollectedClientData/type}}.
    1. A byte string, |challenge|, that contains the challenge byte string that was given in the {{PublicKeyCredentialRequestOptions}} or {{PublicKeyCredentialCreationOptions}}.
    1. A string, |origin|, that contains the expected {{CollectedClientData/origin}} that issued the request to the user agent.
    1. A boolean, |crossOrigin|, that is true if, and only if, the request should have been performed within a cross-origin <{iframe}>.
1. Let |expected| be an empty byte string.
1. Append 0x7b2274797065223a (`{"type":`) to |expected|.
1. Append [=CCDToString=](|type|) to |expected|.
1. Append 0x2c226368616c6c656e6765223a (`,"challenge":`) to |expected|.
1. Perform [=base64url encoding=] on |challenge| to produce a string, |challengeBase64|.
1. Append [=CCDToString=](|challengeBase64|) to |expected|.
1. Append 0x2c226f726967696e223a (`,"origin":`) to |expected|.
1. Append [=CCDToString=](|origin|) to |expected|.
1. Append 0x2c2263726f73734f726967696e223a (`,"crossOrigin":`) to |expected|.
1. If |crossOrigin| is true:
    1. Append 0x74727565 (`true`) to |expected|.
1. Otherwise, i.e. |crossOrigin| is false:
    1. Append 0x66616c7365 (`false`) to |expected|.
1. If |expected| is not a prefix of |clientDataJSON| then the verification has failed.
1. If |clientDataJSON| is not at least one byte longer than |expected| then the verification has failed.
1. If the byte of |clientDataJSON| at the offset equal to the length of |expected|:
    <dl class="switch">
        : is 0x7d
        :: The verification is successful.

        : is 0x2c
        :: The verification is successful.

        : otherwise
        :: The verification has failed.
    </dl>

#### Future development #### {#clientdatajson-development}

In order to remain compatible with the [limited verification algorithm](#clientdatajson-verification), future versions of this specification must not remove any of the fields {{CollectedClientData/type}}, {{CollectedClientData/challenge}}, {{CollectedClientData/origin}}, or {{CollectedClientData/crossOrigin}} from {{CollectedClientData}}. They also must not change the [serialization algorithm](#clientdatajson-verification) to change the order in which those fields are serialized.

If additional fields are added to {{CollectedClientData}} then verifiers that employ the [limited verification algorithm](#clientdatajson-verification) will not be able to consider them until the two algorithms above are updated to include them. Once such an update occurs then the added fields inherit the same limitations as described in the previous paragraph. Such an algorithm update would have to accomodate serializations produced by previous versions. I.e. the verification algorithm would have to handle the fact that a fifth key&ndash;value pair may not appear fifth (or at all) if generated by a user agent working from a previous version.

### Credential Type Enumeration (enum <dfn enum>PublicKeyCredentialType</dfn>) ### {#enum-credentialType}

<xmp class="idl">
    enum PublicKeyCredentialType {
        "public-key"
    };
</xmp>

Note: The {{PublicKeyCredentialType}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

<div dfn-type="enum-value" dfn-for="PublicKeyCredentialType">
    This enumeration defines the valid credential types. It is an extension point; values can be added to it in the future, as
    more credential types are defined. The values of this enumeration are used for versioning the Authentication Assertion and
    attestation structures according to the type of the authenticator.

    Currently one credential type is defined, namely "<dfn>public-key</dfn>".

</div>


### Credential Descriptor (dictionary <dfn dictionary>PublicKeyCredentialDescriptor</dfn>) ### {#dictionary-credential-descriptor}

<xmp class="idl">
    dictionary PublicKeyCredentialDescriptor {
        required DOMString                    type;
        required BufferSource                 id;
        sequence<DOMString>                   transports;
    };
</xmp>

This dictionary identifies a specific [=public key credential=].
It is used in {{CredentialsContainer/create()}} to prevent creating duplicate credentials on the same [=authenticator=],
and in {{CredentialsContainer/get()}} to determine if and how the credential can currently be reached by the [=client=].
It mirrors some fields of the {{PublicKeyCredential}} object returned by
{{CredentialsContainer/create()}} and {{CredentialsContainer/get()}}.

<div dfn-type="dict-member" dfn-for="PublicKeyCredentialDescriptor">
    :   <dfn>type</dfn>
    ::  This member contains the type of the [=public key credential=] the caller is referring to. The value SHOULD be a member of {{PublicKeyCredentialType}} but [=client platforms=] MUST ignore any {{PublicKeyCredentialDescriptor}} with an unknown {{PublicKeyCredentialDescriptor/type}}.

        This mirrors the {{Credential/type}} field of {{PublicKeyCredential}}.

    :   <dfn>id</dfn>
    ::  This member contains the [=credential ID=] of the [=public key credential=] the caller is referring to.

        This mirrors the {{PublicKeyCredential/rawId}} field of {{PublicKeyCredential}}.

    :   <dfn>transports</dfn>
    ::  This OPTIONAL member contains a hint as to how the [=client=] might communicate with the [=managing authenticator=] of the
        [=public key credential=] the caller is referring to. The values SHOULD be members of {{AuthenticatorTransport}} but [=client platforms=] MUST ignore unknown values.

        This mirrors the <code>{{PublicKeyCredential/response}}.{{AuthenticatorAttestationResponse/getTransports()}}</code> method
        of a {{PublicKeyCredential}} structure created by a {{CredentialsContainer/create()}} operation.
        When [[#sctn-registering-a-new-credential|registering a new credential]],
        the [=[RP]=] SHOULD store the value returned from {{AuthenticatorAttestationResponse/getTransports()}}.
        When creating a {{PublicKeyCredentialDescriptor}} for that credential,
        the [=[RP]=] SHOULD retrieve that stored value
        and set it as the value of the {{PublicKeyCredentialDescriptor/transports}} member.
</div>


### Authenticator Transport Enumeration (enum <dfn enum>AuthenticatorTransport</dfn>) ### {#enum-transport}

<xmp class="idl">
    enum AuthenticatorTransport {
        "usb",
        "nfc",
        "ble",
        "hybrid",
        "internal"
    };
</xmp>

Note: The {{AuthenticatorTransport}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

<div dfn-type="enum-value" dfn-for="AuthenticatorTransport">
    [=Authenticators=] may implement various [[#enum-transport|transports]] for communicating with [=clients=]. This enumeration
    defines hints as to how clients might communicate with a particular authenticator in order to obtain an assertion for a
    specific credential. Note that these hints represent the [=[WRP]=]'s best belief as to how an authenticator may be reached. A
    [=[RP]=] will typically learn of the supported transports for a [=public key credential=] via
    {{AuthenticatorAttestationResponse/getTransports()}}.

    :   <dfn>usb</dfn>
    ::  Indicates the respective [=authenticator=] can be contacted over removable USB.

    :   <dfn>nfc</dfn>
    ::  Indicates the respective [=authenticator=] can be contacted over Near Field Communication (NFC).

    :   <dfn>ble</dfn>
    ::  Indicates the respective [=authenticator=] can be contacted over Bluetooth Smart (Bluetooth Low Energy / BLE).

    :   <dfn>hybrid</dfn>
    ::  Indicates the respective [=authenticator=] can be contacted using a combination of (often separate) data-transport and proximity mechanisms. This supports, for example, authentication on a desktop computer using a smartphone.

    :   <dfn>internal</dfn>
    ::  Indicates the respective [=authenticator=] is contacted using a [=client device=]-specific transport,
        i.e., it is a [=platform authenticator=].
        These authenticators are not removable from the [=client device=].
</div>


### Cryptographic Algorithm Identifier (typedef {{COSEAlgorithmIdentifier}}) ### {#sctn-alg-identifier}

<xmp class="idl">
    typedef long COSEAlgorithmIdentifier;
</xmp>

<div dfn-type="typedef" dfn-for="COSEAlgorithmIdentifier">
    A {{COSEAlgorithmIdentifier}}'s value is a number identifying a cryptographic algorithm.
    The algorithm identifiers SHOULD be values registered in the IANA COSE Algorithms registry [[!IANA-COSE-ALGS-REG]],
    for instance, <code>-7</code> for "ES256" and <code>-257</code> for "RS256".

    The COSE algorithms registry leaves degrees of freedom to be specified by other parameters in a [=COSE key=]. In order to promote interoperability, this specification makes the following additional guarantees of [=credential public keys=]:
        1. Keys with algorithm ES256 (-7) MUST specify P-256 (1) as the [=crv=] parameter and MUST NOT use the compressed point form.
        1. Keys with algorithm ES384 (-35) MUST specify P-384 (2) as the [=crv=] parameter and MUST NOT use the compressed point form.
        1. Keys with algorithm ES512 (-36) MUST specify P-521 (3) as the [=crv=] parameter and MUST NOT use the compressed point form.
        1. Keys with algorithm EdDSA (-8) MUST specify Ed25519 (6) as the [=crv=] parameter. (These always use a compressed form in COSE.)

    These restrictions align with the recommendation in [=Section 2.1=] of [[!RFC9053]].
</div>

Note: There are many checks neccessary to correctly implement signature verification using these algorithms. One of these is that, when processing uncompressed elliptic-curve points, implementations should check that the point is actually on the curve. This check is highlighted because it's judged to be at particular risk of falling through the gap between a cryptographic library and other code.

### User Verification Requirement Enumeration (enum <dfn enum>UserVerificationRequirement</dfn>) ### {#enum-userVerificationRequirement}

<xmp class="idl">
    enum UserVerificationRequirement {
        "required",
        "preferred",
        "discouraged"
    };
</xmp>

A [=[WRP]=] may require [=user verification=] for some of its operations but not for others, and may use this type to express its
needs.

Note: The {{UserVerificationRequirement}} enumeration is deliberately not referenced, see [[#sct-domstring-backwards-compatibility]].

<div dfn-type="enum-value" dfn-for="UserVerificationRequirement">
    :   <dfn>required</dfn>
    ::  The [=[RP]=] requires [=user verification=] for the operation and will fail the overall [=ceremony=] if the
        response does not have the [=authData/flags/UV=] [=flag=] set.
        The [=client=] MUST return an error if [=user verification=] cannot be performed.

    :   <dfn>preferred</dfn>
    ::  The [=[RP]=] prefers [=user verification=] for the operation if possible, but will not fail the
        operation if the response does not have the [=authData/flags/UV=] [=flag=] set.

    :   <dfn>discouraged</dfn>
    ::  The [=[RP]=] does not want [=user verification=] employed during the operation (e.g., in the
        interest of minimizing disruption to the user interaction flow).
</div>


## Permissions Policy integration ## {#sctn-permissions-policy}

This specification defines one [=policy-controlled feature=] identified by
the feature-identifier token "<code><dfn data-lt="publickey-credentials-get-feature" export>publickey-credentials-get</dfn></code>".
Its [=default allowlist=] is '<code>self</code>'. [[!Permissions-Policy]]

A {{Document}}'s [=Document/permissions policy=] determines whether any content in that <a href="https://html.spec.whatwg.org/multipage/dom.html#documents">document</a> is
[=allowed to use|allowed to successfully invoke=] the [=Web Authentication API=], i.e., via
<code><a idl for="CredentialsContainer" lt="get()">navigator.credentials.get({publicKey:..., ...})</a></code>.
If disabled in any document, no content in the document will be [=allowed to use=]
the foregoing methods: attempting to do so will [return an error](https://www.w3.org/2001/tag/doc/promises-guide#errors).

Note: Algorithms specified in [[!CREDENTIAL-MANAGEMENT-1]] perform the actual permissions policy evaluation. This is because such policy evaluation needs to occur when there is access to the [=current settings object=]. The {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} [=internal method=] does not have such access since it is invoked [=in parallel=] by {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation [[!CREDENTIAL-MANAGEMENT-1]].



## Using Web Authentication within <code>iframe</code> elements ## {#sctn-iframe-guidance}

The [=Web Authentication API=] is disabled by default in cross-origin <{iframe}>s.
To override this default policy and indicate that a cross-origin <{iframe}> is allowed to invoke the [=Web Authentication API=]'s {{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} method, specify the <{iframe/allow}> attribute on the <{iframe}> element and include the <code>[=publickey-credentials-get-feature|publickey-credentials-get=]</code> feature-identifier token in the <{iframe/allow}> attribute's value.

[=[RPS]=] utilizing the WebAuthn API in an embedded context should review [[#sctn-seccons-visibility]] regarding [=UI redressing=] and its possible mitigations.



# WebAuthn <dfn>Authenticator Model</dfn> # {#sctn-authenticator-model}

[[#sctn-api|The Web Authentication API]] implies a specific abstract functional model for a [=[WAA]=]. This section
describes that [=authenticator model=].

[=Client platforms=] MAY implement and expose this abstract model in any way desired. However, the behavior of the client's Web
Authentication API implementation, when operating on the authenticators supported by that [=client platform=], MUST be indistinguishable
from the behavior specified in [[#sctn-api]].

Note: [[!FIDO-CTAP]] is an example of a concrete instantiation of this model, but it is one in which there are differences in the data it returns and those expected by the [[#sctn-api|WebAuthn API]]'s algorithms. The CTAP2 response messages are CBOR maps constructed using integer keys rather than the string keys defined in this specification for the same objects. The [=client=] is expected to perform any needed transformations on such data. The [[!FIDO-CTAP]] specification details the mapping between CTAP2 integer keys and WebAuthn string keys, in section [=§6.2. Responses=].

For authenticators, this model defines the logical operations that they MUST support, and the data formats that they expose to
the client and the [=[WRP]=]. However, it does not define the details of how authenticators communicate with the [=client device=],
unless they are necessary for interoperability with [=[RPS]=]. For instance, this abstract model does not define protocols for
connecting authenticators to clients over transports such as USB or NFC. Similarly, this abstract model does not define specific
error codes or methods of returning them; however, it does define error behavior in terms of the needs of the client. Therefore,
specific error codes are mentioned as a means of showing which error conditions MUST be distinguishable (or not) from each other
in order to enable a compliant and secure client implementation.

[=[RPS]=] may influence authenticator selection, if they deem necessary, by stipulating various authenticator characteristics
when [[#sctn-createCredential|creating credentials]] and/or when [[#sctn-getAssertion|generating assertions]], through use of
[[#dictionary-makecredentialoptions|credential creation options]] or [[#dictionary-assertion-options|assertion generation options]],
respectively. The algorithms underlying the [[#sctn-api|WebAuthn API]] marshal these options and pass them to the applicable
[[#sctn-authenticator-ops|authenticator operations]] defined below.

In this abstract model, the authenticator provides key management and cryptographic signatures. It can be embedded in the
WebAuthn client or housed in a separate device entirely. The authenticator itself can contain a cryptographic module which
operates at a higher security level than the rest of the authenticator. This is particularly important for authenticators that
are embedded in the WebAuthn client, as in those cases this cryptographic module (which may, for example, be a TPM) could be
considered more trustworthy than the rest of the authenticator.

Each authenticator stores a <dfn for=authenticator>credentials map</dfn>, a [=map=] from ([=rpId=], [=public key credential source/userHandle=]) to
[=public key credential source=].

Additionally, each authenticator has an AAGUID, which is a 128-bit identifier indicating the type (e.g. make and model) of the
authenticator. The AAGUID MUST be chosen by the manufacturer to be identical across all substantially identical authenticators
made by that manufacturer, and different (with high probability) from the AAGUIDs of all other types of authenticators.
The AAGUID for a given type of authenticator SHOULD be randomly generated to ensure this. The [=[RP]=] MAY use the AAGUID to infer certain
properties of the authenticator, such as certification level and strength of key protection, using information from other sources.

The primary function of the authenticator is to provide [=WebAuthn signatures=], which are bound to various contextual data. These
data are observed and added at different levels of the stack as a signature request passes from the server to the
authenticator. In verifying a signature, the server checks these bindings against expected values. These contextual bindings
are divided in two: Those added by the [=[RP]=] or the client, referred to as [=client data=]; and those added by the authenticator,
referred to as the [=authenticator data=]. The authenticator signs over the [=client data=], but is otherwise not interested in
its contents. To save bandwidth and processing requirements on the authenticator, the client hashes the [=client data=] and
sends only the result to the authenticator. The authenticator signs over the combination of the
[=hash of the serialized client data=], and its own [=authenticator data=].

The goals of this design can be summarized as follows.

- The scheme for generating signatures should accommodate cases where the link between the [=client device=] and authenticator
    is very limited, in bandwidth and/or latency. Examples include Bluetooth Low Energy and Near-Field Communication.

- The data processed by the authenticator should be small and easy to interpret in low-level code. In particular, authenticators
    should not have to parse high-level encodings such as JSON.

- Both the [=client=] and the authenticator should have the flexibility to add contextual bindings as needed.

- The design aims to reuse as much as possible of existing encoding formats in order to aid adoption and implementation.

Authenticators produce cryptographic signatures for two distinct purposes:
1. An <dfn>attestation signature</dfn> is produced when a new [=public key credential=] is created via an
    [=authenticatorMakeCredential=] operation. An [=attestation signature=] provides cryptographic
    proof of certain properties of the [=authenticator=] and the credential. For instance, an [=attestation signature=]
    asserts the [=authenticator=] type (as denoted by its AAGUID) and the [=credential public key=]. The [=attestation
    signature=] is signed by an [=attestation private key=], which is chosen depending on the type of [=attestation=] desired.
    For more details on [=attestation=], see [[#sctn-attestation]].
2. An <dfn>assertion signature</dfn> is produced when the [=authenticatorGetAssertion=] method is invoked. It represents an
    assertion by the [=authenticator=] that the user has [=user consent|consented=] to a specific transaction, such as logging
    in, or completing a purchase. Thus, an [=assertion signature=] asserts that the [=authenticator=] possessing a particular
    [=credential private key=] has established, to the best of its ability, that the user requesting this transaction is the
    same user who [=user consent|consented=] to creating that particular [=public key credential=]. It also asserts additional
    information, termed [=client data=], that may be useful to the caller, such as the means by which [=user consent=] was
    provided, and the prompt shown to the user by the [=authenticator=]. The [=assertion signature=] format is illustrated in
    [Figure 4, below](#fig-signature).

The term <dfn>WebAuthn signature</dfn> refers to both [=attestation signatures=] and [=assertion signatures=].
The formats of these signatures, as well as the procedures for generating them, are specified below.

## Authenticator Data ## {#sctn-authenticator-data}

The <dfn>authenticator data</dfn> structure encodes contextual bindings made by the [=authenticator=]. These bindings are
controlled by the authenticator itself, and derive their trust from the [=[WRP]=]'s assessment of the security properties of the
authenticator. In one extreme case, the authenticator may be embedded in the client, and its bindings may be no more trustworthy
than the [=client data=]. At the other extreme, the authenticator may be a discrete entity with high-security hardware and
software, connected to the client over a secure channel. In both cases, the [=[RP]=] receives the [=authenticator data=] in the same
format, and uses its knowledge of the authenticator to make trust decisions.

The [=authenticator data=] has a compact but extensible encoding. This is desired since authenticators can be devices with
limited capabilities and low power requirements, with much simpler software stacks than the [=client platform=].

The [=authenticator data=] structure is a byte array of 37 bytes or more,
laid out as shown in <a href="#table-authData">Table <span class="table-ref-following"/></a>.


<figure id="table-authData" class="table">
    <table class="complex data longlastcol" dfn-for="authData">
        <tr>
            <th>Name</th>
            <th>Length (in bytes)</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>rpIdHash</dfn></td>
            <td>32</td>
            <td>
                SHA-256 hash of the [=RP ID=] the [=public key credential|credential=] is [=scoped=] to.
            </td>
        </tr>
        <tr>
            <td><dfn>flags</dfn></td>
            <td>1</td>
            <td dfn-for="authData/flags">
                Flags (bit 0 is the least significant bit):
                - Bit 0: [=User Present=] (<dfn>UP</dfn>) result.
                    - `1` means the user is [=user present|present=].
                    - `0` means the user is not [=user present|present=].
                - Bit 1: Reserved for future use (`RFU1`).
                - Bit 2: [=User Verified=] (<dfn>UV</dfn>) result.
                    - `1` means the user is [=user verified|verified=].
                    - `0` means the user is not [=user verified|verified=].
                - Bit 3: [=Backup Eligibility=] (<dfn>BE</dfn>).
                    - `1` means the [=public key credential source=] is [=backup eligible=].
                    - `0` means the [=public key credential source=] is not [=backup eligible=].
                - Bit 4: [=Backup State=] (<dfn>BS</dfn>).
                    - `1` means the [=public key credential source=] is currently [=backed up=].
                    - `0` means the [=public key credential source=] is not currently [=backed up=].
                - Bits 5: Reserved for future use (`RFU2`).
                - Bit 6: [=Attested credential data=] included (<dfn>AT</dfn>).
                    - Indicates whether the authenticator added [=attested credential data=].
                - Bit 7: Extension data included (<dfn>ED</dfn>).
                    - Indicates if the [=authenticator data=] has [=authData/extensions=].
            </td>
        </tr>
        <tr>
            <td><dfn>signCount</dfn></td>
            <td>4</td>
            <td>[=Signature counter=], 32-bit unsigned big-endian integer.</td>
        </tr>
        <tr>
            <td><dfn>attestedCredentialData</dfn></td>
            <td>variable (if present)</td>
            <td>
                [=attested credential data=] (if present). See [[#sctn-attested-credential-data]] for details. Its length depends on
                the [=credentialIdLength|length=] of the [=credentialId|credential ID=] and [=credentialPublicKey|credential public
                key=] being attested.
            </td>
        </tr>
        <tr>
            <td><dfn>extensions</dfn></td>
            <td>variable (if present)</td>
            <td>
                Extension-defined [=authenticator data=]. This is a [=CBOR=] [[!RFC8949]] map with [=extension identifiers=] as keys,
                and [=authenticator extension outputs=] as values. See [[#sctn-extensions]] for details.
            </td>
        </tr>
    </table>
    <figcaption>
        [=Authenticator data=] layout. The names in the Name column are only for reference within this document, and are not
        present in the actual representation of the [=authenticator data=].
    </figcaption>
</figure>

The [=RP ID=] is originally received from the [=client=] when the credential is created, and again when an [=assertion=] is generated.
However, it differs from other [=client data=] in some important ways. First, unlike the [=client data=], the [=RP ID=] of a
credential does not change between operations but instead remains the same for the lifetime of that credential. Secondly, it is
validated by the authenticator during the [=authenticatorGetAssertion=] operation, by verifying that the [=RP ID=] that
the requested [=public key credential|credential=] is [=scoped=] to exactly matches the [=RP ID=] supplied by the [=client=].

[=Authenticators=] <dfn for="authenticator data">perform the following steps to generate an [=authenticator data=] structure</dfn>:

- Hash [=RP ID=] using SHA-256 to generate the [=rpIdHash=].

- The [=UP=] [=flag=] SHALL be set if and only if the authenticator performed a [=test of user presence=].
    The [=authData/flags/UV=] [=flag=] SHALL be set if and only if the authenticator performed [=user verification=].
    The `RFU` bits SHALL be set to zero.

    Note: If the authenticator performed both a [=test of user presence=] and [=user verification=],
    possibly combined in a single [=authorization gesture=],
    then the authenticator will set both the [=UP=] [=flag=] and the [=authData/flags/UV=] [=flag=].

- For [=attestation signatures=], the authenticator MUST set the [=AT=] [=flag=] and include the <code>[=attestedCredentialData=]</code>.
    For [=assertion signatures=], the [=AT=] [=flag=] MUST NOT be set and the <code>[=attestedCredentialData=]</code> MUST NOT be included.

- If the authenticator does not include any [=authData/extensions|extension data=], it MUST set the [=authData/flags/ED=] [=flag=] to zero, and to one if
    [=authData/extensions|extension data=] is included.

<a href="#fig-authData">Figure <span class="figure-num-following"/></a> shows a visual representation of the [=authenticator data=] structure.

<figure id="fig-authData">
    <img src="images/fido-signature-formats-figure1.svg"/>
    <figcaption>[=Authenticator data=] layout.</figcaption>
</figure>

<div class="note">
    Note: [=authenticator data=] describes its own length: If the [=AT=] and [=authData/flags/ED=] [=flags=] are not set, it is always 37 bytes long.
    The [=attested credential data=] (which is only present if the [=AT=] [=flag=] is set) describes its own length. If the [=authData/flags/ED=] [=flag=] is set, then the total length is 37 bytes plus the length of the [=attested credential data=] (if the [=AT=] [=flag=] is set), plus the length of the [=authData/extensions=] output (a [=CBOR=] map) that
    follows.

    Determining [=attested credential data=]'s length, which is variable, involves determining <code>[=credentialPublicKey=]</code>'s beginning location given the preceding <code>[=credentialid|credentialId=]</code>'s [=credentialidlength|length=], and then determining the <code>[=credentialPublicKey=]</code>'s length (see also [=Section 7=] of [[!RFC9052]]).
</div>

### <dfn>Signature Counter</dfn> Considerations ### {#sctn-sign-counter}

Authenticators SHOULD implement a [=signature counter=] feature. These counters are conceptually stored for each credential
by the authenticator, or globally for the authenticator as a whole. The initial value of a credential's [=signature counter=] is specified in the <code>[=authData/signCount=]</code>
value of the [=authenticator data=] returned by [=authenticatorMakeCredential=]. The [=signature counter=] is incremented for each successful
[=authenticatorGetAssertion=] operation by some positive value, and subsequent values are returned to the [=[WRP]=] within the
[=authenticator data=] again. The [=signature counter=]'s purpose is to aid [=[RPS]=] in detecting cloned authenticators. Clone
detection is more important for authenticators with limited protection measures.

Authenticators that do not implement a [=signature counter=]
leave the <code>[=authData/signCount=]</code> in the [=authenticator data=] constant at zero.

A [=[RP]=] stores the [=signature counter=] of the most recent [=authenticatorGetAssertion=] operation. (Or the counter from the [=authenticatorMakeCredential=] operation if no [=authenticatorGetAssertion=] has ever been performed on a credential.) In subsequent
[=authenticatorGetAssertion=] operations, the [=[RP]=] compares the stored [=signature counter=] value with the new
<code>[=authData/signCount=]</code> value returned in the assertion's [=authenticator data=]. If either is non-zero, and the new <code>[=authData/signCount=]</code> value is less than or equal to the stored value, a cloned authenticator may exist, or the authenticator may be malfunctioning.

Detecting a [=signature counter=] mismatch does not indicate whether the current operation was performed by a cloned authenticator or the original authenticator.  [=[RPS]=] should address this situation appropriately relative to their individual situations, i.e., their risk tolerance.

Authenticators:
- SHOULD implement per credential [=signature counters=].  This prevents the
    [=signature counter=] value from being shared between [=[RPS]=] and being possibly employed
    as a correlation handle for the user. Authenticators MAY implement a global [=signature counter=],
    i.e., on a per-authenticator basis, but this is less privacy-friendly for users.

- SHOULD ensure that the [=signature counter=] value does not
    accidentally decrease  (e.g., due to hardware failures).


### FIDO U2F Signature Format Compatibility ### {#sctn-fido-u2f-sig-format-compat}

The format for [=assertion signatures=], which sign over the concatenation of an [=authenticator data=] structure and the [=hash
of the serialized client data=], are compatible with the FIDO U2F authentication signature format (see [=Section 5.4=] of
[[FIDO-U2F-Message-Formats]]).

This is because the first 37 bytes of the signed data in a FIDO U2F authentication response message constitute a valid
[=authenticator data=] structure, and the remaining 32 bytes are the [=hash of the serialized client data=]. In this
[=authenticator data=] structure, the <code>[=rpIdHash=]</code> is the FIDO U2F [=application parameter=], all
<code>[=flags=]</code> except <code>[=UP=]</code> are always zero, and the <code>[=attestedCredentialData=]</code> and
<code>[=authData/extensions=]</code> are never present. FIDO U2F authentication signatures can therefore be verified by
the same procedure as other [=assertion signatures=] generated by the [=authenticatorGetAssertion=] operation.

### Credential Backup State ### {#sctn-credential-backup}

Credential [=backup eligibility=] and current [=backup state=] is conveyed by the [=authData/flags/BE=] and [=authData/flags/BS=] [=flags=] in the [=authenticator data=], as
defined in <a href="#table-authData">Table <span class="table-ref-previous"/></a>.

The value of the [=authData/flags/BE=] [=flag=] is set during [=authenticatorMakeCredential=] operation and MUST NOT change.

The value of the [=authData/flags/BS=] [=flag=] may change over time based on the current state of the [=public key credential source=]. <a href="#table-backupStates">Table <span class="table-ref-following"/></a> below defines
valid combinations and their meaning.

<figure id="table-backupStates" class="table">
    <table class="complex data longlastcol">
            <tr>
            <th>[=authData/flags/BE=]</th>
            <th>[=authData/flags/BS=]</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>`0`</td>
            <td>`0`</td>
            <td>
                The credential is a [=single-device credential=].
            </td>
        </tr>
        <tr>
            <td>`0`</td>
            <td>`1`</td>
            <td>
                This combination is not allowed.
            </td>
        </tr>
        <tr>
            <td>`1`</td>
            <td>`0`</td>
            <td>
                The credential is a [=multi-device credential=] and is not currently [=backed up=].
            </td>
        </tr>
        <tr>
            <td>`1`</td>
            <td>`1`</td>
            <td>
                The credential is a [=multi-device credential=] and is currently [=backed up=].
            </td>
        </tr>
    </table>
    <figcaption>
        [=authData/flags/BE=] and [=authData/flags/BS=] [=flag=] combinations
    </figcaption>
</figure>

It is RECOMMENDED that [=[RPS]=] store the most recent value of these [=flags=] with the [=user account=] for future evaluation.

The following is a non-exhaustive list of how [=[RPS]=] might use these [=flags=]:

    - Requiring additional [=authenticators=]:

        When the [=authData/flags/BE=] [=flag=] is set to `0`, the credential is a [=single-device credential=] and the [=generating authenticator=] will never
        allow the credential to be backed up.

        A [=single-device credential=] is not resilient to single device loss. [=[RPS]=] SHOULD ensure that each [=user account=]
        has additional [=authenticators=] [=registration ceremony|registered=] and/or an account recovery process in place.
        For example, the user could be prompted to set up an additional [=authenticator=], such as a [=roaming authenticator=] or an
        [=authenticator=] that is capable of [=multi-device credentials=].

    - Upgrading a user to a password-free account:

        When the [=authData/flags/BS=] [=flag=] changes from `0` to `1`, the [=authenticator=] is signaling that the [=credential=] is backed up and is protected from single device loss.

        The [=[RP]=] MAY choose to prompt the user to upgrade their account security and remove their password.

    - Adding an additional factor after a state change:

        When the [=authData/flags/BS=] [=flag=] changes from `1` to `0`, the [=authenticator=] is signaling that the [=credential=] is no longer backed up,
        and no longer protected from single device loss. This could be the result of the user actions, such as disabling the backup service,
        or errors, such as issues with the backup service.

        When this transition occurs, the [=[RP]=] SHOULD guide the user through a process to validate their other authentication factors.
        If the user does not have another credential for their account, they SHOULD be guided through adding an additional credential
        to ensure they do not lose access to their account. For example, the user could be prompted to set up an additional [=authenticator=],
        such as a [=roaming authenticator=] or an [=authenticator=] that is capable of [=multi-device credentials=].

## Authenticator Taxonomy ## {#sctn-authenticator-taxonomy}

Many use cases are dependent on the capabilities of the [=authenticator=] used.
This section defines some terminology for those capabilities, their most important combinations,
and which use cases those combinations enable.

For example:

- When authenticating for the first time on a particular [=client device=], a [=roaming authenticator=] is typically needed
    since the user doesn't yet have a [=platform credential=] on that [=client device=].
- For subsequent re-authentication on the same [=client device=], a [=platform authenticator=] is likely the most convenient
    since it's built directly into the [=client device=] rather than being a separate device that the user may have to locate.
- For [=second-factor=] authentication in addition to a traditional username and password, any [=authenticator=] can be used.
- Passwordless [=multi-factor=] authentication requires an [=authenticator=]
    capable of [=user verification=], and in some cases also [=discoverable credential capable=].
- A laptop computer might support connecting to [=roaming authenticators=] via USB and Bluetooth,
    while a mobile phone might only support NFC.

The above examples illustrate the the primary <dfn>authenticator type</dfn> characteristics:

- Whether the [=authenticator=] is a [=roaming authenticator|roaming=] or [=platform authenticator|platform=] authenticator
    &mdash; the [=authenticator attachment modality=].
    A [=roaming authenticator=] can support one or more [[#enum-transport|transports]] for communicating with the [=client=].
- Whether the authenticator is capable of [=user verification=] &mdash; the [=authentication factor capability=].
- Whether the authenticator is [=discoverable credential capable=] &mdash; the [=credential storage modality=].

These characteristics are independent and may in theory be combined in any way,
but <a href="#table-authenticatorTypes">Table <span class="table-ref-following"/></a>
lists and names some [=authenticator types=] of particular interest.


<figure id="table-authenticatorTypes" class="table">
    <table class="data">
        <thead>
            <tr>
                <th> [=Authenticator Type=] </th>
                <th> [=Authenticator Attachment Modality=] </th>
                <th> [=Credential Storage Modality=] </th>
                <th> [=Authentication Factor Capability=] </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th> <dfn>Second-factor platform authenticator</dfn> </th>
                <td> [=platform attachment|platform=] </td>
                <td> Either </td>
                <td> [=Single-factor capable=] </td>
            </tr>
            <tr>
                <th> <dfn>User-verifying platform authenticator</dfn> </th>
                <td> [=platform attachment|platform=] </td>
                <td> Either </td>
                <td> [=Multi-factor capable=] </td>
            </tr>
            <tr>
                <th> <dfn>Second-factor roaming authenticator</dfn> </th>
                <td> [=cross-platform attachment|cross-platform=] </td>
                <td> [=server-side credential storage modality|Server-side storage=] </td>
                <td> [=Single-factor capable=] </td>
            </tr>
            <tr>
                <th> <dfn>First-factor roaming authenticator</dfn> </th>
                <td> [=cross-platform attachment|cross-platform=] </td>
                <td> [=client-side credential storage modality|Client-side storage=] </td>
                <td> [=Multi-factor capable=] </td>
            </tr>
        </tbody>
    </table>
    <figcaption>
        Definitions of names for some [=authenticator types=].
    </figcaption>
</figure>

A [=second-factor platform authenticator=] is convenient to use for re-authentication on the same [=client device=],
and can be used to add an extra layer of security both when initiating a new session and when resuming an existing session.
A [=second-factor roaming authenticator=] is more likely to be used
to authenticate on a particular [=client device=] for the first time,
or on a [=client device=] shared between multiple users.

[=User-verifying platform authenticators=] and [=first-factor roaming authenticators=]
enable passwordless [=multi-factor=] authentication.
In addition to the proof of possession of the [=credential private key=],
these authenticators support [=user verification=] as a second [=authentication factor=],
typically a PIN or [=biometric recognition=].
The [=authenticator=] can thus act as two kinds of [=authentication factor=],
which enables [=multi-factor=] authentication while eliminating the need to share a password with the [=[RP]=].

The four combinations not named in <a href="#table-authenticatorTypes">Table <span class="table-ref-previous"/></a>
have less distinguished use cases:


- The [=credential storage modality=] is less relevant for a [=platform authenticator=] than for a [=roaming authenticator=],
    since users using a [=platform authenticator=] can typically be identified by a session cookie or the like
    (i.e., ambient credentials).
- A [=roaming authenticator=] that is [=discoverable credential capable=] but not [=multi-factor capable=]
    can be used for [=single-factor=] authentication without a username,
    where the user is automatically identified by the [=user handle=]
    and possession of the [=credential private key=] is used as the only [=authentication factor=].
    This can be useful in some situations, but makes the user particularly vulnerable to theft of the [=authenticator=].
- A [=roaming authenticator=] that is [=multi-factor capable=] but not [=discoverable credential capable=]
    can be used for [=multi-factor=] authentication, but requires the user to be identified first
    which risks leaking [PII]; see [[#sctn-credential-id-privacy-leak]].

The following subsections define the aspects [=authenticator attachment modality=],
[=credential storage modality=] and [=authentication factor capability=] in more depth.


### <dfn>Authenticator Attachment Modality</dfn> ### {#sctn-authenticator-attachment-modality}

[=Clients=] can communicate with [=authenticators=] using a variety of mechanisms. For example, a [=client=] MAY use a
[=client device=]-specific API to communicate with an [=authenticator=] which is physically bound to a [=client device=]. On the other hand, a
[=client=] can use a variety of standardized cross-platform transport protocols such as Bluetooth (see [[#enum-transport]]) to discover
and communicate with [=cross-platform attachment|cross-platform attached=] [=authenticators=]. We refer to [=authenticators=] that
are part of the [=client device=] as <dfn>platform authenticators</dfn>, while those that are reachable via cross-platform
transport protocols are referred to as <dfn>roaming authenticators</dfn>.

- A [=platform authenticator=] is attached using a [=client device=]-specific transport, called <dfn>platform attachment</dfn>, and is usually not removable from the [=client
    device=]. A [=public key credential=] [=bound credential|bound=] to a [=platform authenticator=] is called a <dfn>platform credential</dfn>.

- A [=roaming authenticator=] is attached using cross-platform transports, called <dfn>cross-platform attachment</dfn>. Authenticators of this class are removable from, and
    can "roam" between, [=client devices=]. A [=public key credential=] [=bound credential|bound=] to a [=roaming authenticator=] is called a <dfn>roaming
    credential</dfn>.

Some [=platform authenticators=] could possibly also act as [=roaming authenticators=] depending on context. For example, a
[=platform authenticator=] integrated into a mobile device could make itself available as a [=roaming authenticator=] via
Bluetooth.
In this case [=clients=] running on the mobile device would recognise the authenticator as a [=platform authenticator=],
while [=clients=] running on a different [=client device=] and communicating with the same authenticator via Bluetooth
would recognize it as a [=roaming authenticator=].

The primary use case for [=platform authenticators=] is to register a particular [=client device=] as a "trusted device",
so the [=client device=] itself acts as a [=something you have=] [=authentication factor=] for future [=authentication=].
This gives the user the convenience benefit
of not needing a [=roaming authenticator=] for future [=authentication ceremonies=], e.g., the user will not have to dig around in
their pocket for their key fob or phone.

Use cases for [=roaming authenticators=] include:
[=authentication|authenticating=] on a new [=client device=] for the first time,
on rarely used [=client devices=], [=client devices=] shared between multiple users,
or [=client devices=] that do not include a [=platform authenticator=];
and when policy or preference dictates that the [=authenticator=] be kept separate from the [=client devices=] it is used with.
A [=roaming authenticator=] can also be used to hold
backup [=public key credential|credentials=] in case another [=authenticator=] is lost.


### Credential Storage Modality ### {#sctn-credential-storage-modality}

An [=authenticator=] can store a [=public key credential source=] in one of two ways:

 1. In persistent storage embedded in the [=authenticator=], [=client=] or [=client device=], e.g., in a secure element.
    This is a technical requirement for a [=client-side discoverable public key credential source=].

 1. By encrypting (i.e., wrapping) the [=credential private key=] such that only this [=authenticator=] can decrypt (i.e., unwrap) it and letting the resulting
    ciphertext be the [=credential ID=] for the [=public key credential source=]. The [=credential ID=] is stored by the [=[RP]=]
    and returned to the [=authenticator=] via the {{PublicKeyCredentialRequestOptions/allowCredentials}} option of
    {{CredentialsContainer/get()}}, which allows the [=authenticator=] to decrypt and use the [=credential private key=].

    This enables the [=authenticator=] to have unlimited storage capacity for [=credential private keys=], since the encrypted
    [=credential private keys=] are stored by the [=[RP]=] instead of by the [=authenticator=] - but it means that a
    [=credential=] stored in this way must be retrieved from the [=[RP]=] before the [=authenticator=] can use it.

Which of these storage strategies an [=authenticator=] supports defines the [=authenticator=]'s <dfn>credential storage
modality</dfn> as follows:

- An [=authenticator=] has the <dfn>client-side credential storage modality</dfn> if it supports [=client-side discoverable public key
    credential sources=]. An [=authenticator=] with [=client-side credential storage modality=] is also called <dfn>discoverable
    credential capable</dfn>.

- An [=authenticator=] has the <dfn>server-side credential storage modality</dfn> if it does not have the [=client-side credential storage
    modality=], i.e., it only supports storing [=credential private keys=] as a ciphertext in the [=credential ID=].

Note that a [=discoverable credential capable=] [=authenticator=] MAY support both storage strategies. In this case, the [=authenticator=] MAY
at its discretion use different storage strategies for different [=public key credential|credentials=], though subject to the
{{AuthenticatorSelectionCriteria/residentKey}} or {{AuthenticatorSelectionCriteria/requireResidentKey}} options of
{{CredentialsContainer/create()}}.


### <dfn>Authentication Factor Capability</dfn> ### {#sctn-authentication-factor-capability}

There are three broad classes of [=authentication factors=] that can be used to prove an identity during an [=authentication
ceremony=]: [=something you have=], [=something you know=] and [=something you are=]. Examples include a physical key, a password,
and a fingerprint, respectively.

All [=[WAA]s=] belong to the [=something you have=] class, but an [=authenticator=] that supports [=user
verification=] can also act as one or two additional kinds of [=authentication factor=]. For example, if the [=authenticator=] can
verify a PIN, the PIN is [=something you know=], and a [=biometric authenticator=] can verify [=something you are=]. Therefore, an
[=authenticator=] that supports [=user verification=] is <dfn>multi-factor capable</dfn>. Conversely, an [=authenticator=] that is
not [=multi-factor capable=] is <dfn>single-factor capable</dfn>. Note that a single [=multi-factor capable=] [=authenticator=]
could support several modes of [=user verification=], meaning it could act as all three kinds of [=authentication factor=].

Although [=user verification=] is performed locally on the [=authenticator=] and not by the [=[RP]=], the [=authenticator=]
indicates if [=user verification=] was performed by setting the [=authData/flags/UV=] [=flag=] in the signed response returned to the [=[RP]=].
The [=[RP]=] can therefore use the [=authData/flags/UV=] [=flag=] to verify that additional [=authentication factors=] were used in a
[=registration=] or [=authentication ceremony=]. The authenticity of the [=authData/flags/UV=] [=flag=] can in turn be assessed by inspecting the
[=authenticator=]'s [=attestation statement=].


## <dfn>Authenticator Operations</dfn> ## {#sctn-authenticator-ops}

A [=[WAC]=] MUST connect to an authenticator in order to invoke any of the operations of that authenticator. This connection
defines an <dfn>authenticator session</dfn>. An authenticator must maintain isolation between sessions. It may do this by only allowing one
session to exist at any particular time, or by providing more complicated session management.

The following operations can be invoked by the client in an authenticator session.


### Lookup Credential Source by Credential ID Algorithm ### {#sctn-op-lookup-credsource-by-credid}

The result of <dfn for="credential id">looking up</dfn> a [=credential id=] |credentialId| in an [=authenticator=]
|authenticator| is the result of the following algorithm:
1. If |authenticator| can decrypt |credentialId| into a [=public key credential source=] |credSource|:
    1. Set |credSource|.[=public key credential source/id=] to |credentialId|.
    1. Return |credSource|.
1. [=map/For each=] [=public key credential source=] |credSource| of |authenticator|'s [=credentials map=]:
    1. If |credSource|.[=public key credential source/id=] is |credentialId|, return |credSource|.
1. Return `null`.


### The <dfn>authenticatorMakeCredential</dfn> Operation ### {#sctn-op-make-cred}

It takes the following input parameters:

<!-- @@EDITOR-ANCHOR-01: KEEP THIS LIST SYNC'D WITH OTHER LOCATIONS WITH THIS TAG -->
: |hash|
:: The [=hash of the serialized client data=], provided by the client.
: |rpEntity|
:: The [=[RP]=]'s {{PublicKeyCredentialRpEntity}}.
: |userEntity|
:: The [=user account's=] {{PublicKeyCredentialUserEntity}}, containing the [=user handle=] given by the [=[RP]=].
: |requireResidentKey|
:: The [=effective resident key requirement for credential creation=], a Boolean value determined by the [=client=].
: |requireUserPresence|
:: The constant Boolean value [TRUE].
    It is included here as a pseudo-parameter to simplify applying this abstract authenticator model to implementations that may
    wish to make a [=test of user presence=] optional although WebAuthn does not.
: |requireUserVerification|
:: The [=effective user verification requirement for credential creation=], a Boolean value determined by the [=client=].
: |credTypesAndPubKeyAlgs|
:: A sequence of pairs of {{PublicKeyCredentialType}} and public key algorithms ({{COSEAlgorithmIdentifier}}) requested by the
    [=[RP]=]. This sequence is ordered from most preferred to least preferred. The [=authenticator=] makes a best-effort to create the most
    preferred credential that it can.
: |excludeCredentialDescriptorList|
:: An OPTIONAL list of {{PublicKeyCredentialDescriptor}} objects provided by the [=[RP]=] with the intention that, if any of
    these are known to the authenticator, it SHOULD NOT create a new credential. |excludeCredentialDescriptorList| contains a
    list of known credentials.
: |enterpriseAttestationPossible|
:: A Boolean value that indicates that individually-identifying attestation MAY be returned by the authenticator.
: |attestationFormats|
:: A sequence of strings that expresses the [=[RP]=]'s preference for attestation statement formats, from most to least preferable. If the [=authenticator=] returns [=attestation=], then it makes a best-effort attempt to use the most preferable format that it supports.
: |extensions|
:: A [=CBOR=] [=map=] from [=extension identifiers=] to their [=authenticator extension inputs=], created by the [=client=] based on
    the extensions requested by the [=[RP]=], if any.

Note: Before performing this operation, all other operations in progress in the [=authenticator session=] MUST be aborted by
running the [=authenticatorCancel=] operation.

When this operation is invoked, the [=authenticator=] MUST perform the following procedure:
1. Check if all the supplied parameters are syntactically well-formed and of the correct length. If not, return an error code
    equivalent to "{{UnknownError}}" and terminate the operation.
1. Check if at least one of the specified combinations of {{PublicKeyCredentialType}} and cryptographic parameters in
    |credTypesAndPubKeyAlgs| is supported.
    If not, return an error code equivalent to "{{NotSupportedError}}" and terminate the operation.

1. [=list/For each=] |descriptor| of |excludeCredentialDescriptorList|:

    1.  If [=credential id/looking up=] <code>|descriptor|.{{PublicKeyCredentialDescriptor/id}}</code> in this authenticator
        returns non-null, and the returned [=list/item=]'s [=RP ID=] and [=public key credential source/type=] match
        <code>|rpEntity|.{{PublicKeyCredentialRpEntity/id}}</code> and
        <code>|excludeCredentialDescriptorList|.{{PublicKeyCredentialDescriptor/type}}</code> respectively,
        then collect an [=authorization gesture=] confirming [=user
        consent=] for creating a new credential. The [=authorization gesture=] MUST include a [=test
        of user presence=]. If the user
        <dl class="switch">
            :   confirms consent to create a new credential
            ::  return an error code equivalent to "{{InvalidStateError}}" and terminate the operation.

            :   does not consent to create a new credential
            ::  return an error code equivalent to "{{NotAllowedError}}" and terminate the operation.
        </dl>

        Note: The purpose of this [=authorization gesture=] is not to proceed with creating a credential,
        but for privacy reasons to authorize disclosure of the fact that
        <code>|descriptor|.{{PublicKeyCredentialDescriptor/id}}</code> is [=bound credential|bound=] to this [=authenticator=].
        If the user consents, the [=client=] and [=[RP]=] can detect this and guide the user to use a different [=authenticator=].
        If the user does not consent,
        the [=authenticator=] does not reveal that <code>|descriptor|.{{PublicKeyCredentialDescriptor/id}}</code>
        is [=bound credential|bound=] to it,
        and responds as if the user simply declined consent to create a credential.

1. If |requireResidentKey| is [TRUE] and the authenticator cannot store a [=client-side discoverable public key credential source=],
    return an error code equivalent to "{{ConstraintError}}" and terminate the operation.
1. If |requireUserVerification| is [TRUE] and the authenticator cannot perform [=user verification=], return an error code
    equivalent to "{{ConstraintError}}" and terminate the operation.

<!-- Note: this next step is actually a top-level step, but bikeshed wanted it indented this much in order to render it as
a numbered step. If outdented, it (today) is rendered as a bullet in the midst of a numbered list :-/
-->
    <li id='op-makecred-step-user-consent'>
        Collect an [=authorization gesture=] confirming [=user consent=] for creating a new credential.
        The prompt for the [=authorization gesture=] is shown by the
        authenticator if it has its own output capability, or by the user agent otherwise. The prompt SHOULD display
        <code>|rpEntity|.{{PublicKeyCredentialRpEntity/id}}</code>, <code>|rpEntity|.{{PublicKeyCredentialEntity/name}}</code>,
        <code>|userEntity|.{{PublicKeyCredentialEntity/name}}</code> and
        <code>|userEntity|.{{PublicKeyCredentialUserEntity/displayName}}</code>, if possible.

        If |requireUserVerification| is [TRUE], the [=authorization gesture=] MUST include [=user verification=].

        If |requireUserPresence| is [TRUE], the [=authorization gesture=] MUST include a [=test of user presence=].

        If the user does not [=user consent|consent=] or if [=user verification=] fails, return an error code equivalent to
        "{{NotAllowedError}}" and terminate the operation.
    </li>

1. Once the [=authorization gesture=] has been completed and [=user consent=] has been obtained, generate a new credential object:
    1. Let (|publicKey|, |privateKey|) be a new pair of cryptographic keys using the combination of {{PublicKeyCredentialType}}
        and cryptographic parameters represented by the first [=list/item=] in |credTypesAndPubKeyAlgs| that is supported by
        this authenticator.
    1. Let |userHandle| be <code>|userEntity|.{{PublicKeyCredentialUserEntity/id}}</code>.
    1. Let |credentialSource| be a new [=public key credential source=] with the fields:
        <dl link-for="public key credential source">
            : [=type=]
            :: {{PublicKeyCredentialType/public-key}}.
            : [=privateKey=]
            :: |privateKey|
            : [=rpId=]
            :: <code>|rpEntity|.{{PublicKeyCredentialRpEntity/id}}</code>
            : [=userHandle=]
            :: |userHandle|
            : [=otherUI=]
            :: Any other information the authenticator chooses to include.
        </dl>
    1. If |requireResidentKey| is [TRUE] or the authenticator chooses to create a [=client-side discoverable public key credential source=]:
        1. Let |credentialId| be a new [=credential id=].
        1. Set |credentialSource|.[=public key credential source/id=] to |credentialId|.
        1. Let |credentials| be this authenticator's [=credentials map=].
        1. [=map/Set=] |credentials|[(<code>|rpEntity|.{{PublicKeyCredentialRpEntity/id}}</code>, |userHandle|)] to |credentialSource|.
    1. Otherwise:
        1. Let |credentialId| be the result of serializing and encrypting |credentialSource| so that only this authenticator can
            decrypt it.
1. If any error occurred while creating the new credential object, return an error code equivalent to "{{UnknownError}}" and
    terminate the operation.
1. Let |processedExtensions| be the result of [=authenticator extension processing=] [=map/for each=] supported [=extension
    identifier=] → [=authenticator extension input=] in |extensions|.
1. If the [=authenticator=]:
    <dl class="switch">
        : is a U2F device
        :: let the [=signature counter=] value for the new credential be zero. (U2F devices may support signature counters but do not return a counter when making a credential. See [[FIDO-U2F-Message-Formats]].)

        : supports a global [=signature counter=]
        ::  Use the global [=signature counter=]'s actual value when generating
              [=authenticator data=].

        : supports a per credential [=signature counter=]
        :: allocate the counter, associate it with the new credential, and initialize the counter value as zero.

        : does not support a [=signature counter=]
        :: let the [=signature counter=] value for the new credential be constant at zero.
    </dl>

1. Let |attestedCredentialData| be the [=attested credential data=] byte array including the |credentialId| and |publicKey|.
1. Let |attestationFormat| be the first supported [=attestation statement format identifier=] from |attestationFormats|, taking into account |enterpriseAttestationPossible|.
    If |attestationFormats| contains no supported value, then let |attestationFormat| be the [=attestation statement format identifier=] most preferred by this authenticator.
1. Let |authenticatorData| [=perform the following steps to generate an authenticator data structure|be the byte array=] specified in [[#sctn-authenticator-data]], including |attestedCredentialData| as the
    <code>[=attestedCredentialData=]</code> and |processedExtensions|, if any, as the
    <code>[=authData/extensions=]</code>.
1. Create an [=attestation object=] for the new credential using the procedure specified in
    [[#sctn-generating-an-attestation-object]], the [=attestation statement format=] |attestationFormat|, and the values |authenticatorData|
    and |hash|, as well as {{enterprise|taking into account}} the value of |enterpriseAttestationPossible|. For more details on attestation, see [[#sctn-attestation]].

On successful completion of this operation, the authenticator returns the [=attestation object=] to the client.


### The <dfn>authenticatorGetAssertion</dfn> Operation ### {#sctn-op-get-assertion}

It takes the following input parameters:

: |rpId|
:: The caller's [=RP ID=], as <a href='#GetAssn-DetermineRpId'>determined</a> by the user agent and the client.
: |hash|
:: The [=hash of the serialized client data=], provided by the client.
: |allowCredentialDescriptorList|
:: An OPTIONAL [=list=] of {{PublicKeyCredentialDescriptor}}s describing credentials acceptable to the [=[RP]=] (possibly filtered
    by the client), if any.
: |requireUserPresence|
:: The constant Boolean value [TRUE].
    It is included here as a pseudo-parameter to simplify applying this abstract authenticator model to implementations that may
    wish to make a [=test of user presence=] optional although WebAuthn does not.
: |requireUserVerification|
:: The [=effective user verification requirement for assertion=], a Boolean value provided by the client.
: |enterpriseAttestationPossible|
:: A Boolean value that indicates that individually-identifying attestation MAY be returned by the authenticator.
: |attestationFormats|
:: A sequence of strings that expresses the [=[RP]=]'s preference for attestation statement formats, from most to least preferable. If the [=authenticator=] returns [=attestation=], then it makes a best-effort attempt to use the most preferable format that it supports.
: |extensions|
:: A [=CBOR=] [=map=] from [=extension identifiers=] to their [=authenticator extension inputs=], created by the client based on
    the extensions requested by the [=[RP]=], if any.

Note: Before performing this operation, all other operations in progress in the [=authenticator session=] MUST be aborted by running the [=authenticatorCancel=] operation.

When this method is invoked, the [=authenticator=] MUST perform the following procedure:

1. Check if all the supplied parameters are syntactically well-formed and of the correct length. If not, return an error code
    equivalent to "{{UnknownError}}" and terminate the operation.
1. Let |credentialOptions| be a new empty [=set=] of [=public key credential sources=].
1. If |allowCredentialDescriptorList| was supplied, then [=list/for each=] |descriptor| of |allowCredentialDescriptorList|:
    1. Let |credSource| be the result of [=looking up=] <code>|descriptor|.{{PublicKeyCredentialDescriptor/id}}</code> in this
        authenticator.
    1. If |credSource| is not `null`, [=set/append=] it to |credentialOptions|.
1. Otherwise (|allowCredentialDescriptorList| was not supplied), [=map/for each=] <var ignore>key</var> → |credSource| of this
    authenticator's [=credentials map=], [=set/append=] |credSource| to |credentialOptions|.
1. [=list/Remove=] any items from |credentialOptions| whose [=public key credential source/rpId=] is not equal to
    |rpId|.
1. If |credentialOptions| is now empty, return an error code equivalent to "{{NotAllowedError}}" and terminate the operation.

1. Prompt the user to select a [=public key credential source=] |selectedCredential| from |credentialOptions|.
    Collect an [=authorization gesture=] confirming [=user consent=] for using |selectedCredential|.
    The prompt for the [=authorization gesture=] may be shown
    by the [=authenticator=] if it has its own output capability, or by the user agent otherwise.

    If |requireUserVerification| is [TRUE], the [=authorization gesture=] MUST include [=user verification=].

    If |requireUserPresence| is [TRUE], the [=authorization gesture=] MUST include a
        [=test of user presence=].

    If the user does not [=user consent|consent=], return an error code equivalent to
    "{{NotAllowedError}}" and terminate the operation.

1. Let |processedExtensions| be the result of [=authenticator extension processing=] [=map/for each=] supported [=extension
    identifier=] → [=authenticator extension input=] in |extensions|.
1. Increment the credential associated
    [=signature counter=] or the global [=signature counter=] value, depending on
    which approach is implemented by the [=authenticator=], by some positive value.
    If the [=authenticator=] does not implement a [=signature counter=], let the [=signature counter=] value remain constant at
    zero.
1. If |attestationFormats|:
    <dl class="switch">
        : is [=list/is not empty|not empty=]
        :: let |attestationFormat| be the first supported [=attestation statement format=] from |attestationFormats|, taking into account |enterpriseAttestationPossible|. If none are supported, fallthrough to:

        : is [=list/is empty|empty=]
        :: let |attestationFormat| be the [=attestation statement format=] most preferred by this authenticator. If it does not support attestation during assertion then let this be `none`.
    </dl>
1. Let |authenticatorData| [=perform the following steps to generate an authenticator data structure|be the byte array=]
    specified in [[#sctn-authenticator-data]] including |processedExtensions|, if any, as
    the <code>[=authData/extensions=]</code> and excluding <code>[=attestedCredentialData=]</code>. This |authenticatorData| MUST include [=attested credential data=] if, and only if, |attestationFormat| is not `none`.
1. Let |signature| be the [=assertion signature=] of the concatenation <code>|authenticatorData| || |hash|</code> using the
    [=public key credential source/privateKey=] of |selectedCredential| as shown in <a href="#fig-signature">Figure <span class="figure-num-following"/></a>, below. A simple,
    undelimited
    concatenation is safe to use here because the [=authenticator data=] describes its own length. The [=hash of the serialized
    client data=] (which potentially has a variable length) is always the last element.

    <figure id="fig-signature">
        <img src="images/fido-signature-formats-figure2.svg"/>
        <figcaption>Generating an [=assertion signature=].</figcaption>
    </figure>

1. The |attestationFormat| is not `none` then create an [=attestation object=] for the new credential using the procedure specified in
    [[#sctn-generating-an-attestation-object]], the [=attestation statement format=] |attestationFormat|, and the values |authenticatorData|
    and |hash|, as well as {{enterprise|taking into account}} the value of |enterpriseAttestationPossible|. For more details on attestation, see [[#sctn-attestation]].

1. If any error occurred then return an error code equivalent to "{{UnknownError}}" and terminate the operation.

<!-- Note: this next step is actually a top-level step, but bikeshed wanted it indented this much in order to render it as
a numbered step. If outdented, it (today) is rendered as a bullet in the midst of a numbered list :-/
-->
    <li id='authenticatorGetAssertion-return-values'>
        Return to the user agent:
            - |selectedCredential|.[=public key credential source/id=], if either a list of credentials
                (i.e., |allowCredentialDescriptorList|) of length 2 or greater was
                supplied by the client, or no such list was supplied.

                    Note: If, within |allowCredentialDescriptorList|, the client supplied exactly one credential and it was successfully employed, then its
                        [=credential ID=] is not returned since the client already knows it. This saves transmitting these bytes over
                        what may be a constrained connection in what is likely a common case.

            - |authenticatorData|
            - |signature|
            - The attestation object, if an [=attestation object=] was created for this assertion.
            - |selectedCredential|.[=public key credential source/userHandle=]

                    Note: the returned [=public key credential source/userHandle=] value may be `null`, see:
                        [=assertionCreationData/userHandleResult=].
    </li>

If the [=authenticator=] cannot find any [=public key credential|credential=] corresponding to the specified [=[RP]=] that
matches the specified criteria, it terminates the operation and returns an error.


### The <dfn>authenticatorCancel</dfn> Operation ### {#sctn-op-cancel}

This operation takes no input parameters and returns no result.

When this operation is invoked by the client in an [=authenticator session=], it has the effect of terminating any
[=authenticatorMakeCredential=] or [=authenticatorGetAssertion=] operation currently in progress in that authenticator
session. The authenticator stops prompting for, or accepting, any user input related to authorizing the canceled operation. The
client ignores any further responses from the authenticator for the canceled operation.

This operation is ignored if it is invoked in an [=authenticator session=] which does not have an [=authenticatorMakeCredential=]
or [=authenticatorGetAssertion=] operation currently in progress.


### The <dfn>silentCredentialDiscovery</dfn> operation ### {#sctn-op-silent-discovery}

This is an OPTIONAL operation authenticators MAY support to enable {{CredentialMediationRequirement/conditional}}
[=user mediation=].

It takes the following input parameter:

: |rpId|
:: The caller's [=RP ID=], as <a href='#GetAssn-DetermineRpId'>determined</a> by the [=client=].

When this operation is invoked, the [=authenticator=] MUST perform the following procedure:

1. Let |collectedDiscoverableCredentialMetadata| be a new [=list=] whose [=list/items=] are
    <dfn>DiscoverableCredentialMetadata</dfn> [=structs=] with the following [=struct/items=]:

    <dl dfn-for="DiscoverableCredentialMetadata">
        :   <dfn>type</dfn>
        ::  A {{PublicKeyCredentialType}}.

        :   <dfn>id</dfn>
        ::  A [=Credential ID=].

        :   rpId
        ::  A [=Relying Party Identifier=].

        :   userHandle
        ::  A [=user handle=].

        :   <dfn>otherUI</dfn>
        ::  Other information used by the [=authenticator=] to inform its UI.
    </dl>

1. [=map/For each=] [=public key credential source=] |credSource| of |authenticator|'s [=credentials map=]:

    1. If |credSource| is not a [=client-side discoverable credential=], [=iteration/continue=].

    1. If |credSource|.[=public key credential source/rpId=] is not |rpId|, [=iteration/continue=].

    1. Let |discoveredCredentialMetadata| be a new [=DiscoverableCredentialMetadata=] [=struct=] whose [=struct/items=]
        are copies of |credSource|'s [=public key credential source/type=], [=public key credential source/id=],
        [=public key credential source/rpId=], [=public key credential source/userHandle=] and
        [=public key credential source/otherUI=].

    1. [=list/Append=] |discoveredCredentialMetadata| to |collectedDiscoverableCredentialMetadata|.

1. Return |collectedDiscoverableCredentialMetadata|.


## String Handling ## {#sctn-strings}

Authenticators may be required to store arbitrary strings chosen by a [=[RP]=], for example the {{PublicKeyCredentialEntity/name}} and {{PublicKeyCredentialUserEntity/displayName}} in a {{PublicKeyCredentialUserEntity}}. This section discusses some practical consequences of handling arbitrary strings that may be presented to humans.

### String Truncation ### {#sctn-strings-truncation}

Each arbitrary string in the API will have some accommodation for the potentially limited resources available to an [=authenticator=]. If string value truncation is the chosen accommodation then authenticators MAY truncate in order to make the string fit within a length equal or greater than the specified minimum supported length. Such truncation SHOULD also respect UTF-8 sequence boundaries or [=grapheme cluster=] boundaries [[UTR29]]. This defines the maximum truncation permitted and authenticators MUST NOT truncate further.

For example, in <a href="#fig-stringTruncation">figure <span class="figure-num-following"/></a> the string is 65 bytes long. If truncating to 64 bytes then the final 0x88 byte must be removed purely because of space reasons. Since that leaves a partial UTF-8 sequence the remainder of that sequence may also be removed. Since that leaves a partial [=grapheme cluster=] an authenticator may remove the remainder of that cluster.

<figure id="fig-stringTruncation">
    <img src="images/string-truncation.svg"/>
    <figcaption>The end of a UTF-8 encoded string showing the positions of different truncation boundaries.</figcaption>
</figure>

[=Conforming User Agents=] are responsible for ensuring that the authenticator behavior observed by [=[RPS]=] conforms to this specification with respect to string handling. For example, if an authenticator is known to behave incorrectly when asked to store large strings, the user agent SHOULD perform the truncation for it in order to maintain the model from the point of view of the [=[RP]=]. User-agents that do this SHOULD truncate at [=grapheme cluster=] boundaries.

Truncation based on UTF-8 sequences alone may cause a [=grapheme cluster=] to be truncated. This could make the grapheme cluster render as a different glyph, potentially changing the meaning of the string, instead of removing the glyph entirely.

In addition to that, truncating on byte boundaries alone causes a known issue that user agents should be aware of: if the authenticator is using [[!FIDO-CTAP]] then future messages from the authenticator may contain invalid CBOR since the value is typed as a CBOR string and thus is required to be valid UTF-8. User agents are tasked with handling this to avoid burdening authenticators with understanding character encodings and Unicode character properties. Thus, when dealing with [=authenticators=], user agents SHOULD:

1. Ensure that any strings sent to authenticators are validly encoded.
1. Handle the case where strings have been truncated resulting in an invalid encoding. For example, any partial code point at the end may be dropped or replaced with [U+FFFD](http://unicode.org/cldr/utility/character.jsp?a=FFFD).

### Language and Direction Encoding ### {#sctn-strings-langdir}

In order to be correctly displayed in context, the language and base direction of a string [may be required](https://www.w3.org/TR/string-meta/#why-is-this-important). Strings in this API may have to be written to fixed-function [=authenticators=] and then later read back and displayed on a different platform. Thus language and direction metadata is encoded in the string itself to ensure that it is transported atomically.

To encode language and direction metadata in a string that is documented as permitting it, suffix its code points with two sequences of code points:

The first encodes a [=language tag=] with the code point U+E0001 followed by the ASCII values of the [=language tag=] each shifted up by U+E0000. For example, the [=language tag=] “en-US” becomes the code points U+E0001, U+E0065, U+E006E, U+E002D, U+E0055, U+E0053.

The second consists of a single code point which is either U+200E (“LEFT-TO-RIGHT MARK”), U+200F (“RIGHT-TO-LEFT MARK”), or U+E007F (“CANCEL TAG”). The first two can be used to indicate directionality but SHOULD only be used when neccessary to produce the correct result. (E.g. an RTL string that starts with LTR-strong characters.) The value U+E007F is a direction-agnostic indication of the end of the [=language tag=].

So the string “حبیب الرحمان” could have two different DOMString values, depending on whether the language was encoded or not. (Since the direction is unambiguous a directionality marker is not needed in this example.)

   * Unadorned string: U+FEA2, U+FE92, U+FBFF, U+FE91, U+20, U+FE8E, U+FEDF, U+FEAE, U+FEA4, U+FEE3, U+FE8E, U+FEE7
   * With language “ar-SA” encoded: U+FEA2, U+FE92, U+FBFF, U+FE91, U+20, U+FE8E, U+FEDF, U+FEAE, U+FEA4, U+FEE3, U+FE8E, U+FEE7, U+E0001, U+E0061, U+E0072, U+E002D, U+E0053, U+E0041, U+E007F

Consumers of strings that may have language and direction encoded should be aware that truncation could truncate a [=language tag=] into a different, but still valid, language. The final directionality marker or CANCEL TAG code point provide an unambigous indication of truncation.

## Attestation ## {#sctn-attestation}

[=Authenticators=] SHOULD also provide some form of [=attestation=], if possible.
If an authenticator does, the basic requirement is that the [=authenticator=] can
produce, for each [=credential public key=], an [=attestation statement=] verifiable by the [=[WRP]=]. Typically, this
[=attestation statement=] contains a signature by an [=attestation private key=] over the attested [=credential public key=] and
a challenge, as well as a certificate or similar data providing provenance information for the [=attestation public key=],
enabling the [=[RP]=] to make a trust decision. However, if an [=attestation key pair=] is not available, then the authenticator
MAY either perform [=self attestation=] of the [=credential public key=] with the corresponding [=credential private key=],
or otherwise perform [=None|no attestation=].

All this information is returned by [=authenticators=] any time a new [=public key credential=] is generated, and optionally when exercised, in the overall form of an
<dfn>attestation object</dfn>. The relationship of the [=attestation object=] with [=authenticator data=] (containing
[=attested credential data=]) and the [=attestation statement=] is illustrated in <a href="#fig-attStructs">figure <span class="figure-num-following"/></a>, below.

If an [=authenticator=] employs [=self attestation=] or [=None|no attestation=], then no provenance information is provided
for the [=[RP]=] to base a trust decision on.
In these cases, the [=authenticator=] provides no guarantees about its operation to the [=[RP]=].

<figure id="fig-attStructs">
    <img src="images/fido-attestation-structures.svg"/>
    <figcaption>[=Attestation object=] layout illustrating the included [=authenticator data=] from a {{CredentialsContainer/create()|create()}} operation (containing [=attested credential
    data=]) and the [=attestation statement=].</figcaption>
</figure>
<div class="note">
  This figure illustrates only the `packed` [=attestation statement format=]. Several additional [=attestation statement
  formats=] are defined in [[#sctn-defined-attestation-formats]].
</div>

An important component of the [=attestation object=] is the <dfn>attestation statement</dfn>. This is a specific type of signed
data object, containing statements about a [=public key credential=] itself and the [=authenticator=] that created it. It
contains an [=attestation signature=] created using the key of the attesting authority (except for the case of [=self
attestation=], when it is created using the [=credential private key=]). In order to correctly interpret an [=attestation
statement=], a [=[RP]=] needs to understand these two aspects of [=attestation=]:

1. The <dfn>attestation statement format</dfn> is the manner in which the signature is represented and the various contextual
    bindings are incorporated into the attestation statement by the [=authenticator=]. In other words, this defines the
    syntax of the statement. Various existing components and OS platforms (such as TPMs and the Android OS) have previously defined
    [=attestation statement formats=]. This specification supports a variety of such formats in an extensible way, as defined in
    [[#sctn-attestation-formats]]. The formats themselves are identified by strings, as described in [[#sctn-attstn-fmt-ids]].

2. The <dfn>attestation type</dfn> defines the semantics of [=attestation statements=] and their underlying trust models.
    Specifically, it defines how a [=[RP]=] establishes trust in a particular [=attestation statement=], after verifying that it
    is cryptographically valid. This specification supports a number of [=attestation types=], as described in
    [[#sctn-attestation-types]].

In general, there is no simple mapping between [=attestation statement formats=] and [=attestation types=]. For example, the
"packed" [=attestation statement format=] defined in [[#sctn-packed-attestation]] can be used in conjunction with all [=attestation
types=], while other formats and types have more limited applicability.

The privacy, security and operational characteristics of [=attestation=] depend on:
- The [=attestation type=], which determines the trust model,
- The [=attestation statement format=], which MAY constrain the strength of the [=attestation=] by limiting what can be
    expressed in an [=attestation statement=], and
- The characteristics of the individual [=authenticator=], such as its construction, whether part or all of it runs in a secure
    operating environment, and so on.

The [=attestation type=] and [=attestation statement format=] is chosen by the [=authenticator=];
[=[RPS]=] can only signal their preferences by setting the {{PublicKeyCredentialCreationOptions/attestation}} and {{PublicKeyCredentialCreationOptions/attestationFormats}} parameters, or those with the same names in {{PublicKeyCredentialRequestOptions}}.

It is expected that most [=authenticators=] will support a small number of [=attestation types=] and [=attestation statement
formats=], while [=[RPS]=] will decide what [=attestation types=] are acceptable to them by policy. [=[RPS]=] will also need to
understand the characteristics of the [=authenticators=] that they trust, based on information they have about these
[=authenticators=]. For example, the FIDO Metadata Service [[FIDOMetadataService]] provides one way to access such information.

### Attestation in assertions ### {#sctn-attestation-in-assertions}

Attestation is most commonly provided during credential creation. However, if supported by the authenticator and requested by the [=[RP]=] using the {{PublicKeyCredentialRequestOptions/attestation}} parameter, attestation MAY be provided in [=assertions=].

Attestations in [=assertions=] could be helpful in at least the following situations:

1. For [=multi-device credentials=], the [=generating authenticator=] may have returned a meaningfully different attestation than the authenticator currently exercising the credential. Thus returning an attestation for each use of the credential allows the [=[RP]=] to observe these changes.
1. If the [=attestation statement format=] involves a 3rd-party attesting to the state of the authenticator, then returning an attestation with each use of the credential allows for the continued good health of the authenticator to be attested.

[=Attestation objects=] provided in an {{AuthenticatorAttestationResponse}} structure (i.e. as the result of a {{CredentialsContainer/create()|create()}} operation) contain at least the three keys shown in [the previous figure](#fig-attStructs): `fmt`, `attStmt`, and `authData`. The `authData` key is not included when an [=attestation object=] is provided in an {{AuthenticatorAssertionResponse}} (i.e. as the result of a {{CredentialsContainer/get()|get()}} operation). That is because the [=authenticator data=] is provided directly in the {{AuthenticatorAssertionResponse/authenticatorData}} member of the {{AuthenticatorAssertionResponse}}. Otherwise, processing of the [=attestation object=] is identical.

### Attested Credential Data ### {#sctn-attested-credential-data}

<dfn>Attested credential data</dfn> is a variable-length byte array added to the [=authenticator data=] when generating an [=attestation
object=] for a credential. Its format is shown in <a href="#table-attestedCredentialData">Table <span class="table-ref-following"/></a>.

<figure id="table-attestedCredentialData" class="table">
    <table class="complex data longlastcol" dfn-for="authData/attestedCredentialData">
        <tr>
            <th>Name</th>
            <th>Length (in bytes)</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>aaguid</dfn></td>
            <td>16</td>
            <td>The AAGUID of the authenticator.</td>
        </tr>
        <tr>
            <td><dfn>credentialIdLength</dfn></td>
            <td>2</td>
            <td>Byte length <strong>L</strong> of [=credentialId=], 16-bit unsigned big-endian integer. Value MUST be &le; 1023.</td>
        </tr>
        <tr>
            <td><dfn>credentialId</dfn></td>
            <td>L</td>
            <td>[=Credential ID=]</td>
        </tr>
        <tr>
            <td><dfn>credentialPublicKey</dfn></td>
            <td>variable</td>
            <td>
                The [=credential public key=] encoded in COSE_Key format,
                as defined in [=Section 7=] of [[!RFC9052]], using the [=CTAP2 canonical CBOR encoding form=].
                The COSE_Key-encoded [=credential public key=] MUST contain the "alg" parameter and MUST NOT
                contain any other OPTIONAL parameters. The "alg" parameter MUST contain a {{COSEAlgorithmIdentifier}} value.
                The encoded [=credential public key=] MUST also contain any additional REQUIRED parameters stipulated by the
                relevant key type specification, i.e., REQUIRED for the key type "kty" and algorithm "alg"
                (see [=RFC9053/Section 2=] of [[!RFC9053]]).
            </td>
        </tr>
    </table>
    <figcaption>
        [=Attested credential data=] layout. The names in the Name column are only for reference within this document, and are not
        present in the actual representation of the [=attested credential data=].
    </figcaption>
</figure>

Attested credential data is always present in any [=authenticator data=] that results from a {{CredentialsContainer/create()|create()}} operation. It MUST be present in an [=authenticator data=] resulting from a {{CredentialsContainer/get()|get()}} operation if, and only if, the {{AuthenticatorAssertionResponse/attestationObject}} attribute is present in the assertion result.

#### Examples of `credentialPublicKey` Values Encoded in COSE_Key Format #### {#sctn-encoded-credPubKey-examples}

This section provides examples of COSE_Key-encoded Elliptic Curve and RSA public keys for the ES256, PS256, and RS256
signature algorithms. These examples adhere to the rules defined above for the [=credentialPublicKey=] value, and are presented in CDDL [[!RFC8610]] for clarity.

[=Section 7=] of [[!RFC9052]] defines the general framework for all COSE_Key-encoded keys.
Specific key types for specific algorithms are defined in [[!RFC9053]] as well as in other specifications,
as noted below.

Below is an example of a COSE_Key-encoded Elliptic Curve public key in EC2 format (see [=Section 7.1=] of [[!RFC9053]]),
on the P-256 curve, to be used with the ES256 signature
algorithm (ECDSA w/ SHA-256, see [=Section 2.1=] of [[!RFC9053]]):

<pre class="example" highlight="json">
  {
    1:   2,  ; kty: EC2 key type
    3:  -7,  ; alg: ES256 signature algorithm
   -1:   1,  ; crv: P-256 curve
   -2:   x,  ; x-coordinate as byte string 32 bytes in length
             ; e.g., in hex: 65eda5a12577c2bae829437fe338701a10aaa375e1bb5b5de108de439c08551d
   -3:   y   ; y-coordinate as byte string 32 bytes in length
             ; e.g., in hex: 1e52ed75701163f7f9e40ddf9f341b3dc9ba860af7e0ca7ca7e9eecd0084d19c
  }
</pre>

Below is the above Elliptic Curve public key encoded in the [=CTAP2 canonical CBOR encoding form=], whitespace and line breaks
are included here for clarity and to match the CDDL [[!RFC8610]] presentation above:

<pre class="example" highlight="json">
  A5
     01  02

     03  26

     20  01

     21  58 20   65eda5a12577c2bae829437fe338701a10aaa375e1bb5b5de108de439c08551d

     22  58 20   1e52ed75701163f7f9e40ddf9f341b3dc9ba860af7e0ca7ca7e9eecd0084d19c
</pre>


Below is an example of a COSE_Key-encoded 2048-bit RSA public key (see [[RFC8230]] [=Section 4=],
to be used with the PS256 signature algorithm
(RSASSA-PSS with SHA-256, see [=RFC8230/Section 2=] of [[RFC8230]]:

<pre class="example" highlight="json">
  {
    1:   3,  ; kty: RSA key type
    3: -37,  ; alg: PS256
   -1:   n,  ; n:   RSA modulus n byte string 256 bytes in length
             ;      e.g., in hex (middle bytes elided for brevity): DB5F651550...6DC6548ACC3
   -2:   e   ; e:   RSA public exponent e byte string 3 bytes in length
             ;      e.g., in hex: 010001
  }
</pre>

Below is an example of the same COSE_Key-encoded RSA public key as above,
to be used with the RS256 signature algorithm (RSASSA-PKCS1-v1_5 with SHA-256):

<pre class="example" highlight="json">
  {
    1:   3,  ; kty: RSA key type
    3:-257,  ; alg: RS256
   -1:   n,  ; n:   RSA modulus n byte string 256 bytes in length
             ;      e.g., in hex (middle bytes elided for brevity): DB5F651550...6DC6548ACC3
   -2:   e   ; e:   RSA public exponent e byte string 3 bytes in length
             ;      e.g., in hex: 010001
  }
</pre>


### Attestation Statement Formats ### {#sctn-attestation-formats}

As described above, an [=attestation statement format=] is a data format which represents a cryptographic signature by an
[=authenticator=] over a set of contextual bindings. Each [=attestation statement format=] MUST be defined using the following
template:

- <strong>[=Attestation statement format identifier=]:</strong>

- <strong>Supported [=attestation types=]:</strong>

- <strong>Syntax:</strong>
    The syntax of an [=attestation statement=] produced in this format, defined using CDDL [[!RFC8610]] for the extension point
    `$attStmtFormat` defined in [[#sctn-generating-an-attestation-object]].

- <dfn>Signing procedure</dfn>:
    The [=signing procedure=] for computing an [=attestation statement=] in this [=attestation statement format|format=] given
    the [=public key credential=] to be attested, the [=authenticator data=] structure containing the <dfn>authenticator data
    for the attestation</dfn>, and the [=hash of the serialized client data=].

- <dfn>Verification procedure</dfn>:
    The procedure for verifying an [=attestation statement=], which takes the following <dfn>verification procedure inputs</dfn>:
    - |attStmt|: The [=attestation statement=] structure
    - |authenticatorData|: The  <dfn>[=authenticator data=] claimed to have been used for the attestation</dfn>
    - |clientDataHash|: The [=hash of the serialized client data=]

    The procedure returns either:
    - An error indicating that the attestation is invalid, or
    - An implementation-specific value representing the [=attestation type=], and the [=attestation trust path|trust path=]. This <dfn>attestation trust path</dfn> is either
        empty (in case of [=self attestation=]), or a set of X.509 certificates.

The initial list of specified [=attestation statement formats=] is in [[#sctn-defined-attestation-formats]].


<!-- Editors Note: differentiating section IDs from non-section IDs is useful because at times we need to seperately reference
     different things having the same nominal name, eg attestation-types-the-section, and attestation-types-the-definition -->
### Attestation Types ### {#sctn-attestation-types}

WebAuthn supports several [=attestation types=], defining the semantics of [=attestation statements=] and their underlying trust
models:

Note: This specification does not define any data structures explicitly expressing the [=attestation types=] employed by
[=authenticators=]. [=[RPS]=] engaging in [=attestation statement=] [=verification procedure|verification=] &mdash; i.e., when
calling {{CredentialsContainer/create()|navigator.credentials.create()}} they select an [=attestation conveyance=] other than
{{AttestationConveyancePreference/none}} and verify the received [=attestation statement=] &mdash; will determine the employed
[=attestation type=] as a part of [=verification procedure|verification=]. See the "Verification procedure" subsections of
[[#sctn-defined-attestation-formats]]. See also [[#sctn-attestation-privacy]]. For all [=attestation types=] defined in this
section other than [=self attestation|Self=] and [=None=], [=[RP]=] [=verification procedure|verification=] is followed by
matching the [=attestation trust path|trust path=] to an acceptable root certificate per step 20 of [[#sctn-registering-a-new-credential]].
Differentiating these [=attestation types=] becomes useful primarily as a means for determining if the [=attestation=] is acceptable
under [=[RP]=] policy.

: <dfn>Basic Attestation</dfn> (<dfn>Basic</dfn>)
:: In the case of basic attestation [[UAFProtocol]], the authenticator's [=attestation key pair=] is specific to an
    authenticator "model", i.e., a "batch" of authenticators.  Thus, authenticators of the same, or similar, model often share the same [=attestation key pair=]. See
    [[#sctn-attestation-privacy]] for further information.

    [=Basic attestation=] is also referred to as <dfn>batch attestation</dfn>.

: <dfn>Self Attestation</dfn> (<dfn>Self</dfn>)
:: In the case of [=self attestation=], also known as surrogate basic attestation [[UAFProtocol]], the Authenticator does not have
    any specific [=attestation key pair=]. Instead it uses the [=credential private key=] to create the [=attestation signature=].
    Authenticators without meaningful protection measures for an [=attestation private key=] typically use this attestation type.

: <dfn>Attestation CA</dfn> (<dfn>AttCA</dfn>)
:: In this case, an [=authenticator=] is based on a Trusted Platform Module (TPM) and holds an authenticator-specific
    "endorsement key" (EK). This key is used to securely communicate with a trusted third party, the [=Attestation CA=]
    [[!TCG-CMCProfile-AIKCertEnroll]] (formerly known as a "Privacy CA"). The [=authenticator=] can generate multiple
    attestation identity key pairs (AIK) and requests an [=Attestation CA=] to issue an AIK certificate
    for each. Using this approach, such an [=authenticator=] can limit the exposure of the EK (which is a global correlation
    handle) to Attestation CA(s). AIKs can be requested for each [=authenticator=]-generated [=public key credential=]
    individually, and conveyed to [=[RPS]=] as [=attestation certificates=].

    Note: This concept typically leads to multiple attestation certificates. The attestation certificate requested most recently
        is called "active".

: <dfn>Anonymization CA</dfn> (<dfn>AnonCA</dfn>)
:: In this case, the [=authenticator=] uses an [=Anonymization CA=] which dynamically generates per-[=credential=] [=attestation certificates=] such that the [=attestation statements=] presented to [=[RPS]=] do not provide uniquely identifiable information, e.g., that might be used for tracking purposes.

    Note: [=Attestation statements=] conveying [=attestations=] of [=attestation type|type=] [=AttCA=] or [=AnonCA=] use the same data structure
        as those of [=attestation type|type=] [=Basic=], so the three attestation types
        are, in general, distinguishable only with externally provided knowledge regarding the contents of the [=attestation
        certificates=] conveyed in the [=attestation statement=].

: No attestation statement (<dfn>None</dfn>)
:: In this case, no attestation information is available. See also [[#sctn-none-attestation]].

### Generating an Attestation Object ### {#sctn-generating-an-attestation-object}

To generate an [=attestation object=] (see: [Figure 6](#fig-attStructs)) given:

: |attestationFormat|
:: An [=attestation statement format=].
: |authData|
:: A byte array containing [=authenticator data=].
: |hash|
:: The [=hash of the serialized client data=].

the [=authenticator=] MUST:

1. Let <var ignore>attStmt</var> be the result of running |attestationFormat|'s [=signing procedure=] given |authData| and
    |hash|.
1. Let <var ignore>fmt</var> be |attestationFormat|'s [=attestation statement format identifier=]
1. Return the [=attestation object=] as a CBOR map with the following syntax, filled in with variables initialized by this
    algorithm:

    ```
    attObj = {
                authData: bytes,
                $$attStmtType
             }

    attStmtTemplate = (
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType
                      )

    ; Every attestation statement format must have the above fields
    attStmtTemplate .within $$attStmtType
    ```

### Signature Formats for Packed Attestation, FIDO U2F Attestation, and Assertion Signatures ### {#sctn-signature-attestation-types}
    - For COSEAlgorithmIdentifier -7 (ES256),  and other ECDSA-based algorithms, the
        `sig` value MUST be encoded as an ASN.1 DER Ecdsa-Sig-Value, as defined in [[RFC3279]] section 2.2.3.

        ```
        Example:
        30 44                                ; SEQUENCE (68 Bytes)
            02 20                            ; INTEGER (32 Bytes)
            |  3d 46 28 7b 8c 6e 8c 8c  26 1c 1b 88 f2 73 b0 9a
            |  32 a6 cf 28 09 fd 6e 30  d5 a7 9f 26 37 00 8f 54
            02 20                            ; INTEGER (32 Bytes)
            |  4e 72 23 6e a3 90 a9 a1  7b cf 5f 7a 09 d6 3a b2
            |  17 6c 92 bb 8e 36 c0 41  98 a2 7b 90 9b 6e 8f 13
        ```

        Note: As CTAP1/U2F [=authenticators=] are already producing signatures values in this format, CTAP2
        [=authenticators=] will also produce signatures values in the same format, for consistency reasons.

    It is RECOMMENDED that any new attestation formats defined not use ASN.1 encodings,
    but instead represent signatures as equivalent fixed-length byte arrays without internal structure,
    using the same representations as used by COSE signatures as defined in [[!RFC9053]] and [[!RFC8230]].

    The below signature format definitions satisfy this requirement and serve as examples for deriving the same for other signature algorithms not explicitly mentioned here:

    - For COSEAlgorithmIdentifier -257 (RS256), `sig` MUST contain the signature generated using the
        RSASSA-PKCS1-v1_5 signature scheme defined in section 8.2.1 in [[RFC8017]] with SHA-256 as the hash function.
        The signature is not ASN.1 wrapped.

    - For COSEAlgorithmIdentifier -37 (PS256), `sig` MUST contain the signature generated using the
        RSASSA-PSS signature scheme defined in section 8.1.1 in [[RFC8017]] with SHA-256 as the hash function.
        The signature is not ASN.1 wrapped.

# [=[WRP]=] Operations # {#sctn-rp-operations}

A [=registration ceremony|registration=] or [=authentication ceremony=] begins with the [=[WRP]=] creating a {{PublicKeyCredentialCreationOptions}}
or {{PublicKeyCredentialRequestOptions}} object, respectively, which encodes the parameters for the [=ceremony=]. The [=[RP]=]
SHOULD take care to not leak sensitive information during this stage; see [[#sctn-username-enumeration]] for details.

Upon successful execution of {{CredentialsContainer/create()}} or {{CredentialsContainer/get()}}, the [=[RP]=]'s script receives
a {{PublicKeyCredential}} containing an {{AuthenticatorAttestationResponse}} or {{AuthenticatorAssertionResponse}} structure,
respectively, from the client. It must then deliver the contents of this structure to the [=[RP]=] server, using methods outside
the scope of this specification. This section describes the operations that the [=[RP]=] must perform upon receipt of these
structures.


## Registering a New Credential ## {#sctn-registering-a-new-credential}

In order to perform a [=registration ceremony=], the [=[RP]=] MUST proceed as follows:

1. Let |options| be a new {{PublicKeyCredentialCreationOptions}} structure configured to the [=[RP]=]'s needs for the ceremony.

1. Call {{CredentialsContainer/create()|navigator.credentials.create()}} and pass |options|
    as the <code>{{CredentialCreationOptions/publicKey}}</code> option.
    Let |credential| be the result of the successfully resolved promise.
    If the promise is rejected, abort the ceremony with a user-visible error, or otherwise guide the user experience as
    might be determinable from the context available in the rejected promise. For example if the promise is rejected with
    an error code equivalent to "{{InvalidStateError}}", the user might be instructed to use a different [=authenticator=].
    For information on different error contexts and the circumstances leading to them, see [[#sctn-op-make-cred]].

1. Let |response| be <code>|credential|.{{PublicKeyCredential/response}}</code>.
    If |response| is not an instance of {{AuthenticatorAttestationResponse}}, abort the ceremony with a user-visible error.

1. Let |clientExtensionResults| be the result of calling
    <code>|credential|.{{PublicKeyCredential/getClientExtensionResults()}}</code>.

1. Let |JSONtext| be the result of
    running [=UTF-8 decode=] on the value of <code>|response|.{{AuthenticatorResponse/clientDataJSON}}</code>.

    Note: Using any implementation of [=UTF-8 decode=] is acceptable as long as it yields the same result as that yielded by
    the [=UTF-8 decode=] algorithm. In particular, any leading byte order mark (BOM) MUST be stripped.

1. Let |C|, the [=client data=] claimed as collected during the credential creation, be the result of running an
    implementation-specific JSON parser on |JSONtext|.

    Note: |C| may be any implementation-specific data structure representation, as long as |C|'s components are referenceable, as
    required by this algorithm.

1. Verify that the value of <code>|C|.{{CollectedClientData/type}}</code> is `webauthn.create`.

1. Verify that the value of <code>|C|.{{CollectedClientData/challenge}}</code> equals
    the base64url encoding of <code>|options|.{{PublicKeyCredentialCreationOptions/challenge}}</code>.

1. Verify that the value of <code>|C|.{{CollectedClientData/origin}}</code> matches the [=[RP]=]'s [=origin=].

1. Let |hash| be the result of computing a hash over <code>|response|.{{AuthenticatorResponse/clientDataJSON}}</code> using SHA-256.

1. Perform CBOR decoding on the {{AuthenticatorAttestationResponse/attestationObject}} field of the
    {{AuthenticatorAttestationResponse}} structure to obtain the attestation statement format |fmt|, the [=authenticator data=]
    |authData|, and the attestation statement |attStmt|.

1. Verify that the <code>[=rpIdHash=]</code> in |authData| is the SHA-256 hash of the [=RP ID=] expected by the [=[RP]=].

1. Verify that the [=UP=] bit of the <code>[=flags=]</code> in |authData| is set.

1. If the [=[RP]=] requires [=user verification=] for this registration,
    verify that the [=authData/flags/UV=] bit of the <code>[=flags=]</code> in |authData| is set.

1. If the [=[RP]=] uses the credential's [=backup eligibility=] to inform its user experience flows and/or policies, evaluate the
    [=authData/flags/BE=] bit of the <code>[=flags=]</code> in |authData|.

1. If the [=[RP]=] uses the credential's [=backup state=] to inform its user experience flows and/or policies, evaluate the [=authData/flags/BS=]
    bit of the <code>[=flags=]</code> in |authData|.

1. Verify that the "alg" parameter in the [=credentialPublicKey|credential public key=] in |authData|
    matches the {{PublicKeyCredentialParameters/alg}} attribute of one of the [=list/items=] in
    <code>|options|.{{PublicKeyCredentialCreationOptions/pubKeyCredParams}}</code>.

    <li id='reg-ceremony-verify-extension-outputs'>
        Verify that the values of the [=client extension outputs=] in |clientExtensionResults| and the [=authenticator extension
        outputs=] in the <code>[=authData/extensions=]</code> in |authData| are as expected, considering the [=client
        extension input=] values that were given in <code>|options|.{{PublicKeyCredentialCreationOptions/extensions}}</code>
        and any specific policy of the [=[RP]=] regarding unsolicited extensions, i.e., those that were not specified as part of
        <code>|options|.{{PublicKeyCredentialCreationOptions/extensions}}</code>.
        In the general case, the meaning of "are as expected" is specific to the [=[RP]=] and which extensions are in use.

        Note:  [=Client platforms=] MAY enact local policy that sets additional [=authenticator extensions=] or
        [=client extensions=] and thus cause values to appear in the [=authenticator extension outputs=] or
        [=client extension outputs=] that were not originally specified as part of
        <code>|options|.{{PublicKeyCredentialCreationOptions/extensions}}</code>. [=[RPS]=] MUST be prepared to handle such
        situations, whether it be to ignore the unsolicited extensions or reject the attestation. The [=[RP]=] can make this
        decision based on local policy and the extensions in use.

        Note: Since all extensions are OPTIONAL for both the [=client=] and the [=authenticator=], the [=[RP]=] MUST also be
        prepared to handle cases where none or not all of the requested extensions were acted upon.

        Note: The [=devicePubKey=] extension has explicit verification procedures, see [[#sctn-device-publickey-extension-verification-create]].
    </li>

1. Determine the attestation statement format by performing a USASCII case-sensitive match on |fmt| against the set of
    supported WebAuthn Attestation Statement Format Identifier values.
    An up-to-date list of registered WebAuthn Attestation Statement Format Identifier values
    is maintained in the
    IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].

1. Verify that |attStmt| is a correct [=attestation statement=], conveying a valid [=attestation signature=], by using the
    [=attestation statement format=] |fmt|'s [=verification procedure=] given |attStmt|, |authData| and |hash|.

    Note: Each [=attestation statement format=] specifies its own [=verification procedure=]. See [[#sctn-defined-attestation-formats]] for
    the initially-defined formats, and [[!IANA-WebAuthn-Registries]] for the up-to-date list.

1. If validation is successful, obtain a list of acceptable trust anchors (i.e. attestation root certificates)
    for that attestation type and attestation statement format |fmt|, from a trusted source or from policy. For
    example, the FIDO Metadata Service [[FIDOMetadataService]] provides one way to obtain such information, using the
    <code>[=aaguid=]</code> in the <code>[=attestedCredentialData=]</code> in |authData|.

1. Assess the attestation trustworthiness using the outputs of the [=verification procedure=] in step 19, as follows:
        - If [=None|no attestation=] was provided, verify that [=None=] attestation is acceptable under [=[RP]=] policy.
        - If [=self attestation=] was used, verify that [=self attestation=] is acceptable under [=[RP]=] policy.
        - Otherwise, use the X.509 certificates returned as the [=attestation trust path=] from the [=verification procedure=]
            to verify that the attestation public key either correctly chains up to an acceptable root certificate, or is itself an acceptable certificate (i.e., it and the root certificate obtained in Step 19 may be the same).

1. Verify that the <code>[=credentialId=]</code> is &le; 1023 bytes. Credential IDs larger than this many bytes SHOULD cause the RP to fail this [=registration ceremony=].

1. Verify that the <code>[=credentialId=]</code> is not yet registered for any user. If the <code>[=credentialId=]</code> is already known then the [=[RP]=] SHOULD fail this [=registration ceremony=].

    NOTE: The rationale for [=[RPS]=] rejecting duplicate [=credential IDs=] is as follows: [=credential IDs=] contain sufficient entropy that accidental duplication is very unlikely. However, [=attestation types=] other than [=self attestation=] do not include a self-signature to explicitly prove possession of the [=credential private key=] at [=registration=] time. Thus an attacker who has managed to obtain a user's [=credential ID=] and [=credential public key=] for a site (this could be potentially accomplished in various ways), could attempt to register a victim's credential as their own at that site. If the [=[RP]=] accepts this new registration and replaces the victim's existing credential registration, and the [=discoverable credentials|credentials are discoverable=], then the victim could be forced to sign into the attacker's account at their next attempt. Data saved to the site by the victim in that state would then be available to the attacker.

1. If the attestation statement |attStmt| verified successfully and is found to be trustworthy,
    then create and store a new [=credential record=] in the [=user account=]
    that was denoted in <code>|options|.{{PublicKeyCredentialCreationOptions/user}}</code>,
    with the following contents:

    <dl>
        :   [$credential record/type$]
        ::  <code>|credential|.{{Credential/type}}</code>.

        :   [$credential record/id$]
        ::  <code>|credential|.{{Credential/id}}</code> or <code>|credential|.{{PublicKeyCredential/rawId}}</code>,
            whichever format is preferred by the [=[RP]=].

        :   [$credential record/publicKey$]
        ::  The [=credential public key=] in |authData|.

        :   [$credential record/signCount$]
        ::  <code>|authData|.[=authData/signCount=]</code>.

        :   [$credential record/transports$]
        ::  The value returned from <code>|response|.{{AuthenticatorAttestationResponse/getTransports()}}</code>.

        :   [$credential record/BE$]
        ::  The value of the [=authData/flags/BE=] [=flag=] in |authData|.

        :   [$credential record/BS$]
        ::  The value of the [=authData/flags/BS=] [=flag=] in |authData|.
    </dl>

    The new [=credential record=] MAY also include the following OPTIONAL contents:

    <dl>
        :   [$credential record/attestationObject$]
        ::  <code>|response|.{{AuthenticatorAttestationResponse/attestationObject}}</code>.

        :   [$credential record/attestationClientDataJSON$]
        ::  <code>|response|.{{AuthenticatorResponse/clientDataJSON}}</code>.
    </dl>

1. If the attestation statement |attStmt| successfully verified but is not trustworthy per step 20 above, the [=[RP]=] SHOULD fail
    the [=registration ceremony=].

    NOTE: However, if permitted by policy, the [=[RP]=] MAY register the [=credential ID=] and credential public key but treat the
        credential as one with [=self attestation=] (see [[#sctn-attestation-types]]). If doing so, the [=[RP]=] is asserting there
        is no cryptographic proof that the [=public key credential=] has been generated by a particular [=authenticator=] model.
        See [[FIDOSecRef]] and [[UAFProtocol]] for a more detailed discussion.

Verification of [=attestation objects=] requires that the [=[RP]=] has a trusted method of determining acceptable trust anchors
in step 19 above. Also, if certificates are being used, the [=[RP]=] MUST have access to certificate status information for the
intermediate CA certificates. The [=[RP]=] MUST also be able to build the attestation certificate chain if the client did not
provide this chain in the attestation information.


## Verifying an Authentication Assertion ## {#sctn-verifying-assertion}

In order to perform an [=authentication ceremony=], the [=[RP]=] MUST proceed as follows:

1. Let |options| be a new {{PublicKeyCredentialRequestOptions}} structure configured to the [=[RP]=]'s needs for the ceremony.

1. Call {{CredentialsContainer/get()|navigator.credentials.get()}} and pass |options|
    as the <code>{{CredentialRequestOptions/publicKey}}</code> option.
    Let |credential| be the result of the successfully resolved promise.
    If the promise is rejected, abort the ceremony with a user-visible error, or otherwise guide the user experience as might
    be determinable from the context available in the rejected promise. For information on different error contexts and the
    circumstances leading to them, see [[#sctn-op-get-assertion]].

1. Let |response| be <code>|credential|.{{PublicKeyCredential/response}}</code>.
    If |response| is not an instance of {{AuthenticatorAssertionResponse}}, abort the ceremony with a user-visible error.

1. Let |clientExtensionResults| be the result of calling <code>|credential|.{{PublicKeyCredential/getClientExtensionResults()}}</code>.

1. If <code>|options|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code> [=list/is not empty=],
    verify that <code>|credential|.{{Credential/id}}</code> identifies one of the [=public key credentials=]
    listed in <code>|options|.{{PublicKeyCredentialRequestOptions/allowCredentials}}</code>.

1. Identify the user being authenticated and let |credentialRecord|
    be the [=credential record=] for the [=credential=]:

    <dl class="switch">
        :  If the user was identified before the [=authentication ceremony=] was initiated, e.g., via a username or cookie,
        :: verify that the identified [=user account=] contains a [=credential record=]
            whose [$credential record/id$] equals <code>|credential|.{{PublicKeyCredential/rawId}}</code>.
            Let |credentialRecord| be that [=credential record=].
            If <code>|response|.{{AuthenticatorAssertionResponse/userHandle}}</code> is present,
            verify that it equals the [=user handle=] of the [=user account=].

        :  If the user was not identified before the [=authentication ceremony=] was initiated,
        :: verify that <code>|response|.{{AuthenticatorAssertionResponse/userHandle}}</code> is present.
            Verify that the [=user account=] identified by <code>|response|.{{AuthenticatorAssertionResponse/userHandle}}</code>
            contains a [=credential record=] whose [$credential record/id$] equals <code>|credential|.{{PublicKeyCredential/rawId}}</code>.
            Let |credentialRecord| be that [=credential record=].
    </dl>

1. Let |cData|, |authData| and |sig| denote the value of |response|'s
    {{AuthenticatorResponse/clientDataJSON}}, {{AuthenticatorAssertionResponse/authenticatorData}}, and
    {{AuthenticatorAssertionResponse/signature}} respectively.

1. Let |JSONtext| be the result of running [=UTF-8 decode=] on the value of |cData|.

    Note: Using any implementation of [=UTF-8 decode=] is acceptable as long as it yields the same result as that yielded by
    the [=UTF-8 decode=] algorithm. In particular, any leading byte order mark (BOM) MUST be stripped.

1. Let |C|, the [=client data=] claimed as used for the signature, be the result of running an implementation-specific
    JSON parser on |JSONtext|.

    Note: |C| may be any implementation-specific data structure representation, as long as |C|'s components are referenceable, as
    required by this algorithm.

1. Verify that the value of <code>|C|.{{CollectedClientData/type}}</code> is the string `webauthn.get`.

1. Verify that the value of <code>|C|.{{CollectedClientData/challenge}}</code> equals
    the base64url encoding of <code>|options|.{{PublicKeyCredentialRequestOptions/challenge}}</code>.

<!-- Note: this next step is actually a top-level step, but bikeshed wanted it indented this much in order to render it as
a numbered step. If outdented, it (today) is rendered as a bullet in the midst of a numbered list :-/
-->
    <li id='rp-op-verifying-assertion-step-origin'>
      Verify that the value of <code>|C|.{{CollectedClientData/origin}}</code> matches the [=[RP]=]'s [=origin=].
    </li>

<!-- Note: this next step is actually a top-level step, but bikeshed wanted it indented this much in order to render it as
a numbered step. If outdented, it (today) is rendered as a bullet in the midst of a numbered list :-/
-->
    <li id='rp-op-verifying-assertion-step-rpid-hash'>
      Verify that the <code>[=rpIdHash=]</code> in |authData| is the SHA-256 hash of the [=RP ID=] expected by the [=[RP]=].

      Note: If using the [=appid=] extension, this step needs some special logic. See [[#sctn-appid-extension]] for details.
    </li>

1. Verify that the [=UP=] bit of the <code>[=flags=]</code> in |authData| is set.

1. If the [=[RP]=] requires [=user verification=] for this assertion,
    verify that the [=authData/flags/UV=] bit of the <code>[=flags=]</code> in |authData| is set.

1. If the credential [=backup state=] is used as part of [=[RP]=] business logic or policy,
    let |currentBe| and |currentBs| be the values of the [=authData/flags/BE=] and [=authData/flags/BS=] bits, respectively,
    of the <code>[=flags=]</code> in |authData|.
    Compare |currentBe| and |currentBs| with
    <code>|credentialRecord|.[$credential record/BE$]</code> and <code>|credentialRecord|.[$credential record/BS$]</code>
    and apply [=[RP]=] policy, if any.

    Note: See [[#sctn-credential-backup]] for examples of how a [=[RP]=] might process the [=authData/flags/BS=] [=flag=] values.

    <li id='authn-ceremony-verify-extension-outputs'>
        Verify that the values of the [=client extension outputs=] in |clientExtensionResults| and the [=authenticator extension
        outputs=] in the <code>[=authData/extensions=]</code> in |authData| are as expected, considering the [=client
        extension input=] values that were given in <code>|options|.{{PublicKeyCredentialRequestOptions/extensions}}</code>
        and any specific policy of the [=[RP]=] regarding unsolicited extensions, i.e., those that were not specified as part of
        <code>|options|.{{PublicKeyCredentialRequestOptions/extensions}}</code>.
        In the general case, the meaning of "are as expected" is specific to the [=[RP]=] and which extensions are in use.

        Note:  [=Client platforms=] MAY enact local policy that sets additional [=authenticator extensions=] or
        [=client extensions=] and thus cause values to appear in the [=authenticator extension outputs=] or
        [=client extension outputs=] that were not originally specified as part of
        <code>|options|.{{PublicKeyCredentialRequestOptions/extensions}}</code>. [=[RPS]=] MUST be prepared to handle such
        situations, whether it be to ignore the unsolicited extensions or reject the assertion. The [=[RP]=] can make this
        decision based on local policy and the extensions in use.

        Note: Since all extensions are OPTIONAL for both the [=client=] and the [=authenticator=], the [=[RP]=] MUST also be
        prepared to handle cases where none or not all of the requested extensions were acted upon.

        Note: The [=devicePubKey=] extension has explicit verification procedures, see [[#sctn-device-publickey-extension-verification-get]].
    </li>

1. Let |hash| be the result of computing a hash over the |cData| using SHA-256.

1. Using <code>|credentialRecord|.[$credential record/publicKey$]</code>,
    verify that |sig| is a valid signature over the binary concatenation of
    |authData| and |hash|.

    Note: This verification step is compatible with signatures generated by FIDO U2F authenticators. See
    [[#sctn-fido-u2f-sig-format-compat]].

1. If |authData|.<code>[=authData/signCount=]</code> is nonzero or <code>|credentialRecord|.[$credential record/signCount$]</code> is nonzero,
    then run the following sub-step:
      - If |authData|.<code>[=authData/signCount=]</code> is
           <dl class="switch">
              <dt>greater than <code>|credentialRecord|.[$credential record/signCount$]</code>:</dt>
              <dd>The signature counter is valid.</dd>
              <dt>less than or equal to <code>|credentialRecord|.[$credential record/signCount$]</code>:</dt>
              <dd>This is a signal that
                  the authenticator may be cloned, i.e. at least
                  two copies of the [=credential private key=] may exist and are
                  being used in parallel. [=[RPS]=] should incorporate this information
                  into their risk scoring.
                  Whether the [=[RP]=] updates <code>|credentialRecord|.[$credential record/signCount$]</code>
                  below in this case, or not, or fails the
                  [=authentication ceremony=] or not, is
                  [=[RP]=]-specific. </dd>
           </dl>

1. If <code>|response|.{{AuthenticatorAssertionResponse/attestationObject}}</code> is present and the [=[RP]=] wishes to verify the attestation then perform CBOR decoding on {{AuthenticatorAssertionResponse/attestationObject}} to obtain the attestation statement format |fmt|, and the attestation statement |attStmt|.

    1. Verify that the `AT` bit in the [=flags=] field of |authData| is set, indicating that [=attested credential data=] is included.

    1. Verify that the [=credentialPublicKey=] and [=credentialId=] fields of the [=attested credential data=] in |authData| match <code>|credentialRecord|.[$credential record/publicKey$]</code> and <code>|credentialRecord|.[$credential record/id$]</code>, respectively.

    1. Determine the attestation statement format by performing a USASCII case-sensitive match on |fmt| against the set of supported WebAuthn Attestation Statement Format Identifier values. An up-to-date list of registered WebAuthn Attestation Statement Format Identifier values is maintained in the IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].

    1. Verify that |attStmt| is a correct [=attestation statement=], conveying a valid [=attestation signature=], by using the [=attestation statement format=] |fmt|'s [=verification procedure=] given |attStmt|, |authData| and |hash|.

        Note: Each [=attestation statement format=] specifies its own [=verification procedure=]. See [[#sctn-defined-attestation-formats]] for the initially-defined formats, and [[!IANA-WebAuthn-Registries]] for the up-to-date list.

    1. If validation is successful, obtain a list of acceptable trust anchors (i.e. attestation root certificates) for that attestation type and attestation statement format |fmt|, from a trusted source or from policy. The [=aaguid=] in the [=attested credential data=] can be used to guide this lookup.

1. Update |credentialRecord| with new state values:

    1. Update <code>|credentialRecord|.[$credential record/signCount$]</code> to the value of |authData|.<code>[=authData/signCount=]</code>.
    1. Update <code>|credentialRecord|.[$credential record/BS$]</code> to the value of |currentBs|.

1. If all the above steps are successful, continue with the [=authentication ceremony=] as appropriate. Otherwise, fail the
    [=authentication ceremony=].


# Defined Attestation Statement Formats # {#sctn-defined-attestation-formats}

WebAuthn supports pluggable attestation statement formats. This section defines an initial set of such formats.

## Attestation Statement Format Identifiers ## {#sctn-attstn-fmt-ids}

Attestation statement formats are identified by a string, called an <dfn>attestation statement format identifier</dfn>, chosen by
the author of the [=attestation statement format=].

Attestation statement format identifiers SHOULD be registered in the
IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].
All registered attestation statement format identifiers are unique amongst themselves as a matter of course.

Unregistered attestation statement format identifiers SHOULD use lowercase reverse domain-name naming, using a domain name
registered by the developer, in order to assure uniqueness of the identifier. All attestation statement format identifiers MUST
be a maximum of 32 octets in length and MUST consist only of printable USASCII characters, excluding backslash and doublequote,
i.e., VCHAR as defined in [[!RFC5234]] but without %x22 and %x5c.

Note: This means attestation statement format identifiers based on domain names MUST incorporate only LDH Labels [[!RFC5890]].

Implementations MUST match WebAuthn attestation statement format identifiers in a case-sensitive fashion.

Attestation statement formats that may exist in multiple versions SHOULD include a version in their identifier. In effect,
different versions are thus treated as different formats, e.g., `packed2` as a new version of the [[#sctn-packed-attestation]].

The following sections present a set of currently-defined and registered attestation statement formats and their identifiers.
The up-to-date list of registered [=WebAuthn Extensions=] is maintained in the
IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].


## Packed Attestation Statement Format ## {#sctn-packed-attestation}

This is a WebAuthn optimized attestation statement format. It uses a very compact but still extensible encoding method. It is
implementable by [=authenticators=] with limited resources (e.g., secure elements).

: Attestation statement format identifier
:: packed

: Attestation types supported
:: [=Basic=], [=Self=], [=AttCA=]

: Syntax
:: The syntax of a Packed Attestation statement is defined by the following CDDL:

    ```
    $$attStmtType //= (
                          fmt: "packed",
                          attStmt: packedStmtFormat
                      )

    packedStmtFormat = {
                           alg: COSEAlgorithmIdentifier,
                           sig: bytes,
                           x5c: [ attestnCert: bytes, * (caCert: bytes) ]
                       } //
                       {
                           alg: COSEAlgorithmIdentifier
                           sig: bytes,
                       }
    ```

    The semantics of the fields are as follows:

    : alg
    :: A {{COSEAlgorithmIdentifier}} containing the identifier of the algorithm used to generate the [=attestation signature=].

    : sig
    :: A byte string containing the [=attestation signature=].

    : x5c
    :: The elements of this array contain |attestnCert| and its certificate chain (if any), each encoded in X.509 format. The attestation
        certificate |attestnCert| MUST be the first element in the array.

    : attestnCert
    :: The attestation certificate, encoded in X.509 format.

: Signing procedure
:: The signing procedure for this attestation statement format is
    similar to [the procedure for generating assertion signatures](#fig-signature).
        1. Let |authenticatorData| denote the [=authenticator data for the attestation=],
            and let |clientDataHash| denote the [=hash of the serialized client data=].

        1. If [=Basic=] or [=AttCA=] [=attestation=] is in use, the authenticator produces the |sig| by concatenating |authenticatorData| and
            |clientDataHash|, and signing the result using an [=attestation private key=] selected through an authenticator-specific
            mechanism. It sets |x5c| to |attestnCert| followed by the related certificate chain (if any). It sets |alg| to the algorithm of the
            attestation private key.

        1. If [=self attestation=] is in use, the authenticator produces |sig| by concatenating |authenticatorData| and |clientDataHash|,
            and signing the result using the credential private key. It sets |alg| to the algorithm of the credential private key and
            omits the other fields.

: Verification procedure
:: Given the [=verification procedure inputs=] |attStmt|, |authenticatorData| and |clientDataHash|, the [=verification procedure=] is
    as follows:

        1. Verify that |attStmt| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract
            the contained fields.

        1. If |x5c| is present:
            - Verify that |sig| is a valid signature over the concatenation of |authenticatorData| and |clientDataHash| using the
                attestation public key in |attestnCert| with the algorithm specified in |alg|.
            - Verify that |attestnCert| meets the requirements in [[#sctn-packed-attestation-cert-requirements]].
            - If |attestnCert| contains an extension with OID `1.3.6.1.4.1.45724.1.1.4` (`id-fido-gen-ce-aaguid`) verify that the
                value of this extension matches the <code>[=aaguid=]</code> in |authenticatorData|.
            - Optionally, inspect |x5c| and consult externally provided knowledge to determine whether |attStmt| conveys a
                [=Basic=] or [=AttCA=] attestation.
            - If successful, return implementation-specific values representing [=attestation type=] [=Basic=], [=AttCA=] or
                uncertainty, and [=attestation trust path=] |x5c|.

        1. If |x5c| is not present, [=self attestation=] is in use.
            - Validate that |alg| matches the algorithm of the <code>[=credentialPublicKey=]</code> in |authenticatorData|.
            - Verify that |sig| is a valid signature over the concatenation of |authenticatorData| and |clientDataHash| using the
                credential public key with |alg|.
            - If successful, return implementation-specific values representing [=attestation type=] [=Self=] and an empty
                [=attestation trust path=].


### Packed Attestation Statement Certificate Requirements ### {#sctn-packed-attestation-cert-requirements}

The attestation certificate MUST have the following fields/extensions:

- Version MUST be set to 3 (which is indicated by an ASN.1 INTEGER with value 2).
- Subject field MUST be set to:
    : Subject-C
    :: ISO 3166 code specifying the country where the Authenticator vendor is incorporated (PrintableString)
    : Subject-O
    :: Legal name of the Authenticator vendor (UTF8String)
    : Subject-OU
    :: Literal string “Authenticator Attestation” (UTF8String)
    : Subject-CN
    :: A UTF8String of the vendor's choosing

- If the related attestation root certificate is used for multiple authenticator models, the Extension OID
    `1.3.6.1.4.1.45724.1.1.4` (`id-fido-gen-ce-aaguid`) MUST be present, containing the AAGUID as a 16-byte OCTET STRING.
    The extension MUST NOT be marked as critical.

    Note that an X.509 Extension encodes the DER-encoding of the value in an OCTET STRING.
    Thus, the AAGUID MUST be wrapped in <i>two</i> OCTET STRINGS to be valid. Here is a sample, encoded Extension structure:

    <pre>
  30 21                                     -- SEQUENCE
    06 0b 2b 06 01 04 01 82 e5 1c 01 01 04  -- 1.3.6.1.4.1.45724.1.1.4
    04 12                                   -- OCTET STRING
      04 10                                 -- OCTET STRING
        cd 8c 39 5c 26 ed ee de             -- AAGUID
        65 3b 00 79 7d 03 ca 3c
    </pre>

- The Basic Constraints extension MUST have the CA component set to [FALSE].

- An Authority Information Access (AIA) extension with entry `id-ad-ocsp` and a CRL Distribution Point extension [[RFC5280]]
    are both OPTIONAL as the status of many attestation certificates is available through authenticator metadata services.
    See, for example, the FIDO Metadata Service [[FIDOMetadataService]].


## TPM Attestation Statement Format ## {#sctn-tpm-attestation}

This attestation statement format is generally used by authenticators that use a Trusted Platform Module as their cryptographic
engine.

: Attestation statement format identifier
:: tpm

: Attestation types supported
:: [=AttCA=]

: Syntax
:: The syntax of a TPM Attestation statement is as follows:

    ```
    $$attStmtType // = (
                           fmt: "tpm",
                           attStmt: tpmStmtFormat
                       )

    tpmStmtFormat = {
                        ver: "2.0",
                        (
                            alg: COSEAlgorithmIdentifier,
                            x5c: [ aikCert: bytes, * (caCert: bytes) ]
                        )
                        sig: bytes,
                        certInfo: bytes,
                        pubArea: bytes
                    }
    ```

    The semantics of the above fields are as follows:

    : ver
    :: The version of the TPM specification to which the signature conforms.

    : alg
    :: A {{COSEAlgorithmIdentifier}} containing the identifier of the algorithm used to generate the [=attestation signature=].

    : x5c
    :: |aikCert| followed by its certificate chain, in X.509 encoding.

    : aikCert
    :: The AIK certificate used for the attestation, in X.509 encoding.

    : sig
    :: The [=attestation signature=], in the form of a TPMT_SIGNATURE structure as specified in [[!TPMv2-Part2]] section 11.3.4.

    : certInfo
    :: The TPMS_ATTEST structure over which the above signature was computed, as specified in [[!TPMv2-Part2]] section 10.12.8.

    : pubArea
    :: The TPMT_PUBLIC structure (see [[!TPMv2-Part2]] section 12.2.4) used by the TPM to represent the credential public key.

: Signing procedure
:: Let |authenticatorData| denote the [=authenticator data for the attestation=], and let |clientDataHash| denote the
    [=hash of the serialized client data=].

    Concatenate |authenticatorData| and |clientDataHash| to form |attToBeSigned|.

    Generate a signature using the procedure specified in [[!TPMv2-Part3]] Section 18.2, using the attestation private key and
    setting the `extraData` parameter to the digest of |attToBeSigned| using the hash algorithm corresponding to the "alg" signature algorithm.
    (For the "RS256" algorithm, this would be a SHA-256 digest.)

    Set the |pubArea| field to the public area of the credential public key, the |certInfo| field to the output parameter of the
    same name, and the |sig| field to the signature obtained from the above procedure.

: Verification procedure
:: Given the [=verification procedure inputs=] |attStmt|, |authenticatorData| and |clientDataHash|, the [=verification procedure=] is
    as follows:

    Verify that |attStmt| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the
    contained fields.

    Verify that the public key specified by the `parameters` and `unique` fields of |pubArea| is identical to the
    <code>[=credentialPublicKey=]</code> in the <code>[=attestedCredentialData=]</code> in |authenticatorData|.

    Concatenate |authenticatorData| and |clientDataHash| to form |attToBeSigned|.

    Validate that |certInfo| is valid:
    - Verify that `magic` is set to `TPM_GENERATED_VALUE`.
    - Verify that `type` is set to `TPM_ST_ATTEST_CERTIFY`.
    - Verify that `extraData` is set to the hash of |attToBeSigned| using the hash algorithm employed in "alg".
    - Verify that `attested` contains a `TPMS_CERTIFY_INFO` structure as specified in [[!TPMv2-Part2]] section 10.12.3,
        whose `name` field contains a valid Name for |pubArea|,
        as computed using the algorithm in the `nameAlg` field of |pubArea| using the procedure specified in [[!TPMv2-Part1]]
        section 16.
    - Verify that |x5c| is present.
    - Note that the remaining fields in the "Standard Attestation Structure" [[!TPMv2-Part1]]
        section 31.2, i.e., `qualifiedSigner`, `clockInfo` and `firmwareVersion` are ignored.
        These fields MAY be used as an input to risk engines.

    - Verify the |sig| is a valid signature over |certInfo| using the attestation public key in |aikCert| with the
        algorithm specified in |alg|.
    - Verify that |aikCert| meets the requirements in [[#sctn-tpm-cert-requirements]].
    - If |aikCert| contains an extension with OID `1.3.6.1.4.1.45724.1.1.4` (`id-fido-gen-ce-aaguid`) verify that the value of this
        extension matches the <code>[=aaguid=]</code> in |authenticatorData|.
    - If successful, return implementation-specific values representing [=attestation type=] [=AttCA=] and [=attestation trust
        path=] |x5c|.

### TPM Attestation Statement Certificate Requirements ### {#sctn-tpm-cert-requirements}

TPM [=attestation certificate=] MUST have the following fields/extensions:

- Version MUST be set to 3.

- Subject field MUST be set to empty.

- The Subject Alternative Name extension MUST be set as defined in [[!TPMv2-EK-Profile]] section 3.2.9.

- The Extended Key Usage extension MUST contain the OID `2.23.133.8.3`
    ("joint-iso-itu-t(2) internationalorganizations(23) 133 tcg-kp(8) tcg-kp-AIKCertificate(3)").

- The Basic Constraints extension MUST have the CA component set to [FALSE].

- An Authority Information Access (AIA) extension with entry `id-ad-ocsp` and a CRL Distribution Point extension [[RFC5280]] are
    both OPTIONAL as the status of many attestation certificates is available through metadata services.
    See, for example, the FIDO Metadata Service [[FIDOMetadataService]].


## Android Key Attestation Statement Format ## {#sctn-android-key-attestation}

When the [=authenticator=] in question is a [=platform authenticator=] on the Android "N" or later platform, the
attestation statement is based on the [Android key
attestation](https://source.android.com/security/keystore/attestation). In these cases, the attestation statement
is produced by a component running in a secure operating environment, but the [=authenticator data for the attestation=] is
produced outside this environment. The [=[WRP]=] is expected to check that the [=authenticator data claimed to have been used for
the attestation=] is consistent with the fields of the attestation certificate's extension data.


: Attestation statement format identifier
:: android-key

: Attestation types supported
:: [=Basic=]

: Syntax
:: An Android key attestation statement consists simply of the Android attestation statement, which is a series of
    DER encoded X.509 certificates. See
    [the Android developer documentation](https://developer.android.com/training/articles/security-key-attestation.html). Its
    syntax is defined as follows:

    ```
    $$attStmtType //= (
                          fmt: "android-key",
                          attStmt: androidStmtFormat
                      )

    androidStmtFormat = {
                          alg: COSEAlgorithmIdentifier,
                          sig: bytes,
                          x5c: [ credCert: bytes, * (caCert: bytes) ]
                        }

    ```

: Signing procedure
:: Let |authenticatorData| denote the [=authenticator data for the attestation=], and let |clientDataHash| denote the
    [=hash of the serialized client data=].

    Request an Android Key Attestation by calling <code>keyStore.getCertificateChain(myKeyUUID)</code> providing |clientDataHash| as the
    challenge value (e.g., by using <a
    href="https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder.html#setAttestationChallenge(byte%5B%5D)">
    setAttestationChallenge</a>). Set |x5c| to the returned value.

    The authenticator produces |sig| by concatenating |authenticatorData| and |clientDataHash|,
    and signing the result using the credential private key. It sets |alg| to the algorithm of the signature format.


: Verification procedure
:: Given the [=verification procedure inputs=] |attStmt|, |authenticatorData| and |clientDataHash|, the [=verification procedure=] is
    as follows:
    - Verify that |attStmt| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the
        contained fields.
    - Verify that |sig| is a valid signature over the concatenation of |authenticatorData| and |clientDataHash| using the
        public key in the first certificate in |x5c| with the algorithm specified in |alg|.
    - Verify that the public key in the first certificate in |x5c| matches the
        <code>[=credentialPublicKey=]</code> in the <code>[=attestedCredentialData=]</code> in |authenticatorData|.
    - Verify that the `attestationChallenge` field in the [=attestation certificate=]
        [=android key attestation certificate extension data|extension data=] is identical to |clientDataHash|.
    - Verify the following using the appropriate authorization list from the attestation certificate
        [=android key attestation certificate extension data|extension data=]:
        - The `AuthorizationList.allApplications` field is <em>not</em> present on either authorization list
            (`softwareEnforced` nor `teeEnforced`), since PublicKeyCredential MUST be [=scoped=] to the [=RP ID=].
        - For the following, use only the `teeEnforced` authorization list if the RP wants to accept only keys from a
            trusted execution environment, otherwise use the union of `teeEnforced` and `softwareEnforced`.
            - The value in the `AuthorizationList.origin` field is equal to `KM_ORIGIN_GENERATED`.
            - The value in the `AuthorizationList.purpose` field is equal to `KM_PURPOSE_SIGN`.
    - If successful, return implementation-specific values representing [=attestation type=] [=Basic=] and [=attestation trust
        path=] |x5c|.

### Android Key Attestation Statement Certificate Requirements ### {#sctn-key-attstn-cert-requirements}

Android Key Attestation [=attestation certificate=]'s <dfn>android key attestation certificate extension
data</dfn> is identified by the OID `1.3.6.1.4.1.11129.2.1.17`, and its schema is defined in the [Android developer documentation](https://developer.android.com/training/articles/security-key-attestation#certificate_schema).

## Android SafetyNet Attestation Statement Format ## {#sctn-android-safetynet-attestation}

When the [=authenticator=] is a [=platform authenticator=] on certain Android platforms, the attestation
statement may be based on the [SafetyNet API](https://developer.android.com/training/safetynet/attestation#compat-check-response). In
this case the [=authenticator data=] is completely controlled by the caller of the SafetyNet API (typically an application
running on the Android platform) and the attestation statement  provides some statements about the health of the platform
and the identity of the calling application
(see [SafetyNet Documentation](https://developer.android.com/training/safetynet/attestation.html) for more details).

: Attestation statement format identifier
:: android-safetynet

: Attestation types supported
:: [=Basic=]

: Syntax
:: The syntax of an Android Attestation statement is defined as follows:

    ```
    $$attStmtType //= (
                          fmt: "android-safetynet",
                          attStmt: safetynetStmtFormat
                      )

    safetynetStmtFormat = {
                              ver: text,
                              response: bytes
                          }
    ```

    The semantics of the above fields are as follows:

    : ver
    :: The version number of Google Play Services responsible for providing the SafetyNet API.

    : response
    :: The [=UTF-8 encoded=] result of the getJwsResult() call of the SafetyNet API. This value is a JWS [[!RFC7515]] object (see
        [SafetyNet online documentation](https://developer.android.com/training/safetynet/attestation#compat-check-response))
        in Compact Serialization.

: Signing procedure
:: Let |authenticatorData| denote the [=authenticator data for the attestation=], and let |clientDataHash| denote the
    [=hash of the serialized client data=].

    Concatenate |authenticatorData| and |clientDataHash|, perform SHA-256 hash of the concatenated string, and
    let the result of the hash form |attToBeSigned|.

    Request a SafetyNet attestation, providing |attToBeSigned| as the nonce value. Set |response| to the result, and |ver| to
    the version of Google Play Services running in the authenticator.

: Verification procedure
:: Given the [=verification procedure inputs=] |attStmt|, |authenticatorData| and |clientDataHash|, the [=verification procedure=] is
    as follows:
    - Verify that |attStmt| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the
        contained fields.
    - Verify that |response| is a valid SafetyNet response of version |ver|
        by following the steps indicated by the [SafetyNet online documentation](https://developer.android.com/training/safetynet/attestation.html#compat-check-response).
        As of this writing, there is only one format of the SafetyNet response and |ver| is reserved for future use.
    - Verify that the `nonce` attribute in the payload of |response| is identical to the Base64 encoding of the SHA-256 hash of the concatenation of |authenticatorData| and |clientDataHash|.
    - Verify that the SafetyNet response actually came from the SafetyNet service by following the steps in the
        [SafetyNet online documentation](https://developer.android.com/training/safetynet/attestation#compat-check-response).
    - If successful, return implementation-specific values representing [=attestation type=] [=Basic=] and [=attestation trust
        path=] |x5c|.


## FIDO U2F Attestation Statement Format ## {#sctn-fido-u2f-attestation}

This attestation statement format is used with FIDO U2F authenticators using the formats defined in
[[FIDO-U2F-Message-Formats]].

: Attestation statement format identifier
:: fido-u2f

: Attestation types supported
:: [=Basic=], [=AttCA=]

: Syntax
:: The syntax of a FIDO U2F attestation statement is defined as follows:

    ```
    $$attStmtType //= (
                          fmt: "fido-u2f",
                          attStmt: u2fStmtFormat
                      )

    u2fStmtFormat = {
                        x5c: [ attestnCert: bytes ],
                        sig: bytes
                    }
    ```

    The semantics of the above fields are as follows:

    : x5c
    :: A single element array containing the attestation certificate in X.509 format.

    : sig
    :: The [=attestation signature=].
        The signature was calculated over the (raw) U2F registration response message [[!FIDO-U2F-Message-Formats]]
        received by the [=client=] from the authenticator.

: Signing procedure
:: If the [=credential public key=] of the [=attestedCredentialData|attested credential=] is not of algorithm -7 ("ES256"), stop and return an error.
    Otherwise, let |authenticatorData| denote the [=authenticator data for the attestation=],
    and let |clientDataHash| denote the [=hash of the serialized client data=]. (Since SHA-256 is used to hash the
    serialized [=client data=], |clientDataHash| will be 32 bytes long.)

    Generate a Registration Response Message as specified in [[!FIDO-U2F-Message-Formats]] [=Section 4.3=], with the application parameter set to the
    SHA-256 hash of the [=RP ID=] that the given [=public key credential|credential=] is [=scoped=] to, the challenge parameter set to |clientDataHash|, and the key handle
    parameter set to the [=credential ID=] of the given credential. Set the raw signature part of this Registration Response Message (i.e., without the [=user public key=],
    key handle, and attestation certificates) as |sig| and set the attestation certificates of
    the attestation public key as |x5c|.

: Verification procedure
:: Given the [=verification procedure inputs=] |attStmt|, |authenticatorData| and |clientDataHash|, the [=verification procedure=] is
    as follows:
    1. Verify that |attStmt| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the
        contained fields.
    1. Check that |x5c| has exactly one element and let |attCert| be that element. Let |certificate public key| be the public key
        conveyed by |attCert|. If |certificate public key| is not an Elliptic Curve (EC) public
        key over the P-256 curve, terminate this algorithm and return an appropriate error.
    1. Extract the claimed |rpIdHash| from |authenticatorData|, and the claimed |credentialId| and |credentialPublicKey| from
        |authenticatorData|.<code>[=attestedCredentialData=]</code>.
    1. Convert the COSE_KEY formatted |credentialPublicKey| (see [=Section 7=] of [[!RFC9052]]) to Raw ANSI X9.62 public key
        format (see ALG_KEY_ECC_X962_RAW in [=Section 3.6.2 Public Key Representation Formats=] of [[!FIDO-Registry]]).
        - Let |x| be the value corresponding to the "-2" key (representing x coordinate) in |credentialPublicKey|, and confirm its
            size to be of 32 bytes.
            If size differs or "-2" key is not found, terminate this algorithm and return an appropriate error.
        - Let |y| be the value corresponding to the "-3" key (representing y coordinate) in |credentialPublicKey|, and confirm its
            size to be of 32 bytes.
            If size differs or "-3" key is not found, terminate this algorithm and return an appropriate error.
        - Let |publicKeyU2F| be the concatenation <code>0x04 || |x| || |y|</code>.

            Note: This signifies uncompressed ECC key format.
    1. Let |verificationData| be the concatenation of (0x00 || |rpIdHash| ||
        |clientDataHash| || |credentialId| || |publicKeyU2F|) (see [=Section 4.3=] of [[!FIDO-U2F-Message-Formats]]).
    1. Verify the |sig| using |verificationData| and the |certificate public key| per section 4.1.4 of [[!SEC1]] with SHA-256 as the hash function used in step two.
    1. Optionally, inspect |x5c| and consult externally provided knowledge to determine whether |attStmt| conveys a [=Basic=] or
        [=AttCA=] attestation.
    1. If successful, return implementation-specific values representing [=attestation type=] [=Basic=], [=AttCA=] or uncertainty,
        and [=attestation trust path=] |x5c|.

## None Attestation Statement Format ## {#sctn-none-attestation}

The none attestation statement format is used to replace any [=authenticator=]-provided [=attestation statement=] when a [=[WRP]=] indicates it does not wish to receive attestation information, see  [[#enum-attestation-convey]].

The [=authenticator=] MAY also directly generate attestation statements of this format
if the [=authenticator=] does not support [=attestation=].

: Attestation statement format identifier
:: none

: Attestation types supported
:: [=None=]

: Syntax
:: The syntax of a none attestation statement is defined as follows:

    ```
    $$attStmtType //= (
                          fmt: "none",
                          attStmt: emptyMap
                      )

    emptyMap = {}
    ```

: Signing procedure
:: Return the fixed attestation statement defined above.

: Verification procedure
:: Return implementation-specific values representing [=attestation type=] [=None=] and an empty [=attestation trust path=].

## Apple Anonymous Attestation Statement Format ## {#sctn-apple-anonymous-attestation}

This attestation statement format is exclusively used by Apple for certain types of Apple devices that support WebAuthn.

: Attestation statement format identifier
:: apple

: Attestation types supported
:: [=Anonymization CA=]

: Syntax
:: The syntax of an Apple attestation statement is defined as follows:

    ```
    $$attStmtType //= (
                          fmt: "apple",
                          attStmt: appleStmtFormat
                      )

    appleStmtFormat = {
                          x5c: [ credCert: bytes, * (caCert: bytes) ]
                      }
    ```

    The semantics of the above fields are as follows:

    : x5c
    :: |credCert| followed by its certificate chain, each encoded in X.509 format.

    : credCert
    :: The credential public key certificate used for attestation, encoded in X.509 format.

: Signing procedure
::
    1. Let |authenticatorData| denote the authenticator data for the attestation, and let |clientDataHash| denote the [=hash of the serialized client data=].
    2. Concatenate |authenticatorData| and |clientDataHash| to form |nonceToHash|.
    3. Perform SHA-256 hash of |nonceToHash| to produce |nonce|.
    4. Let Apple anonymous attestation CA generate an X.509 certificate for the [=credential public key=] and include the |nonce| as a certificate extension with OID `1.2.840.113635.100.8.2`. |credCert| denotes this certificate. The |credCert| thus serves as a proof of the attestation, and the included |nonce| proves the attestation is live. In addition to that, the |nonce| also protects the integrity of the |authenticatorData| and [=client data=].
    5. Set |x5c| to |credCert| followed by its certificate chain.

: Verification procedure
:: Given the verification procedure inputs |attStmt|, |authenticatorData| and |clientDataHash|, the verification procedure is as follows:
    1. Verify that |attStmt| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the contained fields.
    2. Concatenate |authenticatorData| and |clientDataHash| to form |nonceToHash|.
    3. Perform SHA-256 hash of |nonceToHash| to produce |nonce|.
    4. Verify that |nonce| equals the value of the extension with OID `1.2.840.113635.100.8.2` in |credCert|.
    5. Verify that the [=credential public key=] equals the Subject Public Key of |credCert|.
    6. If successful, return implementation-specific values representing attestation type [=Anonymization CA=] and attestation trust path |x5c|.

# <dfn>WebAuthn Extensions</dfn> # {#sctn-extensions}

The mechanism for generating [=public key credentials=], as well as requesting and generating Authentication assertions, as
defined in [[#sctn-api]], can be extended to suit particular use cases. Each case is addressed by defining a <dfn>registration
extension</dfn> and/or an <dfn>authentication extension</dfn>.

Every extension is a <dfn>client extension</dfn>, meaning that the extension involves communication with and processing by the
client.
[=Client extensions=] define the following steps and data:

- {{CredentialsContainer/create()|navigator.credentials.create()}} extension request parameters and response values for [=registration extensions=].

- {{CredentialsContainer/get()|navigator.credentials.get()}} extension request parameters and response values for [=authentication extensions=].

- [=Client extension processing=] for [=registration extensions=] and [=authentication extensions=].

When creating a [=public key credential=] or requesting an [=authentication assertion=], a [=[WRP]=] can request the use of a set
of extensions. These extensions will be invoked during the requested operation if they are supported by the client and/or the
[=[WAA]=]. The [=[RP]=] sends the [=client extension input=] for each extension in the {{CredentialsContainer/get()}} call
(for [=authentication extensions=]) or {{CredentialsContainer/create()}} call (for [=registration extensions=]) to the [=client=].
The [=client=] performs [=client extension processing=] for each extension that the [=client platform=] supports, and augments the
[=client data=] as specified by each extension, by including the [=extension identifier=] and [=client extension output=]
values.

An extension can also be an <dfn>authenticator extension</dfn>, meaning that the extension involves communication with and
processing by the authenticator. [=Authenticator extensions=] define the following steps and data:

- [=authenticatorMakeCredential=] extension request parameters and response values for [=registration extensions=].

- [=authenticatorGetAssertion=] extension request parameters and response values for [=authentication extensions=].

- [=Authenticator extension processing=] for [=registration extensions=] and [=authentication extensions=].

For [=authenticator extensions=], as part of the [=client extension processing=], the client also creates the [=CBOR=]
[=authenticator extension input=] value for each extension (often based on the corresponding [=client extension input=] value),
and passes them to the authenticator in the {{CredentialsContainer/create()}} call (for [=registration extensions=]) or the
{{CredentialsContainer/get()}} call (for [=authentication extensions=]). These [=authenticator extension input=] values are
represented in [=CBOR=] and passed as name-value pairs, with the [=extension identifier=] as the name, and the corresponding
[=authenticator extension input=] as the value. The authenticator, in turn, performs additional processing for the extensions
that it supports, and returns the [=CBOR=] [=authenticator extension output=] for each as specified by the extension.
Since [=authenticator extension output=] is returned as part of the signed [=authenticator data=], authenticator extensions
MAY also specify an [=unsigned extension output=], e.g. for cases where an output itself depends on [=authenticator data=].
Part of the [=client extension processing=] for [=authenticator extensions=] is to use the [=authenticator extension output=]
and [=unsigned extension output=] as an input to creating the [=client extension output=].

All [=WebAuthn Extensions=] are OPTIONAL for both clients and authenticators. Thus, any extensions requested by a [=[RP]=] MAY be
ignored by the client browser or OS and not passed to the authenticator at all, or they MAY be ignored by the authenticator.
Ignoring an extension is never considered a failure in WebAuthn API processing, so when [=[RPS]=] include extensions with any
API calls, they MUST be prepared to handle cases where some or all of those extensions are ignored.

All [=WebAuthn Extensions=] MUST be defined in such a way that lack of support for them by the [=client=] or [=authenticator=]
does not endanger the user's security or privacy.
For instance, if an extension requires client processing, it could be defined in a manner that ensures
that a naïve pass-through that simply transcodes [=client extension inputs=] from JSON to CBOR
will produce a semantically invalid [=authenticator extension input=] value, resulting in the extension
being ignored by the authenticator. Since all extensions are OPTIONAL, this will not cause a functional failure in the API
operation.

The IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]] can be consulted
for an up-to-date list of registered [=WebAuthn Extensions=].

## Extension Identifiers ## {#sctn-extension-id}

Extensions are identified by a string, called an <dfn>extension identifier</dfn>, chosen by the extension author.

Extension identifiers SHOULD be registered in the
IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].
All registered extension identifiers are unique amongst themselves as a matter of course.

Unregistered extension identifiers SHOULD aim to be globally unique, e.g., by including the defining entity such as
`myCompany_extension`.

All extension identifiers MUST be a maximum of 32 octets in length and MUST consist only of printable USASCII characters,
excluding backslash and doublequote, i.e., VCHAR as defined in [[!RFC5234]] but without %x22 and %x5c. Implementations MUST
match WebAuthn extension identifiers in a case-sensitive fashion.

Extensions that may exist in multiple versions should take care to include a version in their identifier. In effect, different
versions are thus treated as different extensions, e.g., `myCompany_extension_01`

[[#sctn-defined-extensions]] defines an additional set of extensions and their identifiers.
See the IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]]
for an up-to-date list of registered WebAuthn Extension Identifiers.


## Defining Extensions ## {#sctn-extension-specification}

A definition of an extension MUST specify an [=extension identifier=], a [=client extension input=] argument
to be sent via the {{CredentialsContainer/get()}} or {{CredentialsContainer/create()}} call,
the [=client extension processing=] rules, and a [=client extension output=] value.
If the extension communicates with the authenticator (meaning it is an [=authenticator extension=]),
it MUST also specify the [=CBOR=] [=authenticator extension input=] argument
sent via the [=authenticatorGetAssertion=] or [=authenticatorMakeCredential=] call,
the [=authenticator extension processing=] rules, and the [=CBOR=] [=authenticator extension output=] value.
Extensions MAY specify [=unsigned extension outputs=].

Any [=client extension=] that is processed by the client MUST return a [=client extension output=] value so that the [=[WRP]=]
knows that the extension was honored by the client. Similarly, any extension that requires authenticator processing MUST return
an [=authenticator extension output=] to let the [=[RP]=] know that the extension was honored by the authenticator. If an
extension does not otherwise require any result values, it SHOULD be defined as returning a JSON Boolean [=client extension
output=] result, set to [TRUE] to signify that the extension was understood and processed. Likewise, any [=authenticator
extension=] that does not otherwise require any result values MUST return a value and SHOULD return a CBOR Boolean
[=authenticator extension output=] result, set to [TRUE] to signify that the extension was understood and processed.


## Extending Request Parameters ## {#sctn-extension-request-parameters}

An extension defines one or two request arguments. The <dfn>client extension input</dfn>,
which is a value that can be encoded in JSON, is passed from the [=[WRP]=] to the client
in the {{CredentialsContainer/get()}} or {{CredentialsContainer/create()}} call,
while the [=CBOR=] <dfn>authenticator extension input</dfn> is
passed from the client to the authenticator for [=authenticator extensions=] during the processing of these calls.

A [=[RP]=] simultaneously requests the use of an extension and sets its [=client extension input=] by including an entry in the
{{PublicKeyCredentialCreationOptions/extensions}} option to the {{CredentialsContainer/create()}} or {{CredentialsContainer/get()}} call.
The entry key is the [=extension identifier=] and the value is the [=client extension input=].

Note: Other documents have specified extensions where the extension input does not always use the [=extension identifier=]
as the entry key.
New extensions SHOULD follow the above convention.

<pre class="example" highlight="js">
    var assertionPromise = navigator.credentials.get({
        publicKey: {
            // Other members omitted for brevity
            extensions: {
                // An "entry key" identifying the "webauthnExample_foobar" extension,
                // whose value is a map with two input parameters:
                "webauthnExample_foobar": {
                  foo: 42,
                  bar: "barfoo"
                }
            }
        }
    });
</pre>

Extension definitions MUST specify the valid values for their [=client extension input=]. Clients SHOULD ignore extensions with
an invalid [=client extension input=]. If an extension does not require any parameters from the [=[RP]=], it SHOULD be defined
as taking a Boolean client argument, set to [TRUE] to signify that the extension is requested by the [=[RP]=].

Extensions that only affect client processing need not specify [=authenticator extension input=]. Extensions that have
authenticator processing MUST specify the method of computing the [=authenticator extension input=] from the [=client extension
input=],
and MUST define extensions for the [=CDDL=] types
<code>[[#iface-authentication-extensions-authenticator-inputs|AuthenticationExtensionsAuthenticatorInputs]]</code>
and <code>[[#iface-authentication-extensions-authenticator-outputs|AuthenticationExtensionsAuthenticatorOutputs]]</code>
by defining an additional choice for the `$$extensionInput` and `$$extensionOutput` [=group sockets=]
using the [=extension identifier=] as the entry key.
Extensions that do not require input parameters, and are thus defined as taking a Boolean [=client extension input=]
value set to [TRUE],
SHOULD define the [=authenticator extension input=] also as the constant Boolean value [TRUE] (CBOR major type
7, value 21).

The following example defines that an extension with [=extension identifier|identifier=] `webauthnExample_foobar`
takes an unsigned integer as [=authenticator extension input=],
and returns an array of at least one byte string as [=authenticator extension output=]:

<pre class="example">
    $$extensionInput //= (
      webauthnExample_foobar: uint
    )
    $$extensionOutput //= (
      webauthnExample_foobar: [+ bytes]
    )
</pre>

Note: Extensions should aim to define authenticator arguments that are as small as possible. Some authenticators communicate
    over low-bandwidth links such as Bluetooth Low-Energy or NFC.


## <dfn>Client Extension Processing</dfn> ## {#sctn-client-extension-processing}

Extensions MAY define additional processing requirements on the [=client=] during the creation of credentials or the
generation of an assertion. The [=client extension input=] for the extension is used as an input to this client processing.
For each supported [=client extension=], the client adds an entry to the |clientExtensions|  [=map=] with the
[=extension identifier=] as the key, and the extension's [=client extension input=] as the value.

Likewise, the [=client extension outputs=] are represented as a dictionary in the result of {{PublicKeyCredential/getClientExtensionResults()}}
with [=extension identifiers=] as keys, and the <dfn>client extension output</dfn> value of each extension as the value.
Like the [=client extension input=], the [=client extension output=] is a value that can be encoded in JSON.
There MUST NOT be any values returned for ignored extensions.

Extensions that require authenticator processing MUST define
the process by which the [=client extension input=] can be used to determine the [=CBOR=] [=authenticator extension input=] and
the process by which the [=CBOR=] [=authenticator extension output=], and the [=unsigned extension output=] if used, can be
used to determine the [=client extension output=].

## <dfn>Authenticator Extension Processing</dfn> ## {#sctn-authenticator-extension-processing}

The [=CBOR=] [=authenticator extension input=] value of each processed [=authenticator extension=] is included in the |extensions|
parameter of the [=authenticatorMakeCredential=] and [=authenticatorGetAssertion=] operations. The |extensions| parameter is a
[=CBOR=] map where each key is an [=extension identifier=] and the corresponding value is the [=authenticator extension input=]
for that extension.

Likewise, the extension output is represented in the [=authData/extensions=] part of the [=authenticator data=]. The
[=authData/extensions=] part of the [=authenticator data=] is a CBOR map where each key is an [=extension identifier=]
and the corresponding value is the <dfn>authenticator extension output</dfn> for that extension.

<dfn>Unsigned extension outputs</dfn> are represented independently from [=authenticator data=] and returned by authenticators
as a separate map, keyed with the same [=extension identifier=]. This map only contains entries for authenticator
extensions that make use of unsigned outputs.

Note: In [[!FIDO-CTAP]] [=unsigned extension outputs=] are returned as a CBOR map in a top-level field named
`unsignedExtensionOutputs` from both [=authenticatorMakeCredential=] and [=authenticatorGetAssertion=].

For each supported extension, the [=authenticator extension processing=] rule for that extension is used create the
[=authenticator extension output=], and [=unsigned extension output=] if used, from the [=authenticator extension input=]
and possibly also other inputs.
There MUST NOT be any values returned for ignored extensions.


# Defined Extensions # {#sctn-defined-extensions}

This section and its subsections define an additional set of extensions to be registered in the
IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].
These MAY be implemented by user agents targeting broad interoperability.

## Client Extensions ## {#sctn-defined-client-extensions}

This section defines extensions that are only [=client extensions=].

### FIDO <dfn>AppID</dfn> Extension (appid) ### {#sctn-appid-extension}

This extension allows [=[WRPS]=] that have previously registered a
credential using the legacy FIDO U2F JavaScript API [[FIDOU2FJavaScriptAPI]] to request an [=assertion=]. The
FIDO APIs use an alternative identifier for [=[RPS]=] called an |AppID|
[[!FIDO-APPID]], and any credentials created using those APIs will be [=scoped=] to
that identifier. Without this extension, they would need to be re-registered in
order to be [=scoped=] to an [=RP ID=].

In addition to setting the {{AuthenticationExtensionsClientInputs/appid}} extension input,
using this extension requires some additional processing by the [=[RP]=]
in order to allow users to [=authentication|authenticate=] using their registered U2F credentials:

 1. List the desired U2F credentials in the {{PublicKeyCredentialRequestOptions/allowCredentials}} option
     of the {{CredentialsContainer/get()}} method:

     - Set the {{PublicKeyCredentialDescriptor/type}} members to {{PublicKeyCredentialType/public-key}}.
     - Set the {{PublicKeyCredentialDescriptor/id}} members to the respective U2F key handles of the desired credentials. Note that U2F key handles commonly use [=base64url encoding=] but must be decoded to their binary form when used in {{PublicKeyCredentialDescriptor/id}}.

     {{PublicKeyCredentialRequestOptions/allowCredentials}} MAY contain a mixture
     of both WebAuthn [=credential IDs=] and U2F key handles;
     stating the {{AuthenticationExtensionsClientInputs/appid}} via this extension
     does not prevent the user from using a WebAuthn-registered credential
     scoped to the [=RP ID=] stated in {{PublicKeyCredentialRequestOptions/rpId}}.

 1. When [verifying the assertion](#rp-op-verifying-assertion-step-rpid-hash), expect that the <code>[=rpIdHash=]</code>
     MAY be the hash of the |AppID| instead of the [=RP ID=].

This extension does not allow FIDO-compatible credentials to be created. Thus,
credentials created with WebAuthn are not backwards compatible with the FIDO
JavaScript APIs.

Note: {{AuthenticationExtensionsClientInputs/appid}} should be set to the AppID
that the [=[RP]=] *previously* used in the legacy FIDO APIs.
This might not be the same as the result of translating the [=[RP]=]'s WebAuthn [=RP ID=] to the AppID format,
e.g., the previously used AppID may have been "https://accounts.example.com"
but the currently used [=RP ID=] might be "example.com".

: Extension identifier
:: `appid`

: Operation applicability
:: [=authentication extension|Authentication=]

: Client extension input
:: A single USVString specifying a FIDO |AppID|.
    <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientInputs {
      USVString appid;
    };
    </xmp>

: Client extension processing
::  1. Let |facetId| be the result of passing the caller's [=origin=] to the
        FIDO algorithm for [=determining the FacetID of a calling application=].
    1. Let |appId| be the extension input.
    1. Pass |facetId| and |appId| to the FIDO algorithm for [=determining if a
        caller's FacetID is authorized for an AppID=]. If that algorithm rejects
        |appId| then return a "{{SecurityError}}" {{DOMException}}.
    1. When [building allowCredentialDescriptorList](#allowCredentialDescriptorListCreation),
        if a U2F authenticator indicates that a credential is inapplicable (i.e. by
        returning `SW_WRONG_DATA`) then the client MUST retry with the U2F application
        parameter set to the SHA-256 hash of |appId|. If this results in an applicable
        credential, the client MUST include the credential in
        <var ignore>allowCredentialDescriptorList</var>. The value of |appId| then replaces the `rpId`
        parameter of [=authenticatorGetAssertion=].
    1. Let |output| be the Boolean value [FALSE].
    1. When [creating assertionCreationData](#assertionCreationDataCreation),
        if the [=assertion=] was created by a U2F authenticator with the U2F application parameter set to the SHA-256 hash of |appId|
        instead of the SHA-256 hash of the [=RP ID=], set |output| to [TRUE].

Note: In practice, several implementations do not implement steps four and onward of the
algorithm for [=determining if a caller's FacetID is authorized for an AppID=].
Instead, in step three, the comparison on the host is relaxed to accept hosts on the
[=same site=].

: Client extension output
:: Returns the value of |output|. If true, the |AppID| was used and thus, when [verifying the assertion](#rp-op-verifying-assertion-step-rpid-hash), the [=[RP]=] MUST expect the <code>[=rpIdHash=]</code> to be the hash of the |AppID|, not the [=RP ID=].

    <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientOutputs {
      boolean appid;
    };
    </xmp>

: Authenticator extension input
:: None.

: Authenticator extension processing
:: None.

: Authenticator extension output
:: None.

### FIDO AppID Exclusion Extension (appidExclude) ### {#sctn-appid-exclude-extension}

This registration extension allows [=[WRPS]=] to exclude authenticators that contain specified credentials that were created with the legacy FIDO U2F JavaScript API [[FIDOU2FJavaScriptAPI]].

During a transition from the FIDO U2F JavaScript API, a [=[RP]=] may have a population of users with legacy credentials already registered. The [appid](#sctn-appid-extension) extension allows the sign-in flow to be transitioned smoothly but, when transitioning the registration flow, the [excludeCredentials](#dom-publickeycredentialcreationoptions-excludecredentials) field will not be effective in excluding authenticators with legacy credentials because its contents are taken to be WebAuthn credentials. This extension directs [=client platforms=] to consider the contents of [excludeCredentials](#dom-publickeycredentialcreationoptions-excludecredentials) as both WebAuthn and legacy FIDO credentials. Note that U2F key handles commonly use [=base64url encoding=] but must be decoded to their binary form when used in [excludeCredentials](#dom-publickeycredentialcreationoptions-excludecredentials).


: Extension identifier
:: `appidExclude`

: Operation applicability
:: [=registration extension|Registration=]

: Client extension input
:: A single USVString specifying a FIDO |AppID|.
    <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientInputs {
      USVString appidExclude;
    };
    </xmp>

: Client extension processing
:: When [[#sctn-createCredential|creating a new credential]]:
        1. Just after [establishing the RP ID](#CreateCred-DetermineRpId) perform these steps:
            1. Let |facetId| be the result of passing the caller's [=origin=] to the FIDO algorithm
                for [=determining the FacetID of a calling application=].
            1. Let |appId| be the value of the extension input {{AuthenticationExtensionsClientInputs/appidExclude}}.
            1. Pass |facetId| and |appId| to the FIDO algorithm for [=determining if a caller's
                FacetID is authorized for an AppID=]. If the latter algorithm rejects |appId| then
                return a "{{SecurityError}}" {{DOMException}} and terminate the
                [creating a new credential](#sctn-createCredential) algorithm as well as these steps.

                Note: In practice, several implementations do not implement steps four and onward of the algorithm for [=determining if a caller's FacetID is authorized for an AppID=]. Instead, in step three, the comparison on the host is relaxed to accept hosts on the [=same site=].

            1. Otherwise, continue with normal processing.

        1. Just prior to [invoking authenticatorMakeCredential](#CreateCred-InvokeAuthnrMakeCred) perform these steps:
            1. If |authenticator| supports the U2F protocol [[!FIDO-U2F-Message-Formats]], then [=list/for each=]
                [credential descriptor](#dictdef-publickeycredentialdescriptor) |C| in |excludeCredentialDescriptorList|:
                1. Check whether |C| was created using U2F on |authenticator| by sending a
                    `U2F_AUTHENTICATE` message to |authenticator|
                    whose "five parts" are set to the following values:

                        :   |control byte|
                        ::  `0x07` ("check-only")

                        :   <var ignore>challenge parameter</var>
                        ::  32 random bytes

                        :   <var ignore>application parameter</var>
                        ::  SHA-256 hash of |appId|

                        :   <var ignore>key handle length</var>
                        ::  The length of <code>|C|.{{PublicKeyCredentialDescriptor/id}}</code> (in bytes)

                        :   <var ignore>key handle</var>
                        ::  The value of <code>|C|.{{PublicKeyCredentialDescriptor/id}}</code>, i.e., the [=credential id=].

                1. If |authenticator| responds with `message:error:test-of-user-presence-required` (i.e., success):
                    cease normal processing of this |authenticator| and indicate in a platform-specific manner
                    that the authenticator is inapplicable. For example, this could be in the form of UI, or
                    could involve requesting [=user consent=] from |authenticator| and, upon receipt, treating
                    it as if the authenticator had returned {{InvalidStateError}}. Requesting [=user consent=]
                    can be accomplished by sending another `U2F_AUTHENTICATE` message to |authenticator| as
                    above except for setting |control byte| to `0x03` ("enforce-user-presence-and-sign"),
                    and ignoring the response.

            1. Continue with normal processing.

: Client extension output
:: Returns the value [TRUE] to indicate to the [=[RP]=] that the extension was acted upon.
    <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientOutputs {
      boolean appidExclude;
    };
    </xmp>

: Authenticator extension input
:: None.

: Authenticator extension processing
:: None.

: Authenticator extension output
:: None.


### Credential Properties Extension (<dfn>credProps</dfn>) ### {#sctn-authenticator-credential-properties-extension}

This [=client extension|client=] [=registration extension=] facilitates reporting certain [=credential properties=] known by the [=client=] to the requesting [=[WRP]=] upon creation of a [=public key credential source=] as a result of a [=registration ceremony=].

At this time, one [=credential property=] is defined: the [=resident key credential property=]
(i.e., [=client-side discoverable credential property=]).

: Extension identifier
:: `credProps`

: Operation applicability
:: [=registration extension|Registration=]

: Client extension input
:: The Boolean value [TRUE] to indicate that this extension is requested by the [=[RP]=].
    <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientInputs {
        boolean credProps;
    };
    </xmp>

: Client extension processing
::  None, other than to report on credential properties in the output.

: Client extension output
:: [=map/Set=] <code>[=credentialCreationData/clientExtensionResults=]["{{AuthenticationExtensionsClientOutputs/credProps}}"]["rk"]</code> to the value of the |requireResidentKey| parameter that was used in the <a href='#CreateCred-InvokeAuthnrMakeCred'>invocation</a> of the [=authenticatorMakeCredential=] operation.

    <xmp class="idl">
    dictionary CredentialPropertiesOutput {
        boolean rk;
    };

    partial dictionary AuthenticationExtensionsClientOutputs {
        CredentialPropertiesOutput credProps;
    };
    </xmp>

    <div dfn-type="dict-member" dfn-for="CredentialPropertiesOutput">
        :   <dfn>rk</dfn>
        ::  This OPTIONAL property, known abstractly as the <dfn dfn-type="dfn">resident key credential property</dfn>
            (i.e., <dfn dfn-type="dfn">client-side discoverable credential property</dfn>),
            is a Boolean value indicating whether the {{PublicKeyCredential}} returned as a result of a [=registration ceremony=]
            is a [=client-side discoverable credential=].
            If {{rk}} is [TRUE], the credential is a [=discoverable credential=].
            If {{rk}} is [FALSE], the credential is a [=server-side credential=].
            If {{rk}} is not present, it is not known whether the credential is a [=discoverable credential=] or a [=server-side credential=].

            Note: some [=authenticators=] create [=discoverable credentials=] even when not requested by the [=client platform=]. Because of this, [=client platforms=] may be forced to omit the {{rk}} property because they lack the assurance to be able to set it to [FALSE]. [=[RPS]=] should assume that, if the `credProps` extension is supported, then [=client platforms=] will endeavour to populate the {{rk}} property. Therefore a missing {{rk}} indicates that the created credential is most likely a [=non-discoverable credential=].
    </div>


: Authenticator extension input
:: None.

: Authenticator extension processing
:: None.

: Authenticator extension output
:: None.

### Pseudo-random function extension (<dfn>prf</dfn>) ### {#prf-extension}

This [=client extension|client=] [=registration extension=] and [=authentication extension=] allows a [=[RP]=] to evaluate outputs from a pseudo-random function (PRF) associated with a [=credential=]. The PRFs provided by this extension map from {{USVString}}s of any length to 32-byte {{ArrayBuffer}}s.

When requested, if a [=credential=] is created on an [=authenticator=] that supports this extension then either one or two freshly-seeded PRFs are associated with it. If two PRFs are associated then, when outputs are requested, one PRF is evaluated if [=user verification=] is performed and the other is evaluated if only a [=test of user presence|user presence test=] is performed. It is the responsibility of the [=[RP]=] to set the {{PublicKeyCredentialRequestOptions/userVerification}} parameter accordingly: [=[RPS]=] SHOULD *consistently* use either the {{UserVerificationRequirement/required}} or {{UserVerificationRequirement/discouraged}} values of {{UserVerificationRequirement}} when using this extension, otherwise the outputs may vary for a given input. To avoid mistakes, the default value of {{UserVerificationRequirement/preferred}} is prohibited when using this extension during [=assertion=] because that could cause the PRF used to vary between operations if [=user verification=] is later enabled on an [=authenticator=].

As a motivating example, PRF outputs could be used as symmetric keys to encrypt user data. Such encrypted data would be inaccessible without the ability to get assertions from the associated [=credential=]. By using the provision below to evaluate the PRF at two inputs in a single [=assertion=] operation, the encryption key could be periodically rotated during [=assertions=] by choosing a fresh, random input and reencrypting under the new output. If the evaluation inputs are unpredictable then even an attacker who could satisfy [=user verification=], and who had time-limited access to the authenticator, could not learn the encryption key without also knowing the correct PRF input.

This extension is implemented on top of the [[FIDO-CTAP]] `hmac-secret` extension. It is a separate [=client extension=] because `hmac-secret` requires that inputs and outputs be encrypted in a manner that only the user agent can perform, and to provide separation between uses by WebAuthn and any uses by the underlying platform. This separation is achieved by hashing the provided PRF inputs with a context string to prevent evaluation of the PRFs for arbitrary inputs.

Note: this extension may be implemented for [=authenticators=] that do not use [[FIDO-CTAP]] so long as the behavior observed by a [=[RP]=] is identical.

: Extension identifier
:: `prf`

: Operation applicability
:: [=registration extension|Registration=] and [=authentication extension|authentication=]

: Client extension input
::  <xmp class="idl">
    dictionary AuthenticationExtensionsPRFValues {
        required ArrayBuffer first;
        ArrayBuffer second;
    };

    dictionary AuthenticationExtensionsPRFInputs {
        AuthenticationExtensionsPRFValues eval;
        record<USVString, AuthenticationExtensionsPRFValues> evalByCredential;
    };

    partial dictionary AuthenticationExtensionsClientInputs {
        AuthenticationExtensionsPRFInputs prf;
    };
    </xmp>

    <div dfn-type="dict-member" dfn-for="AuthenticationExtensionsPRFInputs">
        :   <dfn>eval</dfn>
        ::  One or two inputs on which to evaluate PRF. Not all [=authenticators=] support evaluating the PRFs during credential creation so outputs may, or may not, be provided. If not, then an [=assertion=] is needed in order to obtain the outputs.

        :   <dfn>evalByCredential</dfn>
        ::  A record mapping [=base64url encoding|base64url encoded=] [=credential IDs=] to PRF inputs to evaluate for that credential. Only applicable during [=assertions=] when {{PublicKeyCredentialRequestOptions/allowCredentials}} is not empty.
    </div>

: Client extension processing ([=registration extension|registration=])
::
       1. If {{AuthenticationExtensionsPRFInputs/evalByCredential}} is present, return a {{DOMException}} whose name is “{{NotSupportedError}}”.
       1. Set `hmac-secret` to [TRUE] in the authenticator extensions input.
       1. If {{AuthenticationExtensionsPRFInputs/eval}} is present and a future extension to [[FIDO-CTAP]] permits evaluation of the PRF at creation time, configure `hmac-secret` inputs accordingly:
           * Let `salt1` be the value of <code>SHA-256(UTF8Encode("WebAuthn PRF") || 0x00 || {{AuthenticationExtensionsPRFInputs/eval}}.{{AuthenticationExtensionsPRFValues/first}})</code>.
           * If <code>{{AuthenticationExtensionsPRFInputs/eval}}.{{AuthenticationExtensionsPRFValues/second}}</code> is present, let `salt2` be the value of <code>SHA-256(UTF8Encode("WebAuthn PRF") || 0x00 || {{AuthenticationExtensionsPRFInputs/eval}}.{{AuthenticationExtensionsPRFValues/second}})</code>.
       1. Set {{AuthenticationExtensionsPRFOutputs/enabled}} to the value of `hmac-secret` in the authenticator extensions output. If not present, set {{AuthenticationExtensionsPRFOutputs/enabled}} to [FALSE].
       1. Set {{AuthenticationExtensionsPRFOutputs/results}} to the decrypted PRF result(s), if any.

Note: If PRF results are obtained during [=registration=] then the [=[RP]=] MUST inspect the [=UV=] bit in the [=flags=] of the response in order to determine the correct value of {{PublicKeyCredentialRequestOptions/userVerification}} for future [=assertions=]. Otherwise results from [=assertions=] may be inconsistent with those from the [=registration=].

: Client extension processing ([=authentication extension|authentication=])
::
      1. If {{PublicKeyCredentialRequestOptions/userVerification}} has the value {{UserVerificationRequirement/preferred}}, return a {{DOMException}} whose name is “{{NotSupportedError}}”.
      1. If {{AuthenticationExtensionsPRFInputs/evalByCredential}} is not empty but {{PublicKeyCredentialRequestOptions/allowCredentials}} is empty, return a {{DOMException}} whose name is “{{NotSupportedError}}”.
      1. Initialize the {{AuthenticationExtensionsClientOutputs/prf}} extension output to an empty dictionary.
      1. Let |ev| be null, and try to find any applicable PRF input(s):
          1. If {{AuthenticationExtensionsPRFInputs/evalByCredential}} is present and [=map/exists|contains=] an [=map/entry=] whose [=map/key=] is the [=base64url encoding=] of the [=credential ID=] that will be returned, let |ev| be the [=map/value=] of that entry.
          1. If |ev| is null and {{AuthenticationExtensionsPRFInputs/eval}} is present, then let |ev| be the value of {{AuthenticationExtensionsPRFInputs/eval}}.
      1. If |ev| is not null:
          1. Let `salt1` be the value of <code>SHA-256(UTF8Encode("WebAuthn PRF") || 0x00 || |ev|.{{AuthenticationExtensionsPRFValues/first}})</code>.
          1. If <code>|ev|.{{AuthenticationExtensionsPRFValues/second}}</code> is present, let `salt2` be the value of <code>SHA-256(UTF8Encode("WebAuthn PRF") || 0x00 || |ev|.{{AuthenticationExtensionsPRFValues/second}})</code>.
          1. Send an `hmac-secret` extension to the [=authenticator=] using the values of `salt1` and, if set, `salt2` as the parameters of the same name in that process.
          1. Decrypt the extension result and set {{AuthenticationExtensionsPRFOutputs/results}} to the PRF result(s), if any.

: Authenticator extension input / processing / output
:: [=prf|This extension=] uses the [[FIDO-CTAP]] `hmac-secret` extension when communicating with the authenticator. It thus does not specify any direct authenticator interaction for [=[RPS]=].

: Client extension output
:: <xmp class="idl">
    dictionary AuthenticationExtensionsPRFOutputs {
        boolean enabled;
        AuthenticationExtensionsPRFValues results;
    };

    partial dictionary AuthenticationExtensionsClientOutputs {
        AuthenticationExtensionsPRFOutputs prf;
    };
    </xmp>

    <div dfn-type="dict-member" dfn-for="AuthenticationExtensionsPRFOutputs">
        :   <dfn>enabled</dfn>
        ::  [TRUE] if, and only if, the one or two PRFs are available for use with the created credential. This is only reported during [=registration=] and is not present in the case of [=authentication=].

        :   <dfn>results</dfn>
        ::  The results of evaluating the PRF for the inputs given in {{AuthenticationExtensionsPRFInputs/eval}} or {{AuthenticationExtensionsPRFInputs/evalByCredential}}. Outputs may not be available during [=registration=]; see comments in {{AuthenticationExtensionsPRFInputs/eval}}.
    </div>

### Large blob storage extension (<dfn>largeBlob</dfn>) ### {#sctn-large-blob-extension}

This [=client extension|client=] [=registration extension=] and [=authentication extension=] allows a [=[RP]=] to store opaque data associated with a credential. Since [=authenticators=] can only store small amounts of data, and most [=[RPS]=] are online services that can store arbitrary amounts of state for a user, this is only useful in specific cases. For example, the [=[RP]=] might wish to issue certificates rather than run a centralised authentication service.

Note: [=[RPS]=] can assume that the opaque data will be compressed when being written to a space-limited device and so need not compress it themselves.

Since a certificate system needs to sign over the public key of the credential, and that public key is only available after creation, this extension does not add an ability to write blobs in the [=registration extension|registration=] context. However, [=[RPS]=] SHOULD use the [=registration extension=] when creating the credential if they wish to later use the [=authentication extension=].

Since certificates are sizable relative to the storage capabilities of typical authenticators, user agents SHOULD consider what indications and confirmations are suitable to best guide the user in allocating this limited resource and prevent abuse.

Note: In order to interoperate, user agents storing large blobs on authenticators using [[!FIDO-CTAP]] are expected to use the provisions detailed in that specification for storing [=large, per-credential blobs=].

Note: [=Roaming authenticators=] that use [[!FIDO-CTAP]] as their cross-platform transport protocol only support this [=largeblob|Large Blob=] extension for [=discoverable credentials=],
and might return an error unless
<code>{{PublicKeyCredentialCreationOptions/authenticatorSelection}}.{{AuthenticatorSelectionCriteria/residentKey}}</code>
is set to {{ResidentKeyRequirement/preferred}} or {{ResidentKeyRequirement/required}}.
However, [=authenticators=] that do not utilize [[!FIDO-CTAP]] do not necessarily restrict this extension to [=discoverable credentials=].

: Extension identifier
:: `largeBlob`

: Operation applicability
:: [=registration extension|Registration=] and [=authentication extension|authentication=]

: Client extension input
::  <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientInputs {
        AuthenticationExtensionsLargeBlobInputs largeBlob;
    };

    enum LargeBlobSupport {
      "required",
      "preferred",
    };

    dictionary AuthenticationExtensionsLargeBlobInputs {
        DOMString support;
        boolean read;
        BufferSource write;
    };
    </xmp>

    <div dfn-type="dict-member" dfn-for="AuthenticationExtensionsLargeBlobInputs">
        :   <dfn>support</dfn>
        ::  A DOMString that takes one of the values of {{LargeBlobSupport}}. (See [[#sct-domstring-backwards-compatibility]].) Only valid during [=registration extension|registration=].

        :   <dfn>read</dfn>
        ::  A boolean that indicates that the [=[RP]=] would like to fetch the previously-written blob associated with the asserted credential. Only valid during [=authentication extension|authentication=].

        :   <dfn>write</dfn>
        ::  An opaque byte string that the [=[RP]=] wishes to store with the existing credential. Only valid during [=authentication extension|authentication=].
    </div>

: Client extension processing ([=registration extension|registration=])
::
       1. If {{AuthenticationExtensionsLargeBlobInputs/read}} or {{AuthenticationExtensionsLargeBlobInputs/write}} is present:
           1. Return a {{DOMException}} whose name is “{{NotSupportedError}}”.
       1. If {{AuthenticationExtensionsLargeBlobInputs/support}} is present and has the value {{LargeBlobSupport/required}}:
           1. Set {{AuthenticationExtensionsLargeBlobOutputs/supported}} to [TRUE].

               Note: This is in anticipation of an authenticator capable of storing large blobs becoming available. It occurs during extension processing in Step 11 of {{PublicKeyCredential/[[Create]]()}}. The {{AuthenticationExtensionsLargeBlobOutputs}} will be abandoned if no satisfactory authenticator becomes available.

           1. If a [=create/candidate authenticator=] becomes available (Step 19 of {{PublicKeyCredential/[[Create]]()}}) then, before evaluating any <code>|options|</code>, [=iteration/continue=] (i.e. ignore the [=create/candidate authenticator=]) if the [=create/candidate authenticator=] is not capable of storing large blobs.
       1. Otherwise (i.e. {{AuthenticationExtensionsLargeBlobInputs/support}} is absent or has the value {{LargeBlobSupport/preferred}}):
           1. If an [=create/selected authenticator|authenticator is selected=] and the [=create/selected authenticator=] supports large blobs, set {{AuthenticationExtensionsLargeBlobOutputs/supported}} to [TRUE], and [FALSE] otherwise.

: Client extension processing ([=authentication extension|authentication=])
::
       1. If {{AuthenticationExtensionsLargeBlobInputs/support}} is present:
           1. Return a {{DOMException}} whose name is “{{NotSupportedError}}”.
       1. If both {{AuthenticationExtensionsLargeBlobInputs/read}} and {{AuthenticationExtensionsLargeBlobInputs/write}} are present:
           1. Return a {{DOMException}} whose name is “{{NotSupportedError}}”.
       1. If {{AuthenticationExtensionsLargeBlobInputs/read}} is present and has the value [TRUE]:
           1. Initialize the [=client extension output=], {{AuthenticationExtensionsClientOutputs/largeBlob}}.
           1. If any authenticator indicates success (in {{PublicKeyCredential/[[DiscoverFromExternalSource]]()}}), attempt to read any largeBlob data associated with the asserted credential.
           1. If successful, set {{AuthenticationExtensionsLargeBlobOutputs/blob}} to the result.

              Note: if the read is not successful, {{AuthenticationExtensionsClientOutputs/largeBlob}} will be present in {{AuthenticationExtensionsClientOutputs}} but the {{AuthenticationExtensionsLargeBlobOutputs/blob}} member will not be present.

       1. If {{AuthenticationExtensionsLargeBlobInputs/write}} is present:
           1. If {{PublicKeyCredentialRequestOptions/allowCredentials}} does not contain exactly one element:
               1. Return a {{DOMException}} whose name is “{{NotSupportedError}}”.
           1. If the [[#sctn-getAssertion|assertion]] operation is successful, attempt to store the contents of {{AuthenticationExtensionsLargeBlobInputs/write}} on the [=authenticator=], associated with the indicated credential.
           1. Set {{AuthenticationExtensionsLargeBlobOutputs/written}} to `true` if successful and `false` otherwise.

: Client extension output
:: <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientOutputs {
        AuthenticationExtensionsLargeBlobOutputs largeBlob;
    };

    dictionary AuthenticationExtensionsLargeBlobOutputs {
        boolean supported;
        ArrayBuffer blob;
        boolean written;
    };
    </xmp>

    <div dfn-type="dict-member" dfn-for="AuthenticationExtensionsLargeBlobOutputs">
        :   <dfn>supported</dfn>
        ::  [TRUE] if, and only if, the created credential supports storing large blobs. Only present in [=registration extension|registration=] outputs.

        :   <dfn>blob</dfn>
        ::  The opaque byte string that was associated with the credential identified by {{PublicKeyCredential/rawId}}. Only valid if {{AuthenticationExtensionsLargeBlobInputs/read}} was `true`.

        :   <dfn>written</dfn>
        ::  A boolean that indicates that the contents of {{AuthenticationExtensionsLargeBlobInputs/write}} were successfully stored on the [=authenticator=], associated with the specified credential.
    </div>


: Authenticator extension processing
:: [=largeblob|This extension=] directs the user-agent to cause the large blob to be stored on, or retrieved from, the authenticator. It thus does not specify any direct authenticator interaction for [=[RPS]=].


## Authenticator Extensions ## {#sctn-defined-authenticator-extensions}

This section defines extensions that are both [=client extensions=] and [=authenticator extensions=].

### <dfn>User Verification Method</dfn> Extension (uvm) ### {#sctn-uvm-extension}

This extension enables use of a user verification method.

: Extension identifier
:: `uvm`

: Operation applicability
:: [=registration extension|Registration=] and [=authentication extension|Authentication=]

: Client extension input
:: The Boolean value [TRUE] to indicate that this extension is requested by the [=[RP]=].
    <xmp class="idl">
    partial dictionary AuthenticationExtensionsClientInputs {
      boolean uvm;
    };
    </xmp>

: Client extension processing
:: None, except creating the authenticator extension input from the client extension input.

: Client extension output
:: Returns a JSON array of 3-element arrays of numbers that encodes the factors in the authenticator extension output.
    <xmp class="idl">
    typedef sequence<unsigned long> UvmEntry;
    typedef sequence<UvmEntry> UvmEntries;

    partial dictionary AuthenticationExtensionsClientOutputs {
      UvmEntries uvm;
    };
    </xmp>

: Authenticator extension input
:: The Boolean value [TRUE], encoded in CBOR (major type 7, value 21).

    ```
    $$extensionInput //= (
      uvm: true,
    )
    ```

: Authenticator extension processing
:: The [=authenticator=] sets the [=authenticator extension output=] to be one or more user verification methods indicating the method(s) used
    by the user to authorize the operation, as defined below. This extension can be added to attestation objects and assertions.

: Authenticator extension output
:: Authenticators can report up to 3 different user verification methods (factors) used in a single authentication instance,
    using the CBOR syntax defined below:

    ```
    $$extensionOutput //= (
      uvm: [ 1*3 uvmEntry ],
    )

    uvmEntry = [
                   userVerificationMethod: uint .size 4,
                   keyProtectionType: uint .size 2,
                   matcherProtectionType: uint .size 2
               ]
    ```

    The semantics of the fields in each `uvmEntry` are as follows:
    : userVerificationMethod
    :: The authentication method/factor used by the authenticator to verify the user. Available values are defined in
        [=Section 3.1 User Verification Methods=] of [[!FIDO-Registry]].

    : keyProtectionType
    :: The method used by the authenticator to protect the FIDO registration private key material. Available values are defined
        in [=Section 3.2 Key Protection Types=] of [[!FIDO-Registry]].

    : matcherProtectionType
    :: The method used by the authenticator to protect the matcher that performs user verification. Available values are defined
        in [=Section 3.3 Matcher Protection Types=] of [[!FIDO-Registry]].

    If >3 factors can be used in an authentication instance the authenticator vendor MUST select the 3 factors it believes
    will be most relevant to the Server to include in the UVM.

    Example for [=authenticator data=] containing one UVM extension for a multi-factor authentication instance where 2 factors
    were used:
    <pre>
        ...                    -- RP ID hash (32 bytes)
        81                     -- UP and ED set
        00 00 00 01            -- (initial) signature counter
        ...                    -- all public key alg etc.
        A1                     -- extension: CBOR map of one element
            63                 -- Key 1: CBOR text string of 3 bytes
                75 76 6d       -- "uvm" [=UTF-8 encoded=] string
            82                 -- Value 1: CBOR array of length 2 indicating two factor usage
                83              -- Item 1: CBOR array of length 3
                    02           -- Subitem 1: CBOR integer for User Verification Method Fingerprint
                    04           -- Subitem 2: CBOR short for Key Protection Type TEE
                    02           -- Subitem 3: CBOR short for Matcher Protection Type TEE
                83              -- Item 2: CBOR array of length 3
                    04           -- Subitem 1: CBOR integer for User Verification Method Passcode
                    01           -- Subitem 2: CBOR short for Key Protection Type Software
                    01           -- Subitem 3: CBOR short for Matcher Protection Type Software
    </pre>


### Device-bound public key extension (<dfn>devicePubKey</dfn>) ### {#sctn-device-publickey-extension}

This [=authenticator extension|authenticator=] [=registration extension=] and [=authentication extension=] provides a [=[RP]=] with a "device continuity" signal for [=backup eligible=] credentials. This is done by creating a [=user credential=]-specific [=hardware-bound device key pair=] on the [=authenticator=], if such a key pair does not already exist for the [=user credential=] being created or exercised, and returning the [=device public key=] along with a signature by the [=device private key=] to the [=[RP]=]. This is done each time this [=devicePubKey=] extension is included with either a {{CredentialsContainer/create()|navigator.credentials.create()}} or {{CredentialsContainer/get()|navigator.credentials.get()}} call.

If the [=authenticator=] is incapable of generating a [=hardware-bound device key pair=], or the registration or authentication operation fails for any reason, this extension is ignored and no [=hardware-bound device key pair=] is created. In this case, there is no [=devicePubKey=] extension output generated.

The [=hardware-bound device key pair=] is not on its own a [=user credential=] and does not have its own [=credential ID=]. Instead, the returned [=device public key=] is a device-specific contextual attribute of its associated [=user credential=]. That is, when that [=user credential=] is used&mdash;along with the [=devicePubKey=] extension&mdash;on a particular [=authenticator=], a particular [=device public key=] is returned by the extension, along with a signature demonstrating proof-of-possession of the [=device private key=] by that device.


#### Relying Party Usage #### {#sctn-device-publickey-extension-usage}

This extension is intended for use by those [=[RPS]=] employing risk-analysis systems informing their sign-in decisions. This extension provides a "device continuity" signal <i>when used consistently</i> with both {{CredentialsContainer/create()|navigator.credentials.create()}} and {{CredentialsContainer/get()|navigator.credentials.get()}} operations:

When a [=[RP]=] uses the `devicePubKey` extension with a {{CredentialsContainer/create()|create()}} call to create a new [=user credential=], a signature by a new [=device-bound key=] ("dpk&nbsp;1") is returned along with the new [=device public key=]. Even if the [=user credential=] is [=backed up=], "dpk&nbsp;1" never leaves the [=generating authenticator=] ("authenticator&nbsp;1"). The [=[RP]=]'s subsequent {{CredentialsContainer/get()|get()}} operations using the same user credential with that <i>same [=authenticator=]</i> generate [=assertions=] including further signatures by the <i>same</i> [=device-bound key=] ("dpk&nbsp;1"). This behavior on "authenticator&nbsp;1" is independent of whether this user credential has been copied to any other [=authenticator=].

Then, if this same user credential is copied to a different [=authenticator=] ("authenticator&nbsp;2"), the [=[RP]=]'s first {{CredentialsContainer/get()|get()}} call on "authenticator&nbsp;2" (that includes the `devicePubKey` extension) will produce an [=assertion=] including a signature by a <i>new</i> [=device-bound key=] ("dpk&nbsp;2"). Note that such a [=multi-device credential=] can be exercised on "authenticator&nbsp;2" without a {{CredentialsContainer/create()|create()}} having been performed on "authenticator&nbsp;2". The [=[RP]=]'s subsequent {{CredentialsContainer/get()|get()}} calls on "authenticator&nbsp;2", using the `devicePubKey` extension and the same user credential, yield further signatures by "dpk&nbsp;2".

A usage example is thus:

> Say that a sign-in request appears at a website along with some geolocation signal that has not been seen for this [=user account=] before, and is outside of the typical usage hours observed for the account. The risk may be deemed high enough not to allow the request, even with an assertion by a [=multi-device credential=] on its own. But if a signature by a [=device-bound key=] that is <i>well established</i> for this user can also be presented, then that may tip the balance.

Note: [=[RPS]=] need to take care to verify [=device-bound key=] signatures before associating and storing extension output value fields in conjunction with the [=user account=]. See [[#sctn-device-publickey-extension-verification]].

The weight that [=[RPS]=] give to the presence of a signature from a [=device-bound key=] may be based on information learned from its optional attestation. An attestation can indicate the level of protection that the hardware offers the private key, certifications for the hardware, etc.

#### Extension Definition #### {#sctn-device-publickey-extension-definition}

: Extension identifier
:: `devicePubKey`

: Operation applicability
:: [=registration extension|Registration=] and [=authentication extension|authentication=]

: Client extension input
:: <xmp class="idl">
    dictionary AuthenticationExtensionsDevicePublicKeyInputs {
        DOMString attestation = "none";
        sequence<DOMString> attestationFormats = [];
    };

    partial dictionary AuthenticationExtensionsClientInputs {
        AuthenticationExtensionsDevicePublicKeyInputs devicePubKey;
    };
    </xmp>
    <div dfn-type="dict-member" dfn-for="AuthenticationExtensionsDevicePublicKeyInputs">
        :   <dfn>attestation</dfn>
        ::  The [=[RP]=] MAY use this OPTIONAL member to specify a preference regarding [=attestation conveyance=].
            Its value SHOULD be a member of {{AttestationConveyancePreference}}.
            [=Client platforms=] MUST ignore unknown values, treating an unknown value as if the [=map/exist|member does not exist=].

            The default value is {{AttestationConveyancePreference/none}}.

        :   <dfn>attestationFormats</dfn>
        ::  The [=[RP]=] MAY use this OPTIONAL member to specify a preference regarding the [=attestation=] statement format used by the [=authenticator=].
            Values SHOULD be taken from the IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].
            Values are ordered from most preferable to least preferable.
            This parameter is advisory and the [=authenticator=] MAY use an attestation statement not enumerated in this parameter.

            The default value is the empty list, which indicates no preference.
    </div>

    Note: To request the `devicePubKey` extension processing with default options, pass an empty dictionary as the input.

: Client extension processing
:: If {{AuthenticationExtensionsClientInputs/devicePubKey}} is present, the client creates the authenticator extension input from the client extension input.

: Client extension output
:: An ArrayBuffer containing the [=device public key attestation object=] that was returned in the authenticator extension output and the signature returned as the [=unsigned extension output=].
    <xmp class="idl">
    dictionary AuthenticationExtensionsDevicePublicKeyOutputs {
        ArrayBuffer authenticatorOutput;
        ArrayBuffer signature;
    };

    partial dictionary AuthenticationExtensionsClientOutputs {
        AuthenticationExtensionsDevicePublicKeyOutputs devicePubKey;
    };
    </xmp>


: Authenticator extension input
:: A CBOR expression of the client extension input

    ```
    devicePublicKeyInputs = {
      attestation: "none" / "indirect" / "direct" / "enterprise",
      attestationFormats: [tstr],
    }
    $$extensionInput //= (
      devicePubKey: devicePublicKeyInputs,
    )
    ```

: Authenticator extension output
:: A byte string containing the CBOR encoding of the <dfn>device public key attestation object</dfn>, defined by the `attObjForDevicePublicKey` type:

    ```
    $$extensionOutput //= (
        devicePubKey: bstr,
    )

    attObjForDevicePublicKey = { ; Note: This object conveys an attested
                                 ; device public key and is analogous to \`attObj\`.

        aaguid:  bstr,  ; Authenticator's AAGUID (16 bytes fixed-length)
                        ; https://www.w3.org/TR/webauthn/#aaguid

        dpk:     bstr,  ; The Device Public Key (self-describing variable length,
                        ; COSE_Key format, CBOR-encoded)).

        ; Whether this key is scoped to the entire device, or a loosely-defined,
        ; narrower scope called "app". For example, a "device"-scoped key is expected
        ; to be the same between an app and a browser on the same device, while
        ; an "app"-scoped key would probably not be.
        ;
        ; Whatever the scope, a device key is still specific to a given credential
        ; and does not provide any ability to link credentials.
        ;
        ; Whether device-scoped or not, keys are still device-bound. I.e. an
        ; app-scoped key does not enjoy lesser protection from extraction.

        scope: uint .size 1,  ; A value of 0x00 means "entire device" ("all apps")
                              ; scope. 0x01 means "per-app" scope.
                              ; Values other than 0x00 or 0x01 are reserved for future
                              ; use.

        ; An authenticator-generated random nonce for inclusion in the attestation
        ; signature. If the authenticator chooses to not generate a nonce, it sets this
        ; to a zero-length byte string. See the note below about "randomNonce" for a
        ; discussion on the nonce's purpose.

        nonce: bstr .size (0..32),

        ; See https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object
        ;
        ; Attestation statement formats define the \`fmt\` and \`attStmt\` members of
        ; $$attStmtType.
        ; Note that \`fmt\` and \`attStmt\` are top-level members of
        ; \`attObjForDevicePublicKey\`.
        ;
        ; In summary, the \`attStmt\` will (typically) contain:
        ;   (1) a SIGNATURE value calculated (using the attestation private key)
        ;       over (prefix || aaguid || dpk || nonce) where \`prefix\` is
        ;       h'64657669636520626f756e64206b6579206174746573746174696f6e20736967
        ;         00ffffffff'.
        ;       (See the attestation calculations section, below, for a discussion
        ;       about the purpose of this \`prefix\` value.)
        ;   (2) the attestation certificate or public key, and supporting certificates,
        ;       if any.
        ;
        ; Note that there are details dependent upon the particular attestation
        ; statement format.
        ; See https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats.

        $$attStmtType,

        ; An optional boolean that indicates whether the attestation statement
        ; contains uniquely identifying information. This can only be true
        ; when the \`attestation\` field of the extension input is "enterprise"
        ; and either the user-agent or the authenticator permits uniquely
        ; identifying attestation for the requested RP ID.

        ? epAtt: bool .default false,
    }

    ```

: Unsigned extension output
:: A CBOR byte string containing a signature generated with the device private key.

: Authenticator extension processing
:: For both [=authenticatorMakeCredential=] and [=authenticatorGetAssertion=] operations:
    1. Create or select the [=public key credential source=] as usual (see [[#sctn-op-make-cred]], or [[#sctn-op-get-assertion]] as appropriate).

    1. If the [=public key credential source=] is not [=backup eligible=] then terminate these processing steps: this extension only applies to [=multi-device credentials=].

    1. If a [=hardware-bound device key pair=] does not already exist for this {[=public key credential source/id|Credential ID=], [=public key credential source/rpId|RP ID=], [=public key credential source/rpId|userHandle=]} tuple on the [=authenticator=], create it using the same public key algorithm as that used by the [=user credential=]'s [=credential key pair=], otherwise locate the existing [=device-bound key=].

    1. Let |attFormat| be the chosen [=attestation statement format=], and |attAaguid| be a 16-byte value, based on the value of {{AuthenticationExtensionsDevicePublicKeyInputs/attestation}} in the extension input:

        <dl class="switch">
            : none
            :: |attFormat| is "none" or "self", at the authenticator's discretion, and |attAaguid| is 16 zero bytes. (Note that, since the [=device-bound key=] is already exercised during {{CredentialsContainer/get()|navigator.credentials.get()}} calls, the proof-of-possession property provided by "self" attestation is superfluous in that context.)

            : indirect, direct
            :: |attFormat| is an [=attestation statement format=] appropriate for this [=authenticator=] based on {{AuthenticationExtensionsDevicePublicKeyInputs/attestationFormats}}, and |attAaguid| is the [=authenticator's=] [=AAGUID=]. (Since the [=hardware-bound device key pair=] is specific to a particular authenticator, its attestation can be tied to hardware roots of trust, although they do not have to be. This is in contrast to the associated [=user credential=]'s attestation, if it is a [=multi-device credential=].)

            : enterprise
            :: The [=[RP]=] wants to receive an [=attestation statement=] that may include uniquely identifying information. This is intended for controlled deployments within an enterprise where the organization wishes to tie registrations to specific authenticators. [=Authenticators=] MUST NOT provide such an attestation unless the user agent or authenticator configuration expressly permits it for the requested [=RP ID=]. If <i>not</i> permitted, then |attFormat| is "none" and |attAaguid| is 16 zero bytes. Otherwise |attFormat| is an [=attestation statement format=] appropriate for this [=authenticator=] based on {{AuthenticationExtensionsDevicePublicKeyInputs/attestationFormats}}, and |attAaguid| is the [=authenticator's=] [=AAGUID=]. (Again, since the [=hardware-bound device key pair=] is specific to a particular authenticator, the attestation may be tied to hardware roots of trust.)

                Note: CTAP2 does not currently provide for an <a href="https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#makecred-enterpriseattestation">enterpriseAttestation</a> signal during an <a href="https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#authenticatorGetAssertion">authenticatorGetAssertion</a> call. Until that is changed, <a href="https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#platform-managed-enterprise-attestation">platform-managed enterprise attestation</a> will not work in that context with CTAP2 [=authenticators=].
        </dl>

    1. Let |dpk| be the newly created or existing [=device public key=], in COSE_Key format [=credentialPublicKey|in the same fashion as for the user credential's credentialPublicKey=] when the latter is conveyed in [=attested credential data=].

    1. Let |devicePrivateKey| be the newly created or existing [=device private key=].

    1. Let |randomNonce| be a fresh randomly-generated byte string of 32 bytes maximum length, or a zero length byte string if the authenticator chooses to not generate a nonce.

        Note: |randomNonce|'s purpose is to randomize the `devicePubKey` extension's [=attestation signature=] value. If this is not done, then the `devicePubKey` extension's [=attestation signature=] value remains constant for all such signatures issued on behalf of this [=user credential=], possibly exposing the [=authenticator=]'s [=attestation private key=] to side-channel attacks. The randomness-generation mechanism should be carefully chosen by the authenticator implementer.

    1. Let the `devicePubKey` [=authenticator extension output=] value be a byte string that encodes a [=CBOR=] map as defined by `attObjForDevicePublicKey` above, with keys and values as follows:

        Note: as with all CBOR structures used in this specification, the [=CTAP2 canonical CBOR encoding form=] MUST be used.

        1. Let the `aaguid` key's value be |attAaguid|.

        1. Let the `dpk` key's value be |dpk|.

        1. Let the `nonce` key's value be |randomNonce|.

        1. Let the `scope` key have the value zero (0x00) if this is an "entire device" [=device public key=]. Otherwise, let `scope` have the value one (0x01), indicating a more narrow per-app scope.

        1. Let the values of the `$$attStmtType` [=group socket=] be the result of generating an [=attestation statement=] with the [=attestation statement format=], |attFormat|. See [[#sctn-device-publickey-attestation-calculations]].

            Note: The details of the `$$attStmtType` values are dependent upon the particular [=attestation statement=] format. See [[#sctn-attestation-formats]]. Since the [=hardware-bound device key pair=] is specific to a particular authenticator, its attestation can be tied to hardware roots of trust (although they do not have to be). This is in contrast to the associated [=user credential=]'s attestation, if it is a [=multi-device credential=].

        1. If the `$$attStmtType` [=group socket=] contains uniquely identifying information then let `epAtt` be [TRUE]. Otherwise omit the `epAtt` field. (This field can only be [TRUE] when the {{AuthenticationExtensionsDevicePublicKeyInputs/attestation}} field of the extension input is "enterprise" and either the user-agent or the authenticator permits uniquely identifying attestation for the requested RP ID.)

    1. Let |dpkSig| be the result of signing the [=assertion signature=] [input](#fig-signature) with |devicePrivateKey|.

        Note: the [=assertion signature=] [input](#fig-signature), and thus |dpkSig|, covers the [=[RP]=]'s {{PublicKeyCredentialCreationOptions/challenge}} because it includes the [=hash of the serialized client data=]. Thus the [=[RP]=] knows that |dpkSig| is a fresh signature.

    1. Output |dpkSig| as the extension's [=unsigned extension output=].

        Note: |dpkSig| cannot be included in the [=authenticator extension output=] because it is returned inside the [=authenticator data=] and that would imply that the signature signs over itself.

##### AAGUIDs ##### {#sctn-device-publickey-attestation-aaguid}

The [=AAGUID=] included in the <code>[=devicePubKey=]</code> extension output, if non-zero, identifies the make or model of hardware that is storing the [=device-bound key=]. This is distinct from the [=AAGUID=] in the [=attested credential data=] of a [=multi-device credential=], which likely identifies something broader since such credentials are not bound to a single device. Thus the two AAGUIDs MAY be different in a single response and either, or both, may be zero depending on the options requested and authenticator behaviour.

##### Attestation calculations ##### {#sctn-device-publickey-attestation-calculations}

When computing attestations, the process in [[#sctn-generating-an-attestation-object]] takes two inputs: `authData` and `hash`. When calculating an attestation for a [=device-bound key=], the typical value for `hash` hashes over the attestation signature itself, which is impossible. Also the attestation of a [=device-bound key=] is potentially used repeatedly, thus may want to be cached. But signing over values that include [=[RP]=]-chosen nonces, like the [=hash of the serialized client data=], makes that impossible.

Therefore when calculating an attestation for a [=device-bound key=], the inputs are:

    * For `authData`, substitute the concatenation of the byte string h'64657669636520626f756e64206b6579206174746573746174696f6e2073696700ffffffff' and the value of |aaguid| from the extension output.
    * For `hash`, substitute the concatenation of the |dpk| and |nonce| fields from the extension output. (The nonce MAY be empty.)

The attestation signature is thus typically calculated over the bytes of <code>(h'64657669636520626f756e64206b6579206174746573746174696f6e2073696700ffffffff' || |aaguid| || |dpk| || |nonce|)</code>. The 37-byte prefix ensures domain separation: it takes the place of the RP ID hash, flags, and signature counter fields in those messages and ensures that no attestation signature for a [=device-bound key=] can be confused with a signature for a [=user credential=].

Note that when |nonce| is empty, then the (signed) authenticator extension output MAY be constant. However, the (unsigned) |dpkSig| output is always unique and prevents replay of the (signed) extension output without knowledge of the [=device private key=].

#### `devicePubKey` Extension Output Verification Procedures #### {#sctn-device-publickey-extension-verification}

Verifying the <code>[=devicePubKey=]</code> extension output is performed by the [=[RP]=] whenever a [=device public key=] is returned within the extension output.

##### Registration (`create()`) ##### {#sctn-device-publickey-extension-verification-create}

If the `devicePubKey` extension was included on a {{CredentialsContainer/create()|navigator.credentials.create()}} call, then the below verification steps are performed in the context of <a href=#reg-ceremony-verify-extension-outputs>this step</a> of [[#sctn-registering-a-new-credential]] using these variables established therein: |credential|, |clientExtensionResults|, |authData|, and |hash|. [=[RP]=] policy may specify whether a response without a `devicePubKey` is acceptable.

1. Let |attObjForDevicePublicKey| be the value of the {{AuthenticationExtensionsClientOutputs/devicePubKey}} member of |clientExtensionResults|.

1. Verify that |attObjForDevicePublicKey| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the contained fields: |aaguid|, |dpk|, |scope|, |nonce|, |fmt|, |attStmt|.

    Note: The latter |attObjForDevicePublicKey| fields are referenced exclusively in the below steps and are not to be confused with other fields with the same names in other portions of the top-level [=attestation object=].

1. Verify that {{AuthenticationExtensionsDevicePublicKeyOutputs/signature}} is a valid signature over the [=assertion signature=] [input](#fig-signature) (i.e. `authData` and `hash`) by the [=device public key=] |dpk|. (The signature algorithm is the same as for the [=user credential=].)

1. Optionally, if attestation was requested and the [=[RP]=] wishes to verify it, verify that |attStmt| is a correct [=attestation statement=], conveying a valid [=attestation signature=], by using the [=attestation statement format=] |fmt|'s [=verification procedure=] given |attStmt|. See [[#sctn-device-publickey-attestation-calculations]]. [=[RP]=] policy may specifiy which attestations are acceptable.

    Note: If |fmt|'s value is "[=none=]" there is no attestation signature to verify.

1. Complete the steps from [[#sctn-registering-a-new-credential]] and, if those steps are successful, store the |aaguid|, |dpk|, |scope|, |fmt|, |attStmt| values indexed to the <code>|credential|.{{Credential/id}}</code> in the [=user account=].

See also [[#sctn-device-publickey-extension-usage]] for further details.

##### Authentication (`get()`) ##### {#sctn-device-publickey-extension-verification-get}

If the `devicePubKey` extension was included on a {{CredentialsContainer/get()|navigator.credentials.get()}} call, then the below verification steps are performed in the context of <a href=#authn-ceremony-verify-extension-outputs>this step</a> of [[#sctn-verifying-assertion]] using these variables established therein: |credential|, |clientExtensionResults|, |authData|, and |hash|. [=[RP]=] policy may specify whether a response without a `devicePubKey` is acceptable.

1. Let |attObjForDevicePublicKey| be the value of the `devicePubKey` member of |clientExtensionResults|.

1. Verify that |attObjForDevicePublicKey| is valid CBOR conforming to the syntax defined above and perform CBOR decoding on it to extract the contained fields: |aaguid|, |dpk|, |scope|, |nonce|, |fmt|, |attStmt|.

    Note: The latter |attObjForDevicePublicKey| fields are referenced exclusively in the below steps and are not to be confused with other fields with the same names in other portions of [=authenticator data=].

1. Verify that {{AuthenticationExtensionsDevicePublicKeyOutputs/signature}} is a valid signature over the [=assertion signature=] [input](#fig-signature) (i.e. `authData` and `hash`) by the [=device public key=] |dpk|. (The signature algorithm is the same as for the [=user credential=].)

1. If the [=[RP]=]'s [=user account=] mapped to the <code>|credential|.{{Credential/id}}</code> in play (i.e., for the user being authenticated) holds `aaguid`, `dpk` and `scope` values corresponding to the extracted |attObjForDevicePublicKey| fields, then perform binary equality checks between the corresponding stored values and the extracted field values. The [=[RP]=] MAY have more than one set of {`aaguid`, `dpk`, `scope`} values mapped to the [=user account=] and <code>|credential|.{{Credential/id}}</code> pair and each set MUST be checked.

    If the above set of binary equality checks resulted in:

    <dl class="switch">
        : more than one match
        :: Some form of error has occurred. It is indeterminate whether this is a known device. Terminate these verification steps.

        : exactly one match
        :: This is likely a known device.

            If |fmt|'s value is "none" then there is no attestation signature to verify and this is a known [=device public key=] with a valid signature and thus a known device. Terminate these verification steps.

            Otherwise, check |attObjForDevicePublicKey|'s |attStmt| by performing a binary equality check between the corresponding stored and extracted |attStmt| values. If the result is:
                <dl class="switch">
                    : successful
                    :: This is a known [=device public key=] with a valid signature and valid attestation and thus a known device. Terminate these verification steps.

                        Note: This authenticator is not generating a fresh per-response random nonce.

                    : unsuccessful
                    :: Optionally, if attestation was requested and the RP wishes to verify it, verify that |attStmt| is a correct [=attestation statement=], conveying a valid [=attestation signature=], by using the [=attestation statement format=] |fmt|'s [=verification procedure=] given |attStmt|. See [[#sctn-device-publickey-attestation-calculations]]. [=[RP]=] policy may specifiy which attestations are acceptable.

                        If the result is:

                        <dl class="switch">
                            : successful
                            :: This is a known [=device public key=] with a valid signature and valid attestation and thus a known device. Terminate these verification steps.

                            : unsuccessful
                            :: Some form of error has occurred. It is indeterminate whether this is a known device. Terminate these verification steps.
                        </dl>
                </dl>

        : zero matches
        :: This is possibly a new [=device public key=] signifying a new device:

            1. If |attObjForDevicePublicKey|.|dpk| did not match any of the [=[RP]=]'s stored |dpk| values for this [=user account=] and <code>|credential|.{{Credential/id}}</code> pair then:

                <dl class="switch">
                    : If |fmt|'s value is "none":
                    :: There is no attestation signature to verify and this is a new device. Unless [=[RP]=] policy specifies that this attestation is unacceptable, store the extracted |aaguid|, |dpk|, |scope|, |fmt|, |attStmt| values indexed to the <code>|credential|.{{Credential/id}}</code> in the [=user account=]. Terminate these verification steps.

                    : Otherwise:
                    :: Optionally, if attestation was requested and the RP wishes to verify it, verify that |attStmt| is a correct [=attestation statement=], conveying a valid [=attestation signature=], by using the [=attestation statement format=] |fmt|'s [=verification procedure=] given |attStmt|. See [[#sctn-device-publickey-attestation-calculations]]. [=[RP]=] policy may specifiy which attestations are acceptable.

                        If the result is:

                        <dl class="switch">
                            : successful
                            :: This is a new [=device public key=] signifying a new device. Complete the steps in [[#sctn-verifying-assertion]] and, if those steps are successful, store the extracted |aaguid|, |dpk|, |scope|, |fmt|, |attStmt| values indexed to the <code>|credential|.{{Credential/id}}</code> in the [=user account=]. Terminate these verification steps.

                            : unsuccessful
                            :: Some form of error has occurred. It is indeterminate whether this is a valid new device. Terminate these verification steps.
                        </dl>
                </dl>

            1. Otherwise there is some form of error: we recieved a known |dpk| value, but one or more of the accompanying |aaguid|, |scope|, or |fmt| values did not match what the [=[RP]=] has stored along with that |dpk| value. Terminate these verification steps.
    </dl>

1. Otherwise, the [=[RP]=] does not have |attObjForDevicePublicKey| fields presently mapped to this [=user account=] and <code>|credential|.{{Credential/id}}</code> pair:

    1. If |fmt|'s value is "none" there is no attestation signature to verify. Complete the steps in [[#sctn-verifying-assertion]] and, if those steps are successful, store the extracted |aaguid|, |dpk|, |scope|, |fmt|, |attStmt| values indexed to the <code>|credential|.{{Credential/id}}</code> in the [=user account=]. Terminate these verification steps.

    1. Otherwise, verify that |attStmt| is a correct [=attestation statement=], conveying a valid [=attestation signature=], by using the [=attestation statement format=] |fmt|'s [=verification procedure=] given |attStmt|. See [[#sctn-device-publickey-attestation-calculations]]. [=[RP]=] policy may specifiy which attestations are acceptable.

        If the result is:

            <dl class="switch">
                : successful
                :: This is the first [=device public key=]&mdash;and thus device&mdash;mapped to this [=user account=] and <code>|credential|.{{Credential/id}}</code> pair. Complete the steps in [[#sctn-verifying-assertion]] and, if those steps are successful, store the extracted |aaguid|, |dpk|, |scope|, |fmt|, |attStmt| values indexed to the <code>|credential|.{{Credential/id}}</code> in the [=user account=]. Terminate these verification steps.

                : unsuccessful
                :: Some form of error has occurred. It is indeterminate whether this is a valid new device. Terminate these verification steps.
            </dl>

See also [[#sctn-device-publickey-extension-usage]].


# User Agent Automation # {#sctn-automation}

For the purposes of user agent automation and [=web application=] testing, this document defines a number of [[WebDriver]] [=extension commands=].

## WebAuthn WebDriver Extension Capability ## {#sctn-automation-webdriver-capability}

In order to advertise the availability of the [=extension commands=] defined below, a new [=extension capability=] is defined.

<figure id="table-virtualAuthenticatorsWebdriverCapability" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>Capability</th>
                <th>Key</th>
                <th>Value Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Virtual Authenticators Support</td>
                <td>`"webauthn:virtualAuthenticators"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] supports all [=Virtual Authenticators=] commands.</td>
            </tr>
        </tbody>
    </table>
</figure>

When [=validating capabilities=], the extension-specific substeps to validate `"webauthn:virtualAuthenticators"` with `value` are the following:

    1. If `value` is not a [=boolean=] return a [=WebDriver Error=] with [=WebDriver error code=] [=invalid argument=].
    2. Otherwise, let `deserialized` be set to `value`.

When [=matching capabilities=], the extension-specific steps to match `"webauthn:virtualAuthenticators"` with `value` are the following:

    1. If `value` is [TRUE] and the [=endpoint node=] does not support any of the [=Virtual Authenticators=] commands,
        the match is unsuccessful.
    2. Otherwise, the match is successful.

### <dfn>Authenticator Extension Capabilities</dfn> ### {#sctn-authenticator-extension-capabilities}

Additionally, [=extension capabilities=] are defined for every [=authenticator extension=]
(i.e. those defining [=authenticator extension processing=]) defined in this specification:

<figure id="table-virtualAuthenticatorsExtensionsWebdriverCapability" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>Capability</th>
                <th>Key</th>
                <th>Value Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>User Verification Method Extension Support</td>
                <td>`"webauthn:extension:uvm"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] WebAuthn WebDriver implementation supports the [=User Verification Method=] extension.</td>
            </tr>
            <tr>
                <td>Pseudo-Random Function Extension Support</td>
                <td>`"webauthn:extension:prf"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] WebAuthn WebDriver implementation supports the [=prf=] extension.</td>
            </tr>
            <tr>
                <td>Large Blob Storage Extension Support</td>
                <td>`"webauthn:extension:largeBlob"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] WebAuthn WebDriver implementation supports the [=largeBlob=] extension.</td>
            </tr>
            <tr>
                <td>credBlob Extension Support</td>
                <td>`"webauthn:extension:credBlob"`</td>
                <td>boolean</td>
                <td>Indicates whether the [=endpoint node=] WebAuthn WebDriver implementation supports the `credBlob` extension defined in [[FIDO-CTAP]].</td>
            </tr>
        </tbody>
    </table>
</figure>

When [=validating capabilities=], the extension-specific substeps to validate an [=authenticator extension capability=] `key` with `value` are the following:

    1. If `value` is not a [=boolean=] return a [=WebDriver Error=] with [=WebDriver error code=] [=invalid argument=].
    2. Otherwise, let `deserialized` be set to `value`.

When [=matching capabilities=], the extension-specific steps to match an [=authenticator extension capability=] `key` with `value` are the following:

    1. If `value` is [TRUE] and the [=endpoint node=] WebAuthn WebDriver implementation does not support the [=authenticator extension=] identified by the `key`,
        the match is unsuccessful.
    2. Otherwise, the match is successful.

User-Agents implementing defined [=authenticator extensions=] SHOULD implement the corresponding [=authenticator extension capability=].

## <dfn>Virtual Authenticators</dfn> ## {#sctn-automation-virtual-authenticators}

These WebDriver [=extension commands=] create and interact with [=Virtual Authenticators=]: software implementations of the
<a>Authenticator Model</a>. <a>Virtual Authenticators</a> are stored in a <dfn>Virtual Authenticator Database</dfn>.
Each stored [=virtual authenticator=] has the following properties:

: <dfn>authenticatorId</dfn>
:: An non-null string made using up to 48 characters from the `unreserved` production defined in Appendix A of [[RFC3986]]
    that uniquely identifies the [=Virtual Authenticator=].
: |protocol|
:: The protocol the [=Virtual Authenticator=] speaks: one of `"ctap1/u2f"`, `"ctap2"` or `"ctap2_1"` [[FIDO-CTAP]].
: |transport|
:: The {{AuthenticatorTransport}} simulated. If the |transport| is set to {{AuthenticatorTransport/internal}}, the
    authenticator simulates [=platform attachment=]. Otherwise, it simulates [=cross-platform attachment=].
: |hasResidentKey|
:: If set to [TRUE] the authenticator will support [=client-side discoverable credentials=].
: |hasUserVerification|
:: If set to [TRUE], the authenticator supports [=user verification=].
: |isUserConsenting|
:: Determines the result of all [=user consent=] [=authorization gestures=], and by extension, any [=test of user presence=]
    performed on the [=Virtual Authenticator=]. If set to [TRUE], a [=user consent=] will always be granted. If set to
    [FALSE], it will not be granted.
: |isUserVerified|
:: Determines the result of [=User Verification=] performed on the [=Virtual Authenticator=]. If set to [TRUE],
    [=User Verification=] will always succeed. If set to [FALSE], it will fail.

    Note: This property has no effect if |hasUserVerification| is set to [FALSE].
: |extensions|
:: A string array containing the [=extension identifiers=] supported by the [=Virtual Authenticator=].

    A [=Virtual authenticator=] MUST support all [=authenticator extensions=] present in its |extensions| array.
    It MUST NOT support any [=authenticator extension=] not present in its |extensions| array.
: |uvm|
:: A {{UvmEntries}} array to be set as the [=authenticator extension output=] when processing the [=User Verification Method=] extension.

    Note: This property has no effect if the [=Virtual Authenticator=] does not support the [=User Verification Method=] extension.

## <dfn>Add Virtual Authenticator</dfn> ## {#sctn-automation-add-virtual-authenticator}

The [=Add Virtual Authenticator=] WebDriver [=extension command=] creates a software [=Virtual Authenticator=]. It is
defined as follows:

<figure id="table-addVirtualAuthenticator" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/webauthn/authenticator`</td>
            </tr>
        </tbody>
    </table>
</figure>

The <dfn>Authenticator Configuration</dfn> is a JSON [=Object=] passed to the [=remote end steps=] as |parameters|. It contains the following |key| and |value| pairs:

<figure id="table-authenticatorConfiguration" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>Key</th>
                <th>Value Type</th>
                <th>Valid Values</th>
                <th>Default</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>|protocol|</td>
                <td>string</td>
                <td>`"ctap1/u2f"`, `"ctap2"`, `"ctap2_1"`</td>
                <td>None</td>
            </tr>
            <tr>
                <td>|transport|</td>
                <td>string</td>
                <td>{{AuthenticatorTransport}} values</td>
                <td>None</td>
            </tr>
            <tr>
                <td>|hasResidentKey|</td>
                <td>boolean</td>
                <td>[TRUE], [FALSE]</td>
                <td>[FALSE]</td>
            </tr>
            <tr>
                <td>|hasUserVerification|</td>
                <td>boolean</td>
                <td>[TRUE], [FALSE]</td>
                <td>[FALSE]</td>
            </tr>
            <tr>
                <td>|isUserConsenting|</td>
                <td>boolean</td>
                <td>[TRUE], [FALSE]</td>
                <td>[TRUE]</td>
            </tr>
            <tr>
                <td>|isUserVerified|</td>
                <td>boolean</td>
                <td>[TRUE], [FALSE]</td>
                <td>[FALSE]</td>
            </tr>
            <tr>
                <td>|extensions|</td>
                <td>string array</td>
                <td>An array containing [=extension identifiers=]</td>
                <td>Empty array</td>
            </tr>
            <tr>
                <td>|uvm|</td>
                <td>{{UvmEntries}}</td>
                <td>Up to 3 [=User Verification Method=] entries</td>
                <td>Empty array</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |parameters| is not a JSON [=Object=], return a [=WebDriver error=] with [=WebDriver error code=]
     [=invalid argument=].

     Note: |parameters| is a [=Authenticator Configuration=] object.
 1. Let |authenticator| be a new [=Virtual Authenticator=].
 1. For each enumerable [=own property=] in |parameters|:
    1. Let |key| be the name of the property.
    1. Let |value| be the result of [=getting a property=] named |key| from |parameters|.
    1. If there is no matching `key` for |key| in |parameters|, return a [=WebDriver error=] with
        [=WebDriver error code=] [=invalid argument=].
    1. If |value| is not one of the `valid values` for that |key|, return a [=WebDriver error=] with [=WebDriver error code=]
        [=invalid argument=].
    1. [=Set a property=] |key| to |value| on |authenticator|.
 1. For each property in [=Authenticator Configuration=] with a default defined:
    1. If `key` is not a defined property of |authenticator|, [=set a property=] `key` to `default` on |authenticator|.
 1. For each property in [=Authenticator Configuration=]:
    1. If `key` is not a defined property of |authenticator|, return a [=WebDriver error=] with [=WebDriver error code=]
        [=invalid argument=].
 1. For each |extension| in |authenticator|.|extensions|:
    1. If |extension| is not an [=extension identifier=] supported by the [=endpoint node=] WebAuthn WebDriver implementation,
        return a [=WebDriver error=] with [=WebDriver error code=] [=unsupported operation=].
 1. Generate a valid unique [=authenticatorId=].
 1. [=Set a property=] `authenticatorId` to |authenticatorId| on |authenticator|.
 1. Store |authenticator| in the [=Virtual Authenticator Database=].
 1. Return [=success=] with data |authenticatorId|.

## <dfn>Remove Virtual Authenticator</dfn> ## {#sctn-automation-remove-virtual-authenticator}

The [=Remove Virtual Authenticator=] WebDriver [=extension command=] removes a previously created [=Virtual Authenticator=].
It is defined as follows:

<figure id="table-removeVirtualAuthenticator" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>DELETE</td>
                <td>`/session/{session id}/webauthn/authenticator/{authenticatorId}`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |authenticatorId| does not match any [=Virtual Authenticator=] stored in the [=Virtual Authenticator
     Database=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Remove the [=Virtual Authenticator=] identified by |authenticatorId| from the [=Virtual Authenticator Database=]
 1. Return [=success=].

## <dfn>Add Credential</dfn> ## {#sctn-automation-add-credential}

The [=Add Credential=] WebDriver [=extension command=] injects a [=Public Key Credential Source=] into an existing
[=Virtual Authenticator=]. It is defined as follows:

<figure id="table-addCredential" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/webauthn/authenticator/{authenticatorId}/credential`</td>
            </tr>
        </tbody>
    </table>
</figure>

The <dfn>Credential Parameters</dfn> is a JSON [=Object=] passed to the [=remote end steps=] as |parameters|. It contains the following |key| and |value| pairs:

<figure id="table-credentialParameters" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>Key</th>
                <th>Description</th>
                <th>Value Type</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>|credentialId|</td>
                <td>The [=public key credential source/id|Credential ID=] encoded using [=Base64url Encoding=].</td>
                <td>string</td>
            </tr>
            <tr>
                <td>|isResidentCredential|</td>
                <td>
                    If set to [TRUE], a [=client-side discoverable credential=] is created. If set to [FALSE], a [=server-side credential=]
                    is created instead.
                </td>
                <td>boolean</td>
            </tr>
            <tr>
                <td>|rpId|</td>
                <td>The [=public key credential source/rpId|Relying Party ID=] the credential is scoped to.</td>
                <td>string</td>
            </tr>
            <tr>
                <td>|privateKey|</td>
                <td>
                    An asymmetric key package containing a single [=public key credential source/privateKey|private key=]
                    per [[RFC5958]], encoded using [=Base64url Encoding=].
                </td>
                <td>string</td>
            </tr>
            <tr>
                <td>|userHandle|</td>
                <td>
                    The [=public key credential source/userHandle=] associated to the credential encoded using
                    [=Base64url Encoding=]. This property may not be defined.
                </td>
                <td>string</td>
            </tr>
            <tr>
                <td>|signCount|</td>
                <td>The initial value for a [=signature counter=] associated to the [=public key credential source=].</td>
                <td>number</td>
            </tr>
            <tr>
                <td>|largeBlob|</td>
                <td>
                    The [=large, per-credential blob=] associated to the [=public key credential source=], encoded using [=Base64url Encoding=].
                    This property may not be defined.
                </td>
                <td>string</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |parameters| is not a JSON [=Object=], return a [=WebDriver error=] with [=WebDriver error code=]
     [=invalid argument=].

     Note: |parameters| is a [=Credential Parameters=] object.
 1. Let |credentialId| be the result of decoding [=Base64url Encoding=] on the |parameters|' |credentialId| property.
 1. If |credentialId| is failure, return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Let |isResidentCredential| be the |parameters|' |isResidentCredential| property.
 1. If |isResidentCredential| is not defined, return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Let |rpId| be the |parameters|' |rpId| property.
 1. If |rpId| is not a valid [=RP ID=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Let |privateKey| be the result of decoding [=Base64url Encoding=] on the |parameters|' |privateKey| property.
 1. If |privateKey| is failure, return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. If |privateKey| is not a validly-encoded asymmetric key package containing a single ECDSA private key on the P-256
     curve per [[RFC5958]], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. If the |parameters|' |userHandle| property is defined:
     1. Let |userHandle| be the result of decoding [=Base64url Encoding=] on the |parameters|' |userHandle| property.
     1. If |userHandle| is failure, return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Otherwise:
    1. If |isResidentCredential| is [TRUE], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
    1. Let |userHandle| be `null`.
 1. If |authenticatorId| does not match any [=Virtual Authenticator=] stored in the [=Virtual Authenticator
     Database=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Let |authenticator| be the [=Virtual Authenticator=] matched by |authenticatorId|.
 1. If |isResidentCredential| is [TRUE] and the |authenticator|'s |hasResidentKey| property is [FALSE], return a
     [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. If the |authenticator| supports the [=largeBlob=] extension and the |parameters|' |largeBlob| feature is defined:
     1. Let |largeBlob| be the result of decoding [=Base64url Encoding=] on the |parameters|' |largeBlob| property.
     1. If |largeBlob| is failure, return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Otherwise:
     1. Let |largeBlob| be `null`.
 1. Let |credential| be a new [=Client-side discoverable Public Key Credential Source=] if |isResidentCredential| is [TRUE]
     or a [=Server-side Public Key Credential Source=] otherwise whose items are:
    : [=public key credential source/type=]
    :: {{public-key}}
    : [=public key credential source/id=]
    :: |credentialId|
    : [=public key credential source/privateKey=]
    :: |privateKey|
    : [=public key credential source/rpId=]
    :: |rpId|
    : [=public key credential source/userHandle=]
    :: |userHandle|
 1. Associate a [=signature counter=] |counter| to the |credential| with a starting value equal to the |parameters|'
     |signCount| or `0` if |signCount| is `null`.
 1. If |largeBlob| is not `null`, set the [=large, per-credential blob=] associated to the |credential| to |largeBlob|.
 1. Store the |credential| and |counter| in the database of the |authenticator|.
 1. Return [=success=].

## <dfn>Get Credentials</dfn> ## {#sctn-automation-get-credentials}

The [=Get Credentials=] WebDriver [=extension command=] returns one [=Credential Parameters=] object for every
[=Public Key Credential Source=] stored in a [=Virtual Authenticator=], regardless of whether they were
stored using [=Add Credential=] or {{CredentialsContainer/create()|navigator.credentials.create()}}. It is defined as follows:

<figure id="table-getCredentials" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>GET</td>
                <td>`/session/{session id}/webauthn/authenticator/{authenticatorId}/credentials`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |authenticatorId| does not match any [=Virtual Authenticator=] stored in the [=Virtual Authenticator
     Database=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Let |credentialsArray| be an empty array.
 1. For each [=Public Key Credential Source=] |credential|, managed by the authenticator identified by |authenticatorId|,
    construct a corresponding [=Credential Parameters=] [=Object=] and add it to |credentialsArray|.
 1. Return [=success=] with data containing |credentialsArray|.

## <dfn>Remove Credential</dfn> ## {#sctn-automation-remove-credential}

The [=Remove Credential=] WebDriver [=extension command=] removes a [=Public Key Credential Source=] stored on a
[=Virtual Authenticator=]. It is defined as follows:

<figure id="table-removeCredential" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>DELETE</td>
                <td>`/session/{session id}/webauthn/authenticator/{authenticatorId}/credentials/{credentialId}`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |authenticatorId| does not match any [=Virtual Authenticator=] stored in the [=Virtual Authenticator
     Database=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Let |authenticator| be the [=Virtual Authenticator=] identified by |authenticatorId|.
 1. If |credentialId| does not match any [=Public Key Credential Source=] managed by |authenticator|, return a [=WebDriver error=]
     with [=WebDriver error code=] [=invalid argument=].
 1. Remove the [=Public Key Credential Source=] identified by |credentialId| managed by |authenticator|.
 1. Return [=success=].

## <dfn>Remove All Credentials</dfn> ## {#sctn-automation-remove-all-credentials}

The [=Remove All Credentials=] WebDriver [=extension command=] removes all [=Public Key Credential Sources=] stored on a
[=Virtual Authenticator=]. It is defined as follows:

<figure id="table-removeAllCredentials" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>DELETE</td>
                <td>`/session/{session id}/webauthn/authenticator/{authenticatorId}/credentials`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |authenticatorId| does not match any [=Virtual Authenticator=] stored in the [=Virtual Authenticator
     Database=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. Remove all [=Public Key Credential Sources=] managed by the [=Virtual Authenticator=] identified by |authenticatorId|.
 1. Return [=success=].

## <dfn>Set User Verified</dfn> ## {#sctn-automation-set-user-verified}

The [=Set User Verified=] [=extension command=] sets the |isUserVerified| property on the [=Virtual Authenticator=]. It
is defined as follows:

<figure id="table-setUserVerified" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/webauthn/authenticator/{authenticatorId}/uv`</td>
            </tr>
        </tbody>
    </table>
</figure>

The [=remote end steps=] are:

 1. If |parameters| is not a JSON [=Object=], return a [=WebDriver error=] with [=WebDriver error code=]
     [=invalid argument=].
 1. If |authenticatorId| does not match any [=Virtual Authenticator=] stored in the [=Virtual Authenticator
     Database=], return a [=WebDriver error=] with [=WebDriver error code=] [=invalid argument=].
 1. If |isUserVerified| is not a defined property of |parameters|, return a [=WebDriver error=] with [=WebDriver error code=]
     [=invalid argument=].
 1. Let |authenticator| be the [=Virtual Authenticator=] identified by |authenticatorId|.
 1. Set the |authenticator|'s |isUserVerified| property to the |parameters|' |isUserVerified| property.
 1. Return [=success=].

# IANA Considerations # {#sctn-IANA}

## WebAuthn Attestation Statement Format Identifier Registrations Updates ## {#sctn-att-fmt-reg-update}

This section updates the below-listed attestation statement formats defined in Section [[#sctn-defined-attestation-formats]] in the
IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]], originally registered in [[WebAuthn-1]], to point to this specification.

- WebAuthn Attestation Statement Format Identifier: packed
- Description: The "packed" attestation statement format is a WebAuthn-optimized format for [=attestation=]. It uses a very
    compact but still extensible encoding method. This format is implementable by authenticators with limited resources (e.g.,
    secure elements).
- Specification Document: Section [[#sctn-packed-attestation]] of this specification
    <br/><br/>
- WebAuthn Attestation Statement Format Identifier: tpm
- Description: The TPM attestation statement format returns an attestation statement in the same format as the packed
    attestation statement format, although the rawData and signature fields are computed differently.
- Specification Document: Section [[#sctn-tpm-attestation]] of this specification
    <br/><br/>
- WebAuthn Attestation Statement Format Identifier: android-key
- Description: [=Platform authenticators=] on versions "N", and later, may provide this proprietary "hardware
    attestation" statement.
- Specification Document: Section [[#sctn-android-key-attestation]] of this specification
    <br/><br/>
- WebAuthn Attestation Statement Format Identifier: android-safetynet
- Description: Android-based [=platform authenticators=] MAY produce an attestation statement based on the Android
    SafetyNet API.
- Specification Document: Section [[#sctn-android-safetynet-attestation]] of this specification
    <br/><br/>
- WebAuthn Attestation Statement Format Identifier: fido-u2f
- Description: Used with FIDO U2F authenticators
- Specification Document: Section [[#sctn-fido-u2f-attestation]] of this specification


## WebAuthn Attestation Statement Format Identifier Registrations ## {#sctn-att-fmt-reg}

This section registers the below-listed attestation statement formats, newly defined in Section [[#sctn-defined-attestation-formats]], in the IANA "WebAuthn Attestation Statement Format Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].

- WebAuthn Attestation Statement Format Identifier: apple
- Description: Used with Apple devices' [=platform authenticators=]
- Specification Document: Section [[#sctn-apple-anonymous-attestation]] of this specification
    <br/><br/>
- WebAuthn Attestation Statement Format Identifier: none
- Description: Used to replace any authenticator-provided attestation statement when a [=[WRP]=] indicates it does not wish to receive attestation information.
- Specification Document: Section [[#sctn-none-attestation]] of this specification




## WebAuthn Extension Identifier Registrations Updates ## {#sctn-extensions-reg-update}

This section updates the below-listed [=extension identifier=] values defined in Section [[#sctn-defined-extensions]] in the IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]], originally registered in [[WebAuthn-1]], to point to this specification.

- WebAuthn Extension Identifier: appid
- Description: This [=authentication extension=] allows [=[WRPS]=] that have previously registered a credential using the legacy
    FIDO JavaScript APIs to request an assertion.
- Specification Document: Section [[#sctn-appid-extension]] of this specification
    <br/><br/>
- WebAuthn Extension Identifier: uvm
- Description: This [=registration extension=] and [=authentication extension=] enables use of a user verification method.
    The user verification method extension returns to the [=[WRP]=] which user verification methods (factors) were
    used for the WebAuthn operation.
- Specification Document: Section [[#sctn-uvm-extension]] of this specification


## WebAuthn Extension Identifier Registrations ## {#sctn-extensions-reg}

This section registers the below-listed [=extension identifier=] values, newly defined in Section [[#sctn-defined-extensions]], in the IANA "WebAuthn Extension Identifiers" registry [[!IANA-WebAuthn-Registries]] established by [[!RFC8809]].

- WebAuthn Extension Identifier: appidExclude
- Description: This registration extension allows [=[WRPS]=] to exclude authenticators that contain specified credentials that were created with the legacy FIDO U2F JavaScript API [[FIDOU2FJavaScriptAPI]].
- Specification Document: Section [[#sctn-appid-exclude-extension]] of this specification
    <br/><br/>
- WebAuthn Extension Identifier: credProps
- Description: This [=client extension|client=] [=registration extension=] enables reporting of a newly-created [=credential=]'s properties,
    as determined by the [=client=], to the calling [=[WRP]=]'s [=web application=].
- Specification Document: Section [[#sctn-authenticator-credential-properties-extension]] of this specification
    <br/><br/>
- WebAuthn Extension Identifier: largeBlob
- Description: This [=client extension|client=] [=registration extension=] and [=authentication extension=] allows a [=[RP]=] to store opaque data associated with a credential.
- Specification Document: Section [[#sctn-large-blob-extension]] of this specification


# Security Considerations # {#sctn-security-considerations}

This specification defines a [[#sctn-api|Web API]] and a cryptographic peer-entity authentication protocol.
The [=Web Authentication API=] allows Web developers (i.e., "authors") to utilize the Web Authentication protocol in their
[=registration=] and [=authentication=] [=ceremonies=].
The entities comprising the Web Authentication protocol endpoints are user-controlled [=[WAA]s=] and a [=[WRP]=]'s
computing environment hosting the [=[RP]=]'s [=web application=].
In this model, the user agent, together with the [=[WAC]=], comprise an intermediary between [=authenticators=] and [=[RPS]=].
Additionally, [=authenticators=] can [=attestation|attest=] to [=[RPS]=] as to their provenance.

At this time, this specification does not feature detailed security considerations. However, the [[FIDOSecRef]] document provides a security analysis which is overall applicable to this specification.
Also, the [[FIDOAuthnrSecReqs]] document suite provides useful information about [=authenticator=] security characteristics.

The below subsections comprise the current Web Authentication-specific security considerations.
They are divided by audience;
general security considerations are direct subsections of this section,
while security considerations specifically for [=authenticator=], [=client=] and [=[RP]=] implementers
are grouped into respective subsections.


## Credential ID Unsigned ## {#sctn-credentialIdSecurity}

The [=credential ID=] is not signed.
This is not a problem because all that would happen if an [=authenticator=] returns
the wrong [=credential ID=], or if an attacker intercepts and manipulates the [=credential ID=], is that the [=[WRP]=] would not look up the correct
[=credential public key=] with which to verify the returned signed [=authenticator data=]
(a.k.a., [=assertion=]), and thus the interaction would end in an error.


## Physical Proximity between Client and Authenticator ## {#sctn-client-authenticator-proximity}

In the WebAuthn [=authenticator model=], it is generally assumed that [=roaming authenticators=]
are physically close to, and communicate directly with, the [=client=].
This arrangement has some important advantages.

The promise of physical proximity between [=client=] and [=authenticator=]
is a key strength of a [=something you have=] [=authentication factor=].
For example, if a [=roaming authenticator=] can communicate only via USB or Bluetooth,
the limited range of these transports ensures that any malicious actor
must physically be within that range in order to interact with the [=authenticator=].
This is not necessarily true of an [=authenticator=] that can be invoked remotely &mdash;
even if the [=authenticator=] verifies [=user present|user presence=],
users can be tricked into authorizing remotely initiated malicious requests.

Direct communication between [=client=] and [=authenticator=]
means the [=client=] can enforce the [=scope=] restrictions for [=credentials=].
By contrast, if the communication between [=client=] and [=authenticator=] is mediated by some third party,
then the [=client=] has to trust the third party to
enforce the [=scope=] restrictions and control access to the [=authenticator=].
Failure to do either could result in
a malicious [=[RP]=] receiving [=authentication assertions=] valid for other [=[RPS]=],
or in a malicious user gaining access to [=authentication assertions=] for other users.

If designing a solution where the [=authenticator=] does not need to be physically close to the [=client=],
or where [=client=] and [=authenticator=] do not communicate directly,
designers SHOULD consider how this affects the enforcement of [=scope=] restrictions
and the strength of the [=authenticator=] as a [=something you have=] authentication factor.


## Security considerations for [=authenticators=] <span id="sctn-attestation-security-considerations"></span> ## {#sctn-security-considerations-authenticator}
<!-- Note: the above <span> is there to preserve the #sctn-attestation-security-considerations anchor although the section it was
tied to has been removed. The section had no text of its own and served only to group the following two subsections together. -->

### Attestation Certificate Hierarchy ### {#sctn-cert-hierarchy}

A 3-tier hierarchy for attestation certificates is RECOMMENDED (i.e., Attestation Root, Attestation Issuing CA, Attestation
Certificate). It is also RECOMMENDED that for each [=[WAA]=] device line (i.e., model), a separate issuing CA is
used to help facilitate isolating problems with a specific version of an authenticator model.

If the attestation root certificate is not dedicated to a single [=[WAA]=] device line (i.e., AAGUID), the AAGUID
SHOULD be specified in the attestation certificate itself, so that it can be verified against the [=authenticator data=].


### Attestation Certificate and Attestation Certificate CA Compromise ### {#sctn-ca-compromise}

When an intermediate CA or a root CA used for issuing attestation certificates is compromised, [=[WAA]=]
[=attestation key pairs=] are still safe although their certificates can no longer be trusted. A [=[WAA]=] manufacturer that
has recorded the [=attestation public keys=] for their [=authenticator=] models can issue new [=attestation certificates=] for these keys from a new
intermediate CA or from a new root CA. If the root CA changes, the [=[WRPS]=]  MUST update their trusted root certificates
accordingly.

A [=[WAA]=] [=attestation certificate=] MUST be revoked by the issuing CA if its [=attestation private key|private key=] has been compromised. A WebAuthn
Authenticator manufacturer may need to ship a firmware update and inject new [=attestation private keys=]
and [=attestation certificate|certificates=] into already
manufactured [=[WAA]s=], if the exposure was due to a firmware flaw. (The process by which this happens is out of
scope for this specification.) If the [=[WAA]=] manufacturer does not have this capability, then it may not be
possible for [=[RPS]=] to trust any further [=attestation statements=] from the affected [=[WAA]s=].

See also the related security consideration for [=[RPS]=] in [[#sctn-revoked-attestation-certificates]].

<!-- no sec cons for clients enumerated at this time
## Security considerations for [=clients=] ## {#sctn-security-considerations-client}
-->

## Security considerations for [=[RPS]=] ## {#sctn-security-considerations-rp}

### Security Benefits for [WRPS] ### {#sctn-rp-benefits}

The main benefits offered to [=[WRPS]=] by this specification include:

1. Users and accounts can be secured using widely compatible, easy-to-use multi-factor authentication.
1. The [=[RP]=] does not need to provision [=authenticator=] hardware to its users. Instead, each user can independently obtain
    any conforming [=authenticator=] and use that same [=authenticator=] with any number of [=[RPS]=]. The [=[RP]=] can optionally
    enforce requirements on [=authenticators=]' security properties by inspecting the [=attestation statements=] returned from the
    [=authenticators=].
1. [=Authentication ceremonies=] are resistant to [=man-in-the-middle attacks=].
    Regarding [=registration ceremonies=], see [[#sctn-attestation-limitations]], below.
1. The [=[RP]=] can automatically support multiple types of [=user verification=] - for example PIN, biometrics and/or future
    methods - with little or no code change, and can let each user decide which they prefer to use via their choice of
    [=authenticator=].
1. The [=[RP]=] does not need to store additional secrets in order to gain the above benefits.

As stated in the [[#sctn-conforming-relying-parties|Conformance]] section, the [=[RP]=] MUST behave as described in [[#sctn-rp-operations]]
to obtain all of the above security benefits. However, one notable use case that departs slightly from this is described below in [[#sctn-attestation-limitations]].


### Visibility Considerations for Embedded Usage ### {#sctn-seccons-visibility}

Simplistic use of WebAuthn in an embedded context, e.g., within <{iframe}>s as described in [[#sctn-iframe-guidance]], may make users vulnerable to <dfn>UI Redressing</dfn> attacks, also known as "[Clickjacking](https://en.wikipedia.org/wiki/Clickjacking)". This is where an attacker overlays their own UI on top of a [=[RP]=]'s intended UI and attempts to trick the user into performing unintended actions with the [=[RP]=]. For example, using these techniques, an attacker might be able to trick users into purchasing items, transferring money, etc.

Even though WebAuthn-specific UI is typically handled by the [=client platform=] and thus is not vulnerable to [=UI Redressing=], it is likely important for an [=[RP]=] having embedded WebAuthn-wielding content to ensure that their content's UI is visible to the user. An emerging means to do so is by observing the status of the experimental [Intersection Observer v2](https://w3c.github.io/IntersectionObserver/v2/)'s `isVisible` attribute. For example, the [=[RP]=]'s script running in the embedded context could pre-emptively load itself in a popup window if it detects `isVisble` being set to `false`, thus side-stepping any occlusion of their content.



### Cryptographic Challenges ### {#sctn-cryptographic-challenges}

As a cryptographic protocol, Web Authentication is dependent upon randomized challenges
to avoid replay attacks. Therefore, the values of both {{PublicKeyCredentialCreationOptions}}.{{PublicKeyCredentialCreationOptions/challenge}} and {{PublicKeyCredentialRequestOptions}}.{{PublicKeyCredentialRequestOptions/challenge}} MUST be randomly generated
by [=[RPS]=] in an environment they trust (e.g., on the server-side), and the
returned {{CollectedClientData/challenge}} value in the client's
response MUST match what was generated. This SHOULD be done in a fashion that does not rely
upon a client's behavior, e.g., the [=[RP]=] SHOULD store the challenge temporarily
until the operation is complete. Tolerating a mismatch will compromise the security
of the protocol.

In order to prevent replay attacks, the challenges MUST contain enough entropy to make guessing them infeasible. Challenges SHOULD
therefore be at least 16 bytes long.


### Attestation Limitations ### {#sctn-attestation-limitations}

[INFORMATIVE]

When [[#sctn-registering-a-new-credential|registering a new credential]], the [=attestation statement=], if present,
may allow the [=[WRP]=] to derive assurances about various [=authenticator=] qualities.
For example, the [=authenticator=] model, or how it stores and protects [=credential private keys=].
However, it is important to note that an [=attestation statement=], on its own,
provides no means for a [=[RP]=] to verify that an [=attestation object=] was generated
by the [=authenticator=] the user intended, and not by a [=man-in-the-middle attack|man-in-the-middle attacker=].
For example, such an attacker could use malicious code injected into [=[RP]=] script.
The [=[RP]=] must therefore rely on other means, e.g., TLS and related technologies,
to protect the [=attestation object=] from [=man-in-the-middle attacks=].

Under the assumption that a [=registration ceremony=] is completed securely, and that the [=authenticator=] maintains
confidentiality of the [=credential private key=], subsequent [=authentication ceremonies=] using that [=public key
credential=] are resistant to tampering by [=man-in-the-middle attacks=].

The discussion above holds for all [=attestation types=]. In all cases it is possible for a [=man-in-the-middle
attack|man-in-the-middle attacker=] to replace the {{PublicKeyCredential}} object, including the [=attestation statement=] and the
[=credential public key=] to be registered, and subsequently tamper with future [=authentication assertions=] [=scoped=] for the
same [=[RP]=] and passing through the same attacker.

Such an attack would potentially be detectable; since the [=[RP]=] has registered the attacker's [=credential public key=] rather
than the user's, the attacker must tamper with all subsequent [=authentication ceremonies=] with that [=[RP]=]: unscathed
ceremonies will fail, potentially revealing the attack.

[=Attestation types=] other than [=Self Attestation=] and [=None=] can increase the difficulty of such attacks, since [=[RPS]=]
can possibly display [=authenticator=] information, e.g., model designation, to the user. An attacker might therefore need to use
a genuine [=authenticator=] of the same model as the user's [=authenticator=], or the user might notice that the [=[RP]=] reports
a different [=authenticator=] model than the user expects.

Note: All variants of [=man-in-the-middle attacks=] described above are more difficult for an attacker to mount
than a [=man-in-the-middle attack=] against conventional password authentication.


### Revoked Attestation Certificates ### {#sctn-revoked-attestation-certificates}

If [=attestation certificate=] validation fails due to a revoked intermediate attestation CA certificate, and the [=[RP]=]'s policy
requires rejecting the registration/authentication request in these situations, then it is RECOMMENDED that the [=[RP]=] also
un-registers (or marks with a trust level equivalent to "[=self attestation=]") [=public key credentials=] that were registered
after the CA compromise date using an [=attestation certificate=] chaining up to the same intermediate CA. It is thus RECOMMENDED
that [=[RPS]=] remember intermediate attestation CA certificates during [=registration=] in order to un-register
related [=public key credentials=] if the [=registration=] was performed after revocation of such certificates.

See also the related security consideration for [=authenticators=] in [[#sctn-ca-compromise]].


### Credential Loss and Key Mobility ### {#sctn-credential-loss-key-mobility}

This specification defines no protocol for backing up [=credential private keys=], or for sharing them between [=authenticators=].
In general, it is expected that a [=credential private key=] never leaves the [=authenticator=] that created it. Losing an
[=authenticator=] therefore, in general, means losing all [=public key credential|credentials=] [=bound credential|bound=] to the
lost [=authenticator=], which could lock the user out of an account if the user has only one [=public key credential|credential=]
registered with the [=[RP]=]. Instead of backing up or sharing private keys, the Web Authentication API allows registering
multiple [=public key credential|credentials=] for the same user. For example, a user might register [=platform credentials=] on
frequently used [=client devices=], and one or more [=roaming credentials=] for use as backup and with new or rarely used [=client
devices=].

[=[RPS]=] SHOULD allow and encourage users to register multiple [=public key credential|credentials=] to the same [=user account=].
[=[RPS]=] SHOULD make use of the <code>{{PublicKeyCredentialCreationOptions/excludeCredentials}}</code> and
<code>{{PublicKeyCredentialCreationOptions/user}}.{{PublicKeyCredentialUserEntity/id}}</code> options to ensure that these
different [=public key credential|credentials=] are [=bound credential|bound=] to different [=authenticators=].


### Unprotected account detection ### {#sctn-unprotected-account-detection}

[INFORMATIVE]

This security consideration applies to [=[RPS]=] that support [=authentication ceremonies=]
with a non-[=list/empty=] {{PublicKeyCredentialRequestOptions/allowCredentials}} argument as the first authentication step.
For example, if using authentication with [=server-side credentials=] as the first authentication step.

In this case the {{PublicKeyCredentialRequestOptions/allowCredentials}} argument risks leaking information
about which [=user accounts=] have WebAuthn credentials registered and which do not,
which may be a signal of account protection strength.
For example, say an attacker can initiate an [=authentication ceremony=] by providing only a username,
and the [=[RP]=] responds with a non-empty {{PublicKeyCredentialRequestOptions/allowCredentials}} for some [=user accounts=],
and with failure or a password challenge for other [=user accounts=].
The attacker can then conclude that the latter [=user accounts=]
likely do not require a WebAuthn [=assertion=] for successful authentication,
and thus focus an attack on those likely weaker accounts.

This issue is similar to the one described in [[#sctn-username-enumeration]]
and [[#sctn-credential-id-privacy-leak]], and can be mitigated in similar ways.


### Code injection attacks ### {#sctn-code-injection}

Any malicious code executing on an
[=determines the set of origins on which the public key credential may be exercised|origin=]
within the [=scope=] of a [=[RP]=]'s [=public key credentials=]
has the potential to invalidate any and all security guarantees WebAuthn may provide.
[=[WAC]s=] only expose the WebAuthn API in [=secure contexts=],
which mitigates the most basic attacks but SHOULD be combined with additional precautions by [=[RPS]=].

Code injection can happen in several ways;
this section attempts to point out some likely scenarios and suggest suitable mitigations,
but is not an exhaustive list.

  - Malicous code could be injected by a third-party script included by the [=[RP]=],
    either intentionally or due to a security vulnerability in the third party.

    The [=[RP]=] therefore SHOULD limit the amount of third-party script included on the
    [=determines the set of origins on which the public key credential may be exercised|origins=]
    within the [=scope=] of its [=credentials=].

    The [=[RP]=] SHOULD use Content Security Policy [[!CSP2]],
    and/or other appropriate technologies available at the time, to limit what script can run on its
    [=determines the set of origins on which the public key credential may be exercised|origins=].

  - Malicious code could, by the credential [=scope=] rules, be hosted on a subdomain of the [=RP ID=].
    For example, user-submitted code hosted on `usercontent.example.org`
    could exercise any [=credentials=] [=scoped=] to the [=RP ID=] `example.org`.
    If the [=[RP]=] allows a subdomain {{CollectedClientData/origin}}
    when [verifying the assertion](#rp-op-verifying-assertion-step-origin),
    malicious users could use this to launch a [=man-in-the-middle attack=]
    to obtain valid [=authentication assertions=] and impersonate the victims of the attack.

    Therefore, the [=[RP]=] by default SHOULD NOT allow a subdomain {{CollectedClientData/origin}}
    when [verifying the assertion](#rp-op-verifying-assertion-step-origin).
    If the [=[RP]=] needs to allow a subdomain {{CollectedClientData/origin}},
    then the [=[RP]=] MUST NOT serve untrusted code on any allowed subdomain of
    [=determines the set of origins on which the public key credential may be exercised|origins=]
    within the [=scope=] of its [=public key credentials=].


# Privacy Considerations # {#sctn-privacy-considerations}

The privacy principles in [[!FIDO-Privacy-Principles]] also apply to this specification.

This section is divided by audience;
general privacy considerations are direct subsections of this section,
while privacy considerations specifically for [=authenticator=], [=client=] and [=[RP]=] implementers
are grouped into respective subsections.


## De-anonymization Prevention Measures ## {#sctn-privacy-attacks}

[INFORMATIVE]

Many aspects of the design of the [=Web Authentication API=] are motivated by privacy concerns. The main concern considered in
this specification is the protection of the user's personal identity, i.e., the identification of a human being or a correlation
of separate identities as belonging to the same human being. Although the [=Web Authentication API=] does not use or provide any
form of global identity, the following kinds of potentially correlatable identifiers are used:

- The user's [=credential IDs=] and [=credential public keys=].

    These are registered by the [=[WRP]=] and subsequently used by the user to prove possession of the corresponding [=credential
    private key=]. They are also visible to the [=client=] in the communication with the [=authenticator=].

- The user's identities specific to each [=[RP]=], e.g., usernames and [=user handles=].

    These identities are obviously used by each [=[RP]=] to identify a user in their system. They are also visible to the
    [=client=] in the communication with the [=authenticator=].

- The user's biometric characteristic(s), e.g., fingerprints or facial recognition data [[ISOBiometricVocabulary]].

    This is optionally used by the [=authenticator=] to perform [=user verification=]. It is not revealed to the [=[RP]=], but in
    the case of [=platform authenticators=], it might be visible to the [=client=] depending on the implementation.

- The models of the user's [=authenticators=], e.g., product names.

    This is exposed in the [=attestation statement=] provided to the [=[RP]=] during [=registration=]. It is also visible to the
    [=client=] in the communication with the [=authenticator=].

- The identities of the user's [=authenticators=], e.g., serial numbers.

    This is possibly used by the [=client=] to enable communication with the [=authenticator=], but is not exposed to the
    [=[RP]=].

Some of the above information is necessarily shared with the [=[RP]=]. The following sections describe the measures taken to
prevent malicious [=[RPS]=] from using it to discover a user's personal identity.


## Anonymous, Scoped, Non-correlatable [=Public Key Credentials=] ## {#sctn-non-correlatable-credentials}

[INFORMATIVE]

Although [=Credential IDs=] and [=credential public keys=] are necessarily shared with the [=[WRP]=] to enable strong
authentication, they are designed to be minimally identifying and not shared between [=[RPS]=].

- [=Credential IDs=] and [=credential public keys=] are meaningless in isolation, as they only identify [=credential key pairs=]
    and not users directly.

- Each [=public key credential=] is strictly [=scoped=] to a specific [=[RP]=], and the [=client=] ensures that its existence is not
    revealed to other [=[RPS]=]. A malicious [=[RP]=] thus cannot ask the [=client=] to reveal a user's other identities.

- The [=client=] also ensures that the existence of a [=public key credential=] is not revealed to the [=[RP]=] without [=user
    consent=]. This is detailed further in [[#sctn-make-credential-privacy]] and [[#sctn-assertion-privacy]]. A malicious [=[RP]=]
    thus cannot silently identify a user, even if the user has a [=public key credential=] registered and available.

- [=Authenticators=] ensure that the [=credential IDs=] and [=credential public keys=] of different [=public key credentials=] are
    not correlatable as belonging to the same user. A pair of malicious [=[RPS]=] thus cannot correlate users between their
    systems without additional information, e.g., a willfully reused username or e-mail address.

- [=Authenticators=] ensure that their [=attestation certificates=] are not unique enough to identify a single [=authenticator=]
    or a small group of [=authenticators=]. This is detailed further in [[#sctn-attestation-privacy]]. A pair of malicious
    [=[RPS]=] thus cannot correlate users between their systems by tracking individual [=authenticators=].

Additionally, a [=client-side discoverable public key credential source=] can optionally include a [=user
handle=] specified by the [=[RP]=]. The [=public key credential|credential=] can then be used to both identify and
[=authentication|authenticate=] the user.
This means that a privacy-conscious [=[RP]=] can allow creation of a [=user account=] without a traditional username,
further improving non-correlatability between [=[RPS]=].


## Authenticator-local [=Biometric Recognition=] ## {#sctn-biometric-privacy}

[=Biometric authenticators=] perform the [=biometric recognition=] internally in the [=authenticator=] - though for [=platform
authenticators=] the biometric data might also be visible to the [=client=], depending on the implementation. Biometric data is
not revealed to the [=[WRP]=]; it is used only locally to perform [=user verification=] authorizing the creation and
[=registration=] of, or [=authentication=] using, a [=public key credential=]. A malicious [=[RP]=] therefore cannot discover the
user's personal identity via biometric data, and a security breach at a [=[RP]=] cannot expose biometric data for an attacker to
use for forging logins at other [=[RPS]=].

In the case where a [=[RP]=] requires [=biometric recognition=], this is performed locally by the [=biometric authenticator=]
perfoming [=user verification=] and then signaling the result by setting the [=authData/flags/UV=] [=flag=] in the signed [=assertion=] response,
instead of revealing the biometric data itself to the [=[RP]=].


## Privacy considerations for [=authenticators=] ## {#sctn-privacy-considerations-authenticator}

### Attestation Privacy ### {#sctn-attestation-privacy}

[=Attestation certificates=] and [=attestation key pairs=] can be used to track users
or link various online identities of the same user together.
This can be mitigated in several ways, including:

- A [=[WAA]=] manufacturer may choose to ship [=authenticators=] in batches
    where [=authenticators=] in a batch share the same [=attestation certificate=] (called [=Basic Attestation=] or [=batch attestation=]).
    This will anonymize the user at the risk of not being able to revoke a particular [=attestation certificate=]
    if its [=attestation private key|private key=] is compromised.
    The [=authenticator=] manufacturer SHOULD then ensure that such batches are large enough to provide meaningful anonymization,
    while also minimizing the batch size in order to limit the number of affected users
    in case an [=attestation private key=] is compromised.

    [[UAFProtocol]] requires that at least 100,000 [=authenticator=] devices share the same [=attestation certificate=] in order to produce
    sufficiently large groups. This may serve as guidance about suitable batch sizes.

- A [=[WAA]=] may be capable of dynamically generating different [=attestation key pairs=] (and requesting related
    [=attestation certificate|certificates=]) per-[=credential=] as described in the [=Anonymization CA=] approach. For example, an [=authenticator=] can ship with a
    main [=attestation private key=] (and [=attestation certificate|certificate=]),
    and combined with a cloud-operated [=Anonymization CA=],
    can dynamically generate per-[=credential=] [=attestation key pairs=] and [=attestation certificates=].

    Note: In various places outside this specification, the term "Privacy CA" is used to refer to what is termed here
        as an [=Anonymization CA=]. Because the Trusted Computing Group (TCG) also used the term "Privacy CA" to refer to what
        the TCG now refers to as an [=Attestation CA=] (ACA) [[!TCG-CMCProfile-AIKCertEnroll]], we are using the term [=Anonymization CA=] here to try to mitigate
        confusion in the specific context of this specification.


### Privacy of [PII] Stored in Authenticators ### {#sctn-pii-privacy}

[=Authenticators=] MAY provide additional information to [=clients=] outside what's defined by this specification, e.g.,
to enable the [=client=] to provide a rich UI with which the user can pick which [=credential=] to use for an [=authentication
ceremony=]. If an [=authenticator=] chooses to do so, it SHOULD NOT expose [PII] unless successful [=user verification=] has been
performed. If the [=authenticator=] supports [=user verification=] with more than one concurrently enrolled user, the
[=authenticator=] SHOULD NOT expose [PII] of users other than the currently [=user verified|verified=] user. Consequently, an
[=authenticator=] that is not capable of [=user verification=] SHOULD NOT store [PII].

For the purposes of this discussion, the [=user handle=] conveyed as the {{PublicKeyCredentialUserEntity/id}} member of
{{PublicKeyCredentialUserEntity}} is not considered [PII]; see [[#sctn-user-handle-privacy]].

These recommendations serve to prevent an adversary with physical access to an [=authenticator=] from extracting [PII] about the
[=authenticator=]'s enrolled user(s).


## Privacy considerations for [=clients=] ## {#sctn-privacy-considerations-client}

### Registration Ceremony Privacy ### {#sctn-make-credential-privacy}

In order to protect users from being identified without [=user consent|consent=], implementations of the
{{PublicKeyCredential/[[Create]](origin, options, sameOriginWithAncestors)}} method need to take care to not leak information that
could enable a malicious [=[WRP]=] to distinguish between these cases, where "excluded" means that at least one of the [=public key
credential|credentials=] listed by the [=[RP]=] in {{PublicKeyCredentialCreationOptions/excludeCredentials}} is [=bound credential|bound=] to the
[=authenticator=]:

- No [=authenticators=] are present.
- At least one [=authenticator=] is present, and at least one present [=authenticator=] is excluded.

If the above cases are distinguishable, information is leaked by which a malicious [=[RP]=] could identify the user by probing for
which [=public key credential|credentials=] are available. For example, one such information leak is if the client returns a
failure response as soon as an excluded [=authenticator=] becomes available. In this case - especially if the excluded
[=authenticator=] is a [=platform authenticator=] - the [=[RP]=] could detect that the [=ceremony=] was canceled before the
timeout and before the user could feasibly have canceled it manually, and thus conclude that at least one of the [=public key
credential|credentials=] listed in the {{PublicKeyCredentialCreationOptions/excludeCredentials}} parameter is available to the user.

The above is not a concern, however, if the user has [=user consent|consented=] to create a new credential before a
distinguishable error is returned, because in this case the user has confirmed intent to share the information that would be
leaked.


### Authentication Ceremony Privacy ### {#sctn-assertion-privacy}

In order to protect users from being identified without [=user consent|consent=], implementations of the
{{PublicKeyCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)}} method need to take care to not
leak information that could enable a malicious [=[WRP]=] to distinguish between these cases, where "named" means that the [=public
key credential|credential=] is listed by the [=[RP]=] in {{PublicKeyCredentialRequestOptions/allowCredentials}}:

- A named [=public key credential|credential=] is not available.
- A named [=public key credential|credential=] is available, but the user does not [=user consent|consent=] to use it.

If the above cases are distinguishable, information is leaked by which a malicious [=[RP]=] could identify the user by probing
for which [=public key credential|credentials=] are available. For example, one such information leak is if the client returns a
failure response as soon as the user denies [=user consent|consent=] to proceed with an [=authentication ceremony=]. In this
case the [=[RP]=] could detect that the [=ceremony=] was canceled by the user and not the timeout, and thus conclude that at least
one of the [=public key credential|credentials=] listed in the {{PublicKeyCredentialRequestOptions/allowCredentials}} parameter is
available to the user.


### Privacy Between Operating System Accounts ### {#sctn-os-account-privacy}

If a [=platform authenticator=] is included in a [=client device=] with a multi-user operating system, the [=platform
authenticator=] and [=client device=] SHOULD work together to ensure that the existence of any [=platform credential=] is revealed
only to the operating system user that created that [=platform credential=].


## Privacy considerations for [=[RPS]=] ## {#sctn-privacy-considerations-rp}

### User Handle Contents ### {#sctn-user-handle-privacy}

Since the [=user handle=] is not considered [PII] in [[#sctn-pii-privacy]],
and since [=authenticators=] MAY reveal [=user handles=] without first performing [=user verification=],
the [=[RP]=] MUST NOT include [PII], e.g., e-mail
addresses or usernames, in the [=user handle=]. This includes hash values of [PII], unless the hash
function is [=salted=] with [=salt=] values private to the [=[RP]=], since hashing does not prevent probing for guessable input
values. It is RECOMMENDED to let the [=user handle=] be 64 random bytes, and store this value in the [=user account=].


### Username Enumeration ### {#sctn-username-enumeration}

While initiating a [=registration ceremony|registration=] or [=authentication ceremony=], there is a risk that the [=[WRP]=] might leak sensitive
information about its registered users. For example, if a [=[RP]=] uses e-mail addresses as usernames and an attacker attempts to
initiate an [=authentication=] [=ceremony=] for "alex.mueller@example.com" and the [=[RP]=] responds with a failure, but then
successfully initiates an [=authentication ceremony=] for "j.doe@example.com", then the attacker can conclude that "j.doe@example.com"
is registered and "alex.mueller@example.com" is not. The [=[RP]=] has thus leaked the possibly sensitive information that
"j.doe@example.com" has a [=user account=] at this [=[RP]=].

The following is a non-normative, non-exhaustive list of measures the [=[RP]=] may implement to mitigate or prevent information
leakage due to such an attack:

- For [=registration ceremonies=]:

    - If the [=[RP]=] uses [=[RP]=]-specific usernames to identify users:

        - When initiating a [=registration ceremony=], disallow registration of usernames that are syntactically valid e-mail
            addresses.

            Note: The motivation for this suggestion is that in this case the [=[RP]=] probably has no choice but to fail the
            [=registration ceremony=] if the user attempts to register a username that is already registered, and an information
            leak might therefore be unavoidable. By disallowing e-mail addresses as usernames, the impact of the leakage can be
            mitigated since it will be less likely that a user has the same username at this [=[RP]=] as at other [=[RPS]=].

    - If the [=[RP]=] uses e-mail addresses to identify users:

        - When initiating a [=registration ceremony=], interrupt the user interaction after the e-mail address is supplied and
            send a message to this address, containing an unpredictable one-time code and instructions for how to use it to
            proceed with the ceremony. Display the same message to the user in the web interface regardless of the contents of the
            sent e-mail and whether or not this e-mail address was already registered.

            Note: This suggestion can be similarly adapted for other externally meaningful identifiers, for example, national ID
            numbers or credit card numbers &mdash; if they provide similar out-of-band contact information, for example,
            conventional postal address.

- For [=authentication ceremonies=]:

    - If, when initiating an [=authentication ceremony=], there is no [=user account=] matching the provided username, continue the
        ceremony by invoking {{CredentialsContainer/get()|navigator.credentials.get()}} using a syntactically valid
        {{PublicKeyCredentialRequestOptions}} object that is populated with plausible imaginary values.

        This approach could also be used to mitigate information leakage via {{PublicKeyCredentialRequestOptions/allowCredentials}};
        see [[#sctn-unprotected-account-detection]] and [[#sctn-credential-id-privacy-leak]].

        Note: The username may be "provided" in various [=[RP]=]-specific fashions: login form, session cookie, etc.

        Note: If returned imaginary values noticeably differ from actual ones, clever attackers may be able to discern them and
            thus be able to test for existence of actual accounts. Examples of noticeably different values include if the values
            are always the same for all username inputs, or are different in repeated attempts with the same username input. The
            {{PublicKeyCredentialRequestOptions/allowCredentials}} member could therefore be populated with pseudo-random values
            derived deterministically from the username, for example.

    - When verifying an {{AuthenticatorAssertionResponse}} response from the [=authenticator=], make it indistinguishable whether
          verification failed because the signature is invalid or because no such user or credential is registered.

    - Perform a multi-step [=authentication ceremony=], e.g., beginning with supplying username and password or a session cookie,
        before initiating the WebAuthn [=ceremony=] as a subsequent step.
        This moves the username enumeration problem from the WebAuthn step
        to the preceding authentication step, where it may be easier to solve.


### Privacy leak via credential IDs ### {#sctn-credential-id-privacy-leak}

[INFORMATIVE]

This privacy consideration applies to [=[RPS]=] that support [=authentication ceremonies=]
with a non-[=list/empty=] {{PublicKeyCredentialRequestOptions/allowCredentials}} argument as the first authentication step.
For example, if using authentication with [=server-side credentials=] as the first authentication step.

In this case the {{PublicKeyCredentialRequestOptions/allowCredentials}} argument risks leaking [PII],
since it exposes the user's [=credential IDs=] to an unauthenticated caller.
[=Credential IDs=] are designed to not be correlatable between [=[RPS]=],
but the length of a [=credential ID=] might be a hint as to what type of [=authenticator=] created it.
It is likely that a user will use the same username and set of [=authenticators=] for several [=[RPS]=],
so the number of [=credential IDs=] in {{PublicKeyCredentialRequestOptions/allowCredentials}} and their lengths
might serve as a global correlation handle to de-anonymize the user.
Knowing a user's [=credential IDs=] also makes it possible to confirm guesses about the user's identity
given only momentary physical access to one of the user's [=authenticators=].

In order to prevent such information leakage, the [=[RP]=] could for example:

- Perform a separate authentication step,
    such as username and password authentication or session cookie authentication,
    before initiating the WebAuthn [=authentication ceremony=] and exposing the user's [=credential IDs=].
- Use [=client-side discoverable credentials=],
    so the {{PublicKeyCredentialRequestOptions/allowCredentials}} argument is not needed.

If the above prevention measures are not available,
i.e., if {{PublicKeyCredentialRequestOptions/allowCredentials}} needs to be exposed given only a username,
the [=[RP]=] could mitigate the privacy leak using the same approach of returning imaginary [=credential IDs=]
as discussed in [[#sctn-username-enumeration]].


# Accessibility Considerations # {#sctn-accessiblility-considerations}

[=User verification=]-capable [=authenticators=], whether [=roaming authenticators|roaming=] or [=platform authenticators|platform=], should offer users more than one user verification method.  For example, both fingerprint sensing and PIN entry. This allows for fallback to other user verification means if the selected one is not working for some reason. Note that in the case of [=roaming authenticators=], the authenticator and platform might work together to provide a user verification method such as PIN entry [[FIDO-CTAP]].

[=[RPS]=], at [=registration=] time, SHOULD provide affordances for users to complete future [=authorization gestures=] correctly. This could involve naming the authenticator, choosing a picture to associate with the device, or entering freeform text instructions (e.g., as a reminder-to-self).

[=Ceremonies=] relying on timing, e.g., a [=registration ceremony=] (see {{PublicKeyCredentialCreationOptions/timeout}}) or an [=authentication ceremony=] (see {{PublicKeyCredentialRequestOptions/timeout}}), ought to follow [[!WCAG21]]'s [Guideline 2.2 Enough Time](https://www.w3.org/TR/WCAG21/#enough-time). If a [=client platform=] determines that a [=[RP]=]-supplied timeout does not appropriately adhere to the latter [[!WCAG21]] guidelines, then the [=client platform=] MAY adjust the timeout accordingly.


# Acknowledgements # {#sctn-acknowledgements}
We thank the following people for their reviews of, and contributions to, this specification:
Yuriy Ackermann,
James Barclay,
Richard Barnes,
Dominic Battré,
Julien Cayzac,
Domenic Denicola,
Rahul Ghosh,
Brad Hill,
Nidhi Jaju,
Jing Jin,
Wally Jones,
Ian Kilpatrick,
Axel Nennker,
Yoshikazu Nojima,
Kimberly Paulhamus,
Adam Powers,
Yaron Sheffer,
Ki-Eun Shin,
Anne van Kesteren,
Johan Verrept,
and
Boris Zbarsky.

Thanks to Adam Powers for creating the overall [=registration=] and [=authentication=] flow diagrams
([Figure 1](#fig-registration) and [Figure 2](#fig-authentication)).

We thank
Anthony Nadalin,
John Fontana,
and
Richard Barnes
for their contributions as co-chairs of the <a href="https://www.w3.org/Webauthn/">Web Authentication Working Group</a>.

We also thank
Wendy Seltzer,
Samuel Weiler,
and
Harry Halpin
for their contributions as our W3C Team Contacts.


<pre class=biblio>
{

  "UTR29": {
    "href": "http://www.unicode.org/reports/tr29/",
    "title": "UNICODE Text Segmentation",
    "publisher": "UNICODE Consortium"
  },


  "IANA-COSE-ALGS-REG": {
    "href": "https://www.iana.org/assignments/cose/cose.xhtml#algorithms",
    "title": "IANA CBOR Object Signing and Encryption (COSE) Algorithms Registry",
    "publisher": "IANA"
  },


  "WebAuthnAPIGuide": {
    "href": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API",
    "title": "Web Authentication API Guide",
    "publisher": "MDN: Mozilla Developer Network",
    "status": "Experimental"
  },

  "Ceremony": {
    "title": "Ceremony Design and Analysis",
    "href": "https://eprint.iacr.org/2007/399.pdf",
    "authors": ["Carl Ellison"],
    "date": "2007"
  },

  "RFC8809": {
    "authors": [
        "Jeff Hodges",
        "Giridhar Mandyam",
        "Michael B. Jones"
    ],
    "date": "August 2020",
    "href": "https://www.rfc-editor.org/rfc/rfc8809",
    "publisher": "IETF",
    "status": "IETF Proposed Standard",
    "title": "Registries for Web Authentication (WebAuthn)"
  },

  "IANA-WebAuthn-Registries": {
    "authors": [
        "IANA"
    ],
    "href": "https://www.iana.org/assignments/webauthn/",
    "title": "Web Authentication (WebAuthn) registries"
  },

  "SP800-800-63r3": {
    "title": "NIST Special Publication 800-63: Digital Identity Guidelines",
    "href": "https://pages.nist.gov/800-63-3/sp800-63-3.html",
    "authors": ["Paul A. Grassi", "Michael E. Garcia", "James L. Fenton"],
    "date": "June 2017"
  },

  "UAFProtocol": {
    "authors": ["R. Lindemann", "D. Baghdasaryan", "E. Tiffany", "D. Balfanz", "B. Hill", "J. Hodges"],
    "title": "FIDO UAF Protocol Specification v1.0",
    "status": "FIDO Alliance Proposed Standard",
    "href": "https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-protocol-v1.0-ps-20141208.html"
  },

  "SEC1": {
    "title": "SEC1: Elliptic Curve Cryptography, Version 2.0",
    "publisher": "Standards for Efficient Cryptography Group",
    "href": "http://www.secg.org/sec1-v2.pdf"
  },

  "FIDOMetadataService": {
    "authors": ["R. Lindemann", "B. Hill", "D. Baghdasaryan"],
    "title": "FIDO Metadata Service",
    "href": "https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-metadata-service-v2.0-id-20180227.html",
    "status": "FIDO Alliance Implementation Draft",
    "date": "27 February 2018"
  },

  "FIDOU2FJavaScriptAPI": {
    "authors": ["D. Balfanz", "A. Birgisson", "J. Lang"],
    "title": "FIDO U2F JavaScript API",
    "href": "https://fidoalliance.org/specs/fido-u2f-v1.2-ps-20170411/fido-u2f-javascript-api-v1.2-ps-20170411.html",
    "status": "FIDO Alliance Proposed Standard"
  },

  "TPMv2-Part1": {
    "title": "Trusted Platform Module Library, Part 1: Architecture",
    "publisher": "Trusted Computing Group",
    "href": "https://www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-1-Architecture-01.38.pdf"
  },

  "TPMv2-Part2": {
    "title": "Trusted Platform Module Library, Part 2: Structures",
    "publisher": "Trusted Computing Group",
    "href": "https://www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-01.38.pdf"
  },

  "TPMv2-Part3": {
    "title": "Trusted Platform Module Library, Part 3: Commands",
    "publisher": "Trusted Computing Group",
    "href": "https://www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-3-Commands-01.38.pdf"
  },

  "TPMv2-EK-Profile": {
    "title": "TCG EK Credential Profile for TPM Family 2.0",
    "publisher": "Trusted Computing Group",
    "href": "https://www.trustedcomputinggroup.org/wp-content/uploads/Credential_Profile_EK_V2.0_R14_published.pdf"
  },

  "FIDOAuthnrSecReqs": {
    "authors": ["D. Biggs", "J.E. Hill", "L. Lundblade", "M. Karlsson"],
    "title": "FIDO Authenticator Security Requirements",
    "href": "https://fidoalliance.org/specs/fido-security-requirements-v1.0-fd-20170524/",
    "status": "FIDO Alliance Final Documents"
  },

  "FIDOSecRef": {
    "authors": ["R. Lindemann", "D. Baghdasaryan", "B. Hill", "Dr. J. E. Hill", "D. Biggs"],
    "title": "FIDO Security Reference",
    "href": "https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html",
    "status": "FIDO Alliance Implementation Draft",
    "date": "27 February 2018"
  },

  "FIDO-Registry": {
    "authors": ["R. Lindemann", "D. Baghdasaryan", "B. Hill"],
    "title": "FIDO Registry of Predefined Values",
    "href": "https://fidoalliance.org/specs/common-specs/fido-registry-v2.1-ps-20191217.html",
    "status": "FIDO Alliance Proposed Standard",
    "date": "17 December 2019"
  },

  "FIDO-APPID": {
    "authors": ["D. Balfanz", "B. Hill", "R. Lindemann", "D. Baghdasaryan"],
    "title": "FIDO AppID and Facet Specification",
    "href": "https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-appid-and-facets-v2.0-id-20180227.html",
    "status": "FIDO Alliance Implementation Draft",
    "date": "27 February 2018"
  },

  "FIDO-U2F-Message-Formats": {
    "authors": ["D. Balfanz", "J. Ehrensvard", "J. Lang"],
    "title": "FIDO U2F Raw Message Formats",
    "href": "https://fidoalliance.org/specs/fido-u2f-v1.1-id-20160915/fido-u2f-raw-message-formats-v1.1-id-20160915.html",
    "status": "FIDO Alliance Implementation Draft"
  },

  "FIDO-CTAP": {
    "authors": ["J. Bradley", "J. Hodges", "M. B. Jones", "A. Kumar", "R. Lindemann", "J. Verrept"],
    "title": "Client to Authenticator Protocol",
    "href": "https://fidoalliance.org/specs/fido-v2.1-rd-20210309/fido-client-to-authenticator-protocol-v2.1-rd-20210309.html",
    "status": "FIDO Alliance Review Draft",
    "date": "9 March 2021"
  },

  "FIDO-UAF-AUTHNR-CMDS": {
    "authors": ["R. Lindemann", "J. Kemp"],
    "title": "FIDO UAF Authenticator Commands",
    "href": "https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-authnr-cmds-v1.1-id-20170202.html",
    "status": "FIDO Alliance Implementation Draft"
  },

  "FIDO-Privacy-Principles": {
    "authors": ["FIDO Alliance"],
    "title": "FIDO Privacy Principles",
    "href": "https://fidoalliance.org/wp-content/uploads/2014/12/FIDO_Alliance_Whitepaper_Privacy_Principles.pdf",
    "status": "FIDO Alliance Whitepaper"
  },

  "FIDO-Transports-Ext": {
    "authors": ["FIDO Alliance"],
    "title": "FIDO U2F Authenticator Transports Extension",
    "href": "https://fidoalliance.org/specs/fido-u2f-v1.2-ps-20170411/fido-u2f-authenticator-transports-extension-v1.2-ps-20170411.html",
    "status": "FIDO Alliance Proposed Standard"
  },

  "RFC8610": {
    "authors": ["H. Birkholz", "C. Vigano", "C. Bormann"],
    "title": "Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures",
    "href": "https://tools.ietf.org/html/rfc8610",
    "status": "IETF Proposed Standard",
    "date": "June 2019"
  },

  "ISOBiometricVocabulary": {
    "authors": ["ISO/IEC JTC1/SC37"],
    "title": "Information technology — Vocabulary — Biometrics",
    "href": "http://standards.iso.org/ittf/PubliclyAvailableStandards/c055194_ISOIEC_2382-37_2012.zip",
    "status": "International Standard: ISO/IEC 2382-37:2012(E) First Edition",
    "date": "15 December 2012"
  },

  "TokenBinding": {
    "authors": ["A. Popov", "M. Nystroem", "D. Balfanz", "J. Hodges"],
    "title": "The Token Binding Protocol Version 1.0",
    "href": "https://tools.ietf.org/html/rfc8471",
    "status": "IETF Proposed Standard",
    "date": "October, 2018"
  },

  "EduPersonObjectClassSpec": {
    "publisher": "Research and Education FEDerations group - REFEDS.org",
    "title": "EduPerson",
    "href": "https://refeds.org/eduperson",
    "date": "ongoing"
  }

}
</pre>
